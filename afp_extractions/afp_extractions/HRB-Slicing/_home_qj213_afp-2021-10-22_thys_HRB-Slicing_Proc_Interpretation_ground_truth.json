{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/Proc/Interpretation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma get_return_edges_non_call_empty:\n  \"\\<forall>Q r p fs. kind a \\<noteq> Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow> get_return_edges wfp a = {}\"", "lemma call_has_return_edge:\n  assumes \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  obtains a' where \"valid_edge wfp a'\" and \"\\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n  and \"targetnode a' = r\"", "lemma get_return_edges_call_nonempty:\n  \"\\<lbrakk>valid_edge wfp a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk> \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\"", "lemma only_return_edges_in_get_return_edges:\n  \"\\<lbrakk>valid_edge wfp a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges wfp a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], "translations": [["", "lemma get_return_edges_non_call_empty:\n  \"\\<forall>Q r p fs. kind a \\<noteq> Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow> get_return_edges wfp a = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q r p fs.\n       kind a \\<noteq>\n       Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n    get_return_edges wfp a = {}", "by(cases \"kind a\",auto simp:get_return_edges_def)"], ["", "lemma call_has_return_edge:\n  assumes \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n  obtains a' where \"valid_edge wfp a'\" and \"\\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n  and \"targetnode a' = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge wfp a';\n         \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         targetnode a' = r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q' f'.\n           kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n       targetnode a' = r", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain prog procs where \"Rep_wf_prog wfp = (prog,procs)\"\n    and \"prog,procs \\<turnstile> sourcenode a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n         prog,procs \\<turnstile> sourcenode\n                                  a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n               a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  prog,procs \\<turnstile> sourcenode\n                           a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n        a\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q' f'.\n           kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n       targetnode a' = r", "from \\<open>prog,procs \\<turnstile> sourcenode a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode a\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode\n                           a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n        a", "show \"\\<exists>a'. valid_edge wfp a' \\<and> (\\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and> targetnode a' = r\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode\n                           a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n        a\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q' f'.\n           kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n       targetnode a' = r", "proof(induct \"sourcenode a\" \"Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "case (MainCall l es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (Main, n') = r\n  map interpret es = fs\n  (p, Entry) = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain l' \n      where [simp]:\"n' = Label l'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n' = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  n' = Label l'\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "from MainCall"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (Main, n') = r\n  map interpret es = fs\n  (p, Entry) = targetnode a", "have \"prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (Main,Label l'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label l')\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (Main, n') = r\n  map interpret es = fs\n  (p, Entry) = targetnode a\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n    snd cf =\n    (Main,\n     Label\n      l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n       map cf outs)\\<rightarrow> (Main, Label l')", "by(fastforce intro:MainReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n     map cf outs)\\<rightarrow> (Main, Label l')\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(Main, n') = r\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (Main, n') = r\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n     map cf outs)\\<rightarrow> (Main, Label l')", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (Main, n') = r\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n     map cf outs)\\<rightarrow> (Main, Label l')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q' f'.\n           kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n       targetnode a' = r", "by(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q' f'.\n         kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n     targetnode a' = r\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "case (ProcCall px ins outs c l es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (px, Label l') = r\n  map interpret es' = fs\n  (p, Entry) = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "from ProcCall"], ["proof (chain)\npicking this:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (px, Label l') = r\n  map interpret es' = fs\n  (p, Entry) = targetnode a", "have \"prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (px,Label l'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets' [:=] map cf outs'))\\<rightarrow> (px,Label l')\""], ["proof (prove)\nusing this:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (px, Label l') = r\n  map interpret es' = fs\n  (p, Entry) = targetnode a\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n    snd cf =\n    (px,\n     Label\n      l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n       map cf outs')\\<rightarrow> (px, Label l')", "by(fastforce intro:ProcReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (px,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n     map cf outs')\\<rightarrow> (px, Label l')\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(px, Label l') = r\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, Label l') = r\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (px,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n     map cf outs')\\<rightarrow> (px, Label l')", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, Label l') = r\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (px,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n     map cf outs')\\<rightarrow> (px, Label l')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q' f'.\n           kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n       targetnode a' = r", "by(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q' f'.\n         kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n     targetnode a' = r\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q' f'.\n                                kind a' =\n                                Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                            targetnode a' = r", "qed auto"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q' f'.\n         kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n     targetnode a' = r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma get_return_edges_call_nonempty:\n  \"\\<lbrakk>valid_edge wfp a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk> \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge wfp a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}", "by -(erule call_has_return_edge,(fastforce simp:get_return_edges_def)+)"], ["", "lemma only_return_edges_in_get_return_edges:\n  \"\\<lbrakk>valid_edge wfp a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; a' \\<in> get_return_edges wfp a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_edge wfp a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n     a' \\<in> get_return_edges wfp a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q' f'.\n                         kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "by(cases \"kind a\",auto simp:get_return_edges_def)"], ["", "abbreviation lift_procs :: \"wf_prog \\<Rightarrow> (pname \\<times> vname list \\<times> vname list) list\"\n  where \"lift_procs wfp \\<equiv> let (prog,procs) = Rep_wf_prog wfp in\n  map (\\<lambda>x. (fst x,fst(snd x),fst(snd(snd x)))) procs\""], ["", "subsection \\<open>Instatiation of the \\<open>CFG\\<close> locale\\<close>"], ["", "interpretation ProcCFG:\n  CFG sourcenode targetnode kind \"valid_edge wfp\" \"(Main,Entry)\"\n  get_proc \"get_return_edges wfp\" \"lift_procs wfp\" Main\n  for wfp"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n     (get_return_edges wfp) (lift_procs wfp) Main", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n     (get_return_edges wfp) (lift_procs wfp) Main", "from Rep_wf_prog[of wfp]"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp \\<in> wf_prog", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp \\<in> wf_prog\n\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:wf_prog_def)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n     (get_return_edges wfp) (lift_procs wfp) Main", "hence wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n     (get_return_edges wfp) (lift_procs wfp) Main", "show \"CFG sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n    get_proc (get_return_edges wfp) (lift_procs wfp) Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n     (get_return_edges wfp) (lift_procs wfp) Main", "proof"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; targetnode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. get_proc (Main, Entry) = Main\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 8. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> get_proc (sourcenode a) = p\nA total of 25 subgoals...", "fix a"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; targetnode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. get_proc (Main, Entry) = Main\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 8. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> get_proc (sourcenode a) = p\nA total of 25 subgoals...", "assume \"valid_edge wfp a\" and \"targetnode a = (Main, Entry)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  targetnode a = (Main, Entry)\n\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; targetnode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. get_proc (Main, Entry) = Main\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 8. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> get_proc (sourcenode a) = p\nA total of 25 subgoals...", "from this wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  targetnode a = (Main, Entry)\n  well_formed procs", "show False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  targetnode a = (Main, Entry)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. False", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  False\n\ngoal (24 subgoals):\n 1. get_proc (Main, Entry) = Main\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 7. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge wfp a' \\<and>\n                             targetnode a' = targetnode a \\<longrightarrow>\n                             (\\<exists>Qx rx fsx.\n                                 kind a' =\n                                 Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. get_proc (Main, Entry) = Main\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 7. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge wfp a' \\<and>\n                             targetnode a' = targetnode a \\<longrightarrow>\n                             (\\<exists>Qx rx fsx.\n                                 kind a' =\n                                 Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\nA total of 24 subgoals...", "show \"get_proc (Main, Entry) = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc (Main, Entry) = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (Main, Entry) = Main\n\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 6. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 6. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 6. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"sourcenode a = (Main, Entry)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = (Main, Entry)\n\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Entry)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 6. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 kind a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = (Main, Entry)\n\ngoal (1 subgoal):\n 1. False", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  False\n\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 5. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 5. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\nA total of 22 subgoals...", "fix a a'"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 5. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\nA total of 22 subgoals...", "assume \"valid_edge wfp a\" and \"valid_edge wfp a'\"\n      and \"sourcenode a = sourcenode a'\" and \"targetnode a = targetnode a'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 5. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\nA total of 22 subgoals...", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'", "show \"a = a'\""], ["proof (prove)\nusing this:\n  well_formed procs\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n\ngoal (1 subgoal):\n 1. a = a'", "by(cases a,cases a',auto dest:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 4. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> valid_edge wfp a'\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 4. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> valid_edge wfp a'\nA total of 21 subgoals...", "fix a Q r f"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 4. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> valid_edge wfp a'\nA total of 21 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 4. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> valid_edge wfp a'\nA total of 21 subgoals...", "from this wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\n  well_formed procs", "show False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\n  well_formed procs\n\ngoal (1 subgoal):\n 1. False", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  False\n\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 3. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 3. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "fix a Q' f'"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 3. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\n\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 3. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             kind a =\n                             Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "from this wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\n  well_formed procs", "show False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\n  well_formed procs\n\ngoal (1 subgoal):\n 1. False", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  False\n\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 2. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 2. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 2. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs) \\<in> set (lift_procs wfp)\n 2. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "thus \"\\<exists>ins outs. (p, ins, outs) \\<in> set (lift_procs wfp)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs. (p, ins, outs) \\<in> set (lift_procs wfp)", "apply(auto simp:valid_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode a;\n     kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ins outs.\n                         (p, ins, outs)\n                         \\<in> (\\<lambda>x.\n                                   (fst x, fst (snd x),\n                                    fst (snd (snd x)))) `\n                               set procs", "apply(erule PCFG.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, n);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = et;\n        targetnode a = (Main, n');\n        prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 2. \\<And>pa ins outs c n et n' ps.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (pa, n);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = et;\n        targetnode a = (pa, n'); (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, Label l);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es;\n        targetnode a = (pa, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (pa, Label l);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es';\n        targetnode a = (p', Entry); (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (pa, Exit);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs);\n        targetnode a = (Main, Label l');\n        prog \\<turnstile> Label\n                           l -CEdge\n                               (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (p', Exit);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs');\n        targetnode a = (pa, Label l'); (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (Main, n);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (Main, n');\n        prog \\<turnstile> n -CEdge\n                              (pa, es,\n                               rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        sourcenode a = (pa, n);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs =\n        (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (pa, n'); (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>sourcenode a = (Main, n);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a;\n        targetnode a = (Main, n');\n        prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>sourcenode a = (pa, n);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a;\n        targetnode a = (pa, n'); (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(Main,\n                         n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es;\n        sourcenode a = (Main, Label l); targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; Q = (\\<lambda>s. True);\n        r = (Main, n'); fs = map interpret es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply(fastforce dest:Proc_CFG_IEdge_intra_kind simp:intra_kind_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>sourcenode a = (pa, n);\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a;\n        targetnode a = (pa, n'); (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 2. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(Main,\n                         n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es;\n        sourcenode a = (Main, Label l); targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; Q = (\\<lambda>s. True);\n        r = (Main, n'); fs = map interpret es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply(fastforce dest:Proc_CFG_IEdge_intra_kind simp:intra_kind_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(Main,\n                         n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es;\n        sourcenode a = (Main, Label l); targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; Q = (\\<lambda>s. True);\n        r = (Main, n'); fs = map interpret es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 2. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply(rule_tac x=\"ins\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(Main,\n                         n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es;\n        sourcenode a = (Main, Label l); targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; Q = (\\<lambda>s. True);\n        r = (Main, n'); fs = map interpret es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs\n 2. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply(rule_tac x=\"outs\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(Main,\n                         n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es;\n        sourcenode a = (Main, Label l); targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; Q = (\\<lambda>s. True);\n        r = (Main, n'); fs = map interpret es\\<rbrakk>\n       \\<Longrightarrow> (p, ins, outs)\n                         \\<in> (\\<lambda>x.\n                                   (fst x, fst (snd x),\n                                    fst (snd (snd x)))) `\n                               set procs\n 2. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply(rule_tac x=\"(p,ins,outs,c)\" in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(Main,\n                         n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es;\n        sourcenode a = (Main, Label l); targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; Q = (\\<lambda>s. True);\n        r = (Main, n'); fs = map interpret es\\<rbrakk>\n       \\<Longrightarrow> (p, ins, outs) =\n                         (fst (p, ins, outs, c),\n                          fst (snd (p, ins, outs, c)),\n                          fst (snd (snd (p, ins, outs, c))))\n 2. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(Main,\n                         n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es;\n        sourcenode a = (Main, Label l); targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; Q = (\\<lambda>s. True);\n        r = (Main, n'); fs = map interpret es\\<rbrakk>\n       \\<Longrightarrow> (p, ins, outs, c) \\<in> set procs\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs.\n                            (p, ins, outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply(rule_tac x=\"ins'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>outs.\n                            (p, ins', outs)\n                            \\<in> (\\<lambda>x.\n(fst x, fst (snd x), fst (snd (snd x)))) `\n                                  set procs", "apply(rule_tac x=\"outs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> (p, ins', outs')\n                         \\<in> (\\<lambda>x.\n                                   (fst x, fst (snd x),\n                                    fst (snd (snd x)))) `\n                               set procs", "apply(rule_tac x=\"(p,ins',outs',c')\" in image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> (p, ins', outs') =\n                         (fst (p, ins', outs', c'),\n                          fst (snd (p, ins', outs', c')),\n                          fst (snd (snd (p, ins', outs', c'))))\n 2. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>kind a =\n                \\<lambda>s.\n                   True:(pa,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es';\n        sourcenode a = (pa, Label l); targetnode a = (p, Entry);\n        (pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        Q = (\\<lambda>s. True); r = (pa, Label l');\n        fs = map interpret es'\\<rbrakk>\n       \\<Longrightarrow> (p, ins', outs', c') \\<in> set procs", "by(auto simp:set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>ins outs. (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges wfp a'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges wfp a'\nA total of 18 subgoals...", "fix a"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges wfp a'\nA total of 18 subgoals...", "assume \"valid_edge wfp a\" and \"intra_kind (kind a)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  intra_kind (kind a)\n\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = get_proc (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             (\\<exists>Q r fs.\n                                 kind a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> get_return_edges wfp a'\nA total of 18 subgoals...", "thus \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(auto elim:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (targetnode a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = targetnode a \\<and>\n                             targetnode a'' = sourcenode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "thus \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "fix a Q' p f'"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> get_proc (sourcenode a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             valid_edge wfp a'' \\<and>\n                             sourcenode a'' = sourcenode a \\<and>\n                             targetnode a'' = targetnode a' \\<and>\n                             kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "thus \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             sourcenode a' = sourcenode a \\<and>\n                             intra_kind (kind a')\nA total of 15 subgoals...", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show \"\\<forall>a'. valid_edge wfp a' \\<and> targetnode a' = targetnode a \\<longrightarrow>\n      (\\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<longrightarrow>\n       (\\<exists>Qx rx fsx.\n           kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "case (MainCall l p' es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "from \\<open>\\<lambda>s. True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es = kind a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "{"], ["proof (state)\nthis:\n  p' = p\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "fix a'"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "assume \"valid_edge wfp a'\" and \"targetnode a' = (p', Entry)\""], ["proof (state)\nthis:\n  valid_edge wfp a'\n  targetnode a' = (p', Entry)\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "hence \"\\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  targetnode a' = (p', Entry)\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge wfp ?a'2; targetnode ?a'2 = (p', Entry)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       kind ?a'2 =\n                       Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "with \\<open>(p',Entry) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p', Entry) = targetnode a\n  \\<lbrakk>valid_edge wfp ?a'2; targetnode ?a'2 = (p', Entry)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       kind ?a'2 =\n                       Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "show ?case"], ["proof (prove)\nusing this:\n  (p', Entry) = targetnode a\n  \\<lbrakk>valid_edge wfp ?a'2; targetnode ?a'2 = (p', Entry)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       kind ?a'2 =\n                       Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<longrightarrow>\n       (\\<exists>Qx rx fsx.\n           kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge wfp a' \\<and> targetnode a' = targetnode a \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "case (ProcCall px ins outs c l p' es rets l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "from \\<open>\\<lambda>s. True:(px, Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es = kind a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "{"], ["proof (state)\nthis:\n  p' = p\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "fix a'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "assume \"valid_edge wfp a'\" and \"targetnode a' = (p', Entry)\""], ["proof (state)\nthis:\n  valid_edge wfp a'\n  targetnode a' = (p', Entry)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "hence \"\\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  targetnode a' = (p', Entry)\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge wfp ?a'2; targetnode ?a'2 = (p', Entry)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       kind ?a'2 =\n                       Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "with \\<open>(p', Entry) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p', Entry) = targetnode a\n  \\<lbrakk>valid_edge wfp ?a'2; targetnode ?a'2 = (p', Entry)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       kind ?a'2 =\n                       Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "show ?case"], ["proof (prove)\nusing this:\n  (p', Entry) = targetnode a\n  \\<lbrakk>valid_edge wfp ?a'2; targetnode ?a'2 = (p', Entry)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       kind ?a'2 =\n                       Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<longrightarrow>\n       (\\<exists>Qx rx fsx.\n           kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge wfp a' \\<and> targetnode a' = targetnode a \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                kind a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "qed auto"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge wfp a' \\<and> targetnode a' = targetnode a \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "fix a Q' p f'"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             valid_edge wfp a' \\<and>\n                             targetnode a' = targetnode a \\<and>\n                             intra_kind (kind a')\nA total of 14 subgoals...", "from this \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "show \"\\<forall>a'. valid_edge wfp a' \\<and> sourcenode a' = sourcenode a \\<longrightarrow>\n      (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<longrightarrow>\n       (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "case (MainReturn l p' es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins, outs, c) \\<in> set procs\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "from \\<open>\\<lambda>cf. snd cf = (Main, Label l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outs) =\n        kind a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "{"], ["proof (state)\nthis:\n  p' = p\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "fix a'"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "assume \"valid_edge wfp a'\" and \"sourcenode a' = (p', Exit)\""], ["proof (state)\nthis:\n  valid_edge wfp a'\n  sourcenode a' = (p', Exit)\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "hence \"\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  sourcenode a' = (p', Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge wfp ?a'2; sourcenode ?a'2 = (p', Exit)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       kind ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "with \\<open>(p', Exit) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  (p', Exit) = sourcenode a\n  \\<lbrakk>valid_edge wfp ?a'2; sourcenode ?a'2 = (p', Exit)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       kind ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "show ?case"], ["proof (prove)\nusing this:\n  (p', Exit) = sourcenode a\n  \\<lbrakk>valid_edge wfp ?a'2; sourcenode ?a'2 = (p', Exit)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       kind ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<longrightarrow>\n       (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge wfp a' \\<and> sourcenode a' = sourcenode a \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "case (ProcReturn px ins outs c l p' es rets l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs') =\n  kind a\n  (px, Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "from \\<open>\\<lambda>cf. snd cf = (px, Label l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outs') =\n        kind a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs') =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have [simp]:\"p' = p\""], ["proof (prove)\nusing this:\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs') =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "{"], ["proof (state)\nthis:\n  p' = p\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "fix a'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "assume \"valid_edge wfp a'\" and \"sourcenode a' = (p', Exit)\""], ["proof (state)\nthis:\n  valid_edge wfp a'\n  sourcenode a' = (p', Exit)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "hence \"\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  sourcenode a' = (p', Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_edge wfp ?a'2; sourcenode ?a'2 = (p', Exit)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       kind ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "with \\<open>(p', Exit) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  (p', Exit) = sourcenode a\n  \\<lbrakk>valid_edge wfp ?a'2; sourcenode ?a'2 = (p', Exit)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       kind ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "show ?case"], ["proof (prove)\nusing this:\n  (p', Exit) = sourcenode a\n  \\<lbrakk>valid_edge wfp ?a'2; sourcenode ?a'2 = (p', Exit)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       kind ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<longrightarrow>\n       (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge wfp a' \\<and> sourcenode a' = sourcenode a \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                kind a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "qed auto"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge wfp a' \\<and> sourcenode a' = sourcenode a \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_return_edges wfp a \\<noteq> {}\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         kind a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         kind a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> targetnode a = targetnode a'\nA total of 13 subgoals...", "thus \"get_return_edges wfp a \\<noteq> {}\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_return_edges wfp a \\<noteq> {}", "by(rule get_return_edges_call_nonempty)"], ["proof (state)\nthis:\n  get_return_edges wfp a \\<noteq> {}\n\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. distinct_fst (lift_procs wfp)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. distinct_fst (lift_procs wfp)\nA total of 12 subgoals...", "fix a a'"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. distinct_fst (lift_procs wfp)\nA total of 12 subgoals...", "assume \"valid_edge wfp a\" and \"a' \\<in> get_return_edges wfp a\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> valid_edge wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 10. distinct_fst (lift_procs wfp)\nA total of 12 subgoals...", "thus \"valid_edge wfp a'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (1 subgoal):\n 1. valid_edge wfp a'", "by(cases \"kind a\",auto simp:get_return_edges_def)"], ["proof (state)\nthis:\n  valid_edge wfp a'\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. distinct_fst (lift_procs wfp)\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. distinct_fst (lift_procs wfp)\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "fix a a'"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. distinct_fst (lift_procs wfp)\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "assume \"valid_edge wfp a\" and \"a' \\<in> get_return_edges wfp a\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 9. distinct_fst (lift_procs wfp)\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct ins\nA total of 11 subgoals...", "thus \"\\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(cases \"kind a\")(auto simp:get_return_edges_def)"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. distinct_fst (lift_procs wfp)\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct outs", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. distinct_fst (lift_procs wfp)\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct outs", "fix a Q r p fs a'"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. distinct_fst (lift_procs wfp)\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct outs", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"a' \\<in> get_return_edges wfp a\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges wfp a\n\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 8. distinct_fst (lift_procs wfp)\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n        distinct outs", "thus \"\\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges wfp a\n\ngoal (1 subgoal):\n 1. \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "by(rule only_return_edges_in_get_return_edges)"], ["proof (state)\nthis:\n  \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. distinct_fst (lift_procs wfp)\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. distinct_fst (lift_procs wfp)\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix a Q' p f'"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. distinct_fst (lift_procs wfp)\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. distinct_fst (lift_procs wfp)\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 7. distinct_fst (lift_procs wfp)\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from this \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "show \"\\<exists>!a'. valid_edge wfp a' \\<and> (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n      a \\<in> get_return_edges wfp a'\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges wfp a'", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "case (MainReturn l px es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins, outs, c) \\<in> set procs\n  (px, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>\\<lambda>cf. snd cf = (Main, Label l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outs) =\n        kind a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have [simp]:\"px = p\""], ["proof (prove)\nusing this:\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. px = p", "by simp"], ["proof (state)\nthis:\n  px = p\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"l' = Suc l\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. l' = Suc l", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  l' = Suc l\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs prog [] px\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] px", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] px\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "with \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>\n        \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px", "have \"prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (Main,Label l'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n        (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label l')\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n    snd cf =\n    (Main,\n     Label\n      l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n       map cf outs)\\<rightarrow> (Main, Label l')", "by(fastforce intro:PCFG.MainReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n     map cf outs)\\<rightarrow> (Main, Label l')\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "with \\<open>(px, Exit) = sourcenode a\\<close> \\<open>(Main, Label l') = targetnode a\\<close>\n        \\<open>\\<lambda>cf. snd cf = (Main, Label l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outs) =\n        kind a\\<close>"], ["proof (chain)\npicking this:\n  (px, Exit) = sourcenode a\n  (Main, Label l') = targetnode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n     map cf outs)\\<rightarrow> (Main, Label l')", "have edge:\"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  (px, Exit) = sourcenode a\n  (Main, Label l') = targetnode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n     map cf outs)\\<rightarrow> (Main, Label l')\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by simp"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>\n        \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins, outs, c) \\<in> set procs", "have edge':\"prog,procs \\<turnstile> (Main,Label l) \n        -(\\<lambda>s. True):(Main,Label l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es\\<rightarrow> (p,Entry)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (Main,\n                             Label\n                              l) -\\<lambda>s.\n                                     True:(Main,\n     Label\n      l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      es\\<rightarrow> (p, Entry)", "by(fastforce intro:MainCall)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    es\\<rightarrow> (p, Entry)\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges wfp a'", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges wfp a'\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from edge edge' \\<open>(Main, Label l') = targetnode a\\<close> \n          \\<open>l' = Suc l\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    es\\<rightarrow> (p, Entry)\n  (Main, Label l') = targetnode a\n  l' = Suc l\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "show \"\\<exists>a'. valid_edge wfp a' \\<and>\n          (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges wfp a'\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    es\\<rightarrow> (p, Entry)\n  (Main, Label l') = targetnode a\n  l' = Suc l\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges wfp a'", "by(fastforce simp:valid_edge_def get_return_edges_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges wfp a'\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge wfp a' \\<and>\n          (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges wfp a'\"\n          and \"valid_edge wfp a'' \\<and>\n          (\\<exists>Q r fs. kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges wfp a''\""], ["proof (state)\nthis:\n  valid_edge wfp a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a''\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "then"], ["proof (chain)\npicking this:\n  valid_edge wfp a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a''", "obtain Q r fs Q' r' fs' where \"valid_edge wfp a'\"\n          and \"kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a \\<in> get_return_edges wfp a'\"\n          and \"valid_edge wfp a''\" and \"kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\"\n          and \"a \\<in> get_return_edges wfp a''\""], ["proof (prove)\nusing this:\n  valid_edge wfp a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a''\n\ngoal (1 subgoal):\n 1. (\\<And>Q r fs Q' r' fs'.\n        \\<lbrakk>valid_edge wfp a';\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a \\<in> get_return_edges wfp a'; valid_edge wfp a'';\n         kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         a \\<in> get_return_edges wfp a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge wfp a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a''\n  kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges wfp a''\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>[THEN sym] edge wf \\<open>l' = Suc l\\<close>\n          \\<open>a \\<in> get_return_edges wfp a'\\<close> \\<open>(Main, Label l') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a'\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  well_formed procs\n  l' = Suc l\n  a \\<in> get_return_edges wfp a'\n  (Main, Label l') = targetnode a", "have nodes:\"sourcenode a' = (Main,Label l) \\<and> targetnode a' = (p,Entry)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a'\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  well_formed procs\n  l' = Suc l\n  a \\<in> get_return_edges wfp a'\n  (Main, Label l') = targetnode a\n\ngoal (1 subgoal):\n 1. sourcenode a' = (Main, Label l) \\<and> targetnode a' = (p, Entry)", "apply(auto simp:valid_edge_def get_return_edges_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na' -kind a'\\<rightarrow> targetnode a';\n     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a';\n     prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a;\n     well_formed procs; l' = Suc l;\n     a \\<in> (case kind a' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     (Main, Label (Suc l)) = targetnode a\\<rbrakk>\n    \\<Longrightarrow> sourcenode a' = (Main, Label l)\n 2. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na' -kind a'\\<rightarrow> targetnode a';\n     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a';\n     prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a;\n     well_formed procs; l' = Suc l;\n     a \\<in> (case kind a' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     (Main, Label (Suc l)) = targetnode a\\<rbrakk>\n    \\<Longrightarrow> targetnode a' = (p, Entry)", "by(erule PCFG.cases,auto dest:Proc_CFG_Call_Labels)+"], ["proof (state)\nthis:\n  sourcenode a' = (Main, Label l) \\<and> targetnode a' = (p, Entry)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a''\\<close> \\<open>kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>[THEN sym] \\<open>l' = Suc l\\<close>\n            \\<open>a \\<in> get_return_edges wfp a''\\<close> \\<open>(Main, Label l') = targetnode a\\<close> wf edge'"], ["proof (chain)\npicking this:\n  valid_edge wfp a''\n  Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a''\n  l' = Suc l\n  a \\<in> get_return_edges wfp a''\n  (Main, Label l') = targetnode a\n  well_formed procs\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    es\\<rightarrow> (p, Entry)", "have nodes':\"sourcenode a'' = (Main,Label l) \\<and> targetnode a'' = (p,Entry)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a''\n  Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a''\n  l' = Suc l\n  a \\<in> get_return_edges wfp a''\n  (Main, Label l') = targetnode a\n  well_formed procs\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    es\\<rightarrow> (p, Entry)\n\ngoal (1 subgoal):\n 1. sourcenode a'' = (Main, Label l) \\<and> targetnode a'' = (p, Entry)", "apply(auto simp:valid_edge_def get_return_edges_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na'' -kind a''\\<rightarrow> targetnode a'';\n     Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a''; l' = Suc l;\n     a \\<in> (case kind a'' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     (Main, Label (Suc l)) = targetnode a; well_formed procs;\n     prog,procs \\<turnstile> (Main,\n                              Label\n                               l) -\\<lambda>s.\nTrue:targetnode\n      a\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    es\\<rightarrow> (p, Entry)\\<rbrakk>\n    \\<Longrightarrow> sourcenode a'' = (Main, Label l)\n 2. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na'' -kind a''\\<rightarrow> targetnode a'';\n     Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a''; l' = Suc l;\n     a \\<in> (case kind a'' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     (Main, Label (Suc l)) = targetnode a; well_formed procs;\n     prog,procs \\<turnstile> (Main,\n                              Label\n                               l) -\\<lambda>s.\nTrue:targetnode\n      a\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    es\\<rightarrow> (p, Entry)\\<rbrakk>\n    \\<Longrightarrow> targetnode a'' = (p, Entry)", "by(erule PCFG.cases,auto dest:Proc_CFG_Call_Labels)+"], ["proof (state)\nthis:\n  sourcenode a'' = (Main, Label l) \\<and> targetnode a'' = (p, Entry)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with nodes \\<open>valid_edge wfp a'\\<close> \\<open>valid_edge wfp a''\\<close> wf"], ["proof (chain)\npicking this:\n  sourcenode a' = (Main, Label l) \\<and> targetnode a' = (p, Entry)\n  valid_edge wfp a'\n  valid_edge wfp a''\n  well_formed procs\n  sourcenode a'' = (Main, Label l) \\<and> targetnode a'' = (p, Entry)", "have \"kind a' = kind a''\""], ["proof (prove)\nusing this:\n  sourcenode a' = (Main, Label l) \\<and> targetnode a' = (p, Entry)\n  valid_edge wfp a'\n  valid_edge wfp a''\n  well_formed procs\n  sourcenode a'' = (Main, Label l) \\<and> targetnode a'' = (p, Entry)\n\ngoal (1 subgoal):\n 1. kind a' = kind a''", "by(fastforce dest:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  kind a' = kind a''\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with nodes nodes'"], ["proof (chain)\npicking this:\n  sourcenode a' = (Main, Label l) \\<and> targetnode a' = (p, Entry)\n  sourcenode a'' = (Main, Label l) \\<and> targetnode a'' = (p, Entry)\n  kind a' = kind a''", "show \"a' = a''\""], ["proof (prove)\nusing this:\n  sourcenode a' = (Main, Label l) \\<and> targetnode a' = (p, Entry)\n  sourcenode a'' = (Main, Label l) \\<and> targetnode a'' = (p, Entry)\n  kind a' = kind a''\n\ngoal (1 subgoal):\n 1. a' = a''", "by(cases a',cases a'',auto)"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges wfp a'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "case (ProcReturn p' ins outs c l px esx retsx l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'\n  (px, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p',\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n         map cf outs') =\n  kind a\n  (p', Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>\\<lambda>cf. snd cf = (p', Label l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=] map cf outs') =\n        kind a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>cf.\n     snd cf =\n     (p',\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n         map cf outs') =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have [simp]:\"px = p\""], ["proof (prove)\nusing this:\n  \\<lambda>cf.\n     snd cf =\n     (p',\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n         map cf outs') =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. px = p", "by simp"], ["proof (state)\nthis:\n  px = p\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>c \\<turnstile> Label l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'", "have \"l' = Suc l\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. l' = Suc l", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  l' = Suc l\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>(p',ins,outs,c) \\<in> set procs\\<close>\n        \\<open>c \\<turnstile> Label l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\\<close> \n        \\<open>(px, ins', outs', c') \\<in> set procs\\<close> \\<open>containsCall procs prog ps p'\\<close>"], ["proof (chain)\npicking this:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'", "have \"prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (p',Label l'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n        (\\<lambda>cf cf'. cf'(retsx [:=] map cf outs'))\\<rightarrow> (p',Label l')\""], ["proof (prove)\nusing this:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n    snd cf =\n    (p',\n     Label\n      l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n       map cf outs')\\<rightarrow> (p', Label l')", "by(fastforce intro:PCFG.ProcReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n     map cf outs')\\<rightarrow> (p', Label l')\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "with \\<open>(px, Exit) = sourcenode a\\<close> \\<open>(p', Label l') = targetnode a\\<close>\n        \\<open>\\<lambda>cf. snd cf = (p', Label l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=] map cf outs') =\n        kind a\\<close>"], ["proof (chain)\npicking this:\n  (px, Exit) = sourcenode a\n  (p', Label l') = targetnode a\n  \\<lambda>cf.\n     snd cf =\n     (p',\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n         map cf outs') =\n  kind a\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n     map cf outs')\\<rightarrow> (p', Label l')", "have edge:\"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  (px, Exit) = sourcenode a\n  (p', Label l') = targetnode a\n  \\<lambda>cf.\n     snd cf =\n     (p',\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n         map cf outs') =\n  kind a\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n     map cf outs')\\<rightarrow> (p', Label l')\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by simp"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "from \\<open>(p',ins,outs,c) \\<in> set procs\\<close>\n        \\<open>c \\<turnstile> Label l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\\<close>\n        \\<open>(px, ins', outs', c') \\<in> set procs\\<close> \\<open>containsCall procs prog ps p'\\<close>"], ["proof (chain)\npicking this:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'", "have edge':\"prog,procs \\<turnstile> (p',Label l) \n        -(\\<lambda>s. True):(p',Label l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) esx\\<rightarrow> (p,Entry)\""], ["proof (prove)\nusing this:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p',\n                             Label\n                              l) -\\<lambda>s.\n                                     True:(p',\n     Label\n      l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      esx\\<rightarrow> (p, Entry)", "by(fastforce intro:ProcCall)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p',\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(p',\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    esx\\<rightarrow> (p, Entry)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges wfp a'", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges wfp a'\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from edge edge' \\<open>(p', Label l') = targetnode a\\<close> \\<open>l' = Suc l\\<close>\n          \\<open>(p', ins, outs, c) \\<in> set procs\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  prog,procs \\<turnstile> (p',\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(p',\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    esx\\<rightarrow> (p, Entry)\n  (p', Label l') = targetnode a\n  l' = Suc l\n  (p', ins, outs, c) \\<in> set procs\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "show \"\\<exists>a'. valid_edge wfp a' \\<and>\n          (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges wfp a'\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  prog,procs \\<turnstile> (p',\n                           Label\n                            l) -\\<lambda>s.\n                                   True:(p',\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n    esx\\<rightarrow> (p, Entry)\n  (p', Label l') = targetnode a\n  l' = Suc l\n  (p', ins, outs, c) \\<in> set procs\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges wfp a'", "by(fastforce simp:valid_edge_def get_return_edges_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges wfp a'\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge wfp a' \\<and>\n          (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges wfp a'\"\n          and \"valid_edge wfp a'' \\<and>\n          (\\<exists>Q r fs. kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> get_return_edges wfp a''\""], ["proof (state)\nthis:\n  valid_edge wfp a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a''\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "then"], ["proof (chain)\npicking this:\n  valid_edge wfp a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a''", "obtain Q r fs Q' r' fs' where \"valid_edge wfp a'\"\n          and \"kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"a \\<in> get_return_edges wfp a'\"\n          and \"valid_edge wfp a''\" and \"kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\"\n          and \"a \\<in> get_return_edges wfp a''\""], ["proof (prove)\nusing this:\n  valid_edge wfp a' \\<and>\n  (\\<exists>Q r fs.\n      kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a'' \\<and>\n  (\\<exists>Q r fs.\n      kind a'' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n  a \\<in> get_return_edges wfp a''\n\ngoal (1 subgoal):\n 1. (\\<And>Q r fs Q' r' fs'.\n        \\<lbrakk>valid_edge wfp a';\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a \\<in> get_return_edges wfp a'; valid_edge wfp a'';\n         kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         a \\<in> get_return_edges wfp a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge wfp a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a \\<in> get_return_edges wfp a'\n  valid_edge wfp a''\n  kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges wfp a''\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>[THEN sym] \n          \\<open>a \\<in> get_return_edges wfp a'\\<close> edge \\<open>(p', Label l') = targetnode a\\<close> wf\n          \\<open>(p', ins, outs, c) \\<in> set procs\\<close> \\<open>l' = Suc l\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a'\n  a \\<in> get_return_edges wfp a'\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (p', Label l') = targetnode a\n  well_formed procs\n  (p', ins, outs, c) \\<in> set procs\n  l' = Suc l", "have nodes:\"sourcenode a' = (p',Label l) \\<and> targetnode a' = (p,Entry)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a'\n  a \\<in> get_return_edges wfp a'\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (p', Label l') = targetnode a\n  well_formed procs\n  (p', ins, outs, c) \\<in> set procs\n  l' = Suc l\n\ngoal (1 subgoal):\n 1. sourcenode a' = (p', Label l) \\<and> targetnode a' = (p, Entry)", "apply(auto simp:valid_edge_def get_return_edges_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na' -kind a'\\<rightarrow> targetnode a';\n     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a';\n     a \\<in> (case kind a' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a;\n     (p', Label (Suc l)) = targetnode a; well_formed procs;\n     (p', ins, outs, c) \\<in> set procs; l' = Suc l\\<rbrakk>\n    \\<Longrightarrow> sourcenode a' = (p', Label l)\n 2. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na' -kind a'\\<rightarrow> targetnode a';\n     Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs = kind a';\n     a \\<in> (case kind a' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a;\n     (p', Label (Suc l)) = targetnode a; well_formed procs;\n     (p', ins, outs, c) \\<in> set procs; l' = Suc l\\<rbrakk>\n    \\<Longrightarrow> targetnode a' = (p, Entry)", "by(erule PCFG.cases,auto dest:Proc_CFG_Call_Labels)+"], ["proof (state)\nthis:\n  sourcenode a' = (p', Label l) \\<and> targetnode a' = (p, Entry)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a''\\<close> \\<open>kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close>[THEN sym] \n          \\<open>a \\<in> get_return_edges wfp a''\\<close> edge \\<open>(p', Label l') = targetnode a\\<close> wf\n          \\<open>(p', ins, outs, c) \\<in> set procs\\<close> \\<open>l' = Suc l\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a''\n  Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a''\n  a \\<in> get_return_edges wfp a''\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (p', Label l') = targetnode a\n  well_formed procs\n  (p', ins, outs, c) \\<in> set procs\n  l' = Suc l", "have nodes':\"sourcenode a'' = (p',Label l) \\<and> targetnode a'' = (p,Entry)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a''\n  Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a''\n  a \\<in> get_return_edges wfp a''\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (p', Label l') = targetnode a\n  well_formed procs\n  (p', ins, outs, c) \\<in> set procs\n  l' = Suc l\n\ngoal (1 subgoal):\n 1. sourcenode a'' = (p', Label l) \\<and> targetnode a'' = (p, Entry)", "apply(auto simp:valid_edge_def get_return_edges_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na'' -kind a''\\<rightarrow> targetnode a'';\n     Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a'';\n     a \\<in> (case kind a'' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a;\n     (p', Label (Suc l)) = targetnode a; well_formed procs;\n     (p', ins, outs, c) \\<in> set procs; l' = Suc l\\<rbrakk>\n    \\<Longrightarrow> sourcenode a'' = (p', Label l)\n 2. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na'' -kind a''\\<rightarrow> targetnode a'';\n     Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs' = kind a'';\n     a \\<in> (case kind a'' of\n              Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Rightarrow>\n                {a'.\n                 valid_edge wfp a' \\<and>\n                 (\\<exists>Q' f'.\n                     kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f') \\<and>\n                 targetnode a' = r}\n              | _ \\<Rightarrow> {});\n     prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a;\n     (p', Label (Suc l)) = targetnode a; well_formed procs;\n     (p', ins, outs, c) \\<in> set procs; l' = Suc l\\<rbrakk>\n    \\<Longrightarrow> targetnode a'' = (p, Entry)", "by(erule PCFG.cases,auto dest:Proc_CFG_Call_Labels)+"], ["proof (state)\nthis:\n  sourcenode a'' = (p', Label l) \\<and> targetnode a'' = (p, Entry)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with nodes \\<open>valid_edge wfp a'\\<close> \\<open>valid_edge wfp a''\\<close> wf"], ["proof (chain)\npicking this:\n  sourcenode a' = (p', Label l) \\<and> targetnode a' = (p, Entry)\n  valid_edge wfp a'\n  valid_edge wfp a''\n  well_formed procs\n  sourcenode a'' = (p', Label l) \\<and> targetnode a'' = (p, Entry)", "have \"kind a' = kind a''\""], ["proof (prove)\nusing this:\n  sourcenode a' = (p', Label l) \\<and> targetnode a' = (p, Entry)\n  valid_edge wfp a'\n  valid_edge wfp a''\n  well_formed procs\n  sourcenode a'' = (p', Label l) \\<and> targetnode a'' = (p, Entry)\n\ngoal (1 subgoal):\n 1. kind a' = kind a''", "by(fastforce dest:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  kind a' = kind a''\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                (\\<exists>Q r fs.\n                    kind a' =\n                    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                a \\<in> get_return_edges wfp a';\n        valid_edge wfp y \\<and>\n        (\\<exists>Q r fs.\n            kind y = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n        a \\<in> get_return_edges wfp y\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with nodes nodes'"], ["proof (chain)\npicking this:\n  sourcenode a' = (p', Label l) \\<and> targetnode a' = (p, Entry)\n  sourcenode a'' = (p', Label l) \\<and> targetnode a'' = (p, Entry)\n  kind a' = kind a''", "show \"a' = a''\""], ["proof (prove)\nusing this:\n  sourcenode a' = (p', Label l) \\<and> targetnode a' = (p, Entry)\n  sourcenode a'' = (p', Label l) \\<and> targetnode a'' = (p, Entry)\n  kind a' = kind a''\n\ngoal (1 subgoal):\n 1. a' = a''", "by(cases a',cases a'',auto)"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges wfp a'\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'\n 6. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            (\\<exists>Q r fs.\n                                kind a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> get_return_edges wfp a'", "qed auto"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges wfp a'\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix a a'"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge wfp a\" and \"a' \\<in> get_return_edges wfp a\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "then"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a", "obtain Q r p fs l'\n      where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"valid_edge wfp a'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         valid_edge wfp a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"kind a\")(fastforce simp:valid_edge_def get_return_edges_def)+"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge wfp a'\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges wfp a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges wfp a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges wfp a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_return_edges_in_get_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "with \\<open>valid_edge wfp a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"sourcenode a' = (p,Exit)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. sourcenode a' = (p, Exit)", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  sourcenode a' = (p, Exit)\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"prog,procs \\<turnstile> sourcenode a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode\n                             a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n          a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode\n                           a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n        a\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 6. distinct_fst (lift_procs wfp)\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "thus \"\\<exists>a''. valid_edge wfp a'' \\<and> sourcenode a'' = targetnode a \\<and> \n      targetnode a'' = sourcenode a' \\<and> kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode\n                           a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n        a\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge wfp a'' \\<and>\n       sourcenode a'' = targetnode a \\<and>\n       targetnode a'' = sourcenode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "proof(induct \"sourcenode a\" \"Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "case (MainCall l es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (Main, n') = r\n  map interpret es = fs\n  (p, Entry) = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"c \\<turnstile> Entry -IEdge (\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<turnstile> Entry -IEdge\n                           (\\<lambda>s.\n                               False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit", "by(rule Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  c \\<turnstile> Entry -IEdge\n                         (\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "moreover"], ["proof (state)\nthis:\n  c \\<turnstile> Entry -IEdge\n                         (\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"containsCall procs prog [] p\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] p", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] p\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  c \\<turnstile> Entry -IEdge\n                         (\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n  containsCall procs prog [] p", "have \"prog,procs \\<turnstile> (p,Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p,Exit)\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Entry -IEdge\n                         (\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n  containsCall procs prog [] p\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n      False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)", "using \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (prove)\nusing this:\n  c \\<turnstile> Entry -IEdge\n                         (\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n  containsCall procs prog [] p\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n      False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)", "by(fastforce intro:Proc)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n    False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a' = (p,Exit)\\<close> \\<open>(p, Entry) = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a' = (p, Exit)\n  targetnode a = (p, Entry)\n  prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n    False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a' = (p, Exit)\n  targetnode a = (p, Entry)\n  prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n    False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge wfp a'' \\<and>\n       sourcenode a'' = targetnode a \\<and>\n       targetnode a'' = sourcenode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge wfp a'' \\<and>\n     sourcenode a'' = targetnode a \\<and>\n     targetnode a'' = sourcenode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "case (ProcCall px ins outs c l es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (px, Label l') = r\n  map interpret es' = fs\n  (p, Entry) = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"c' \\<turnstile> Entry -IEdge (\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c' \\<turnstile> Entry -IEdge\n                            (\\<lambda>s.\n                                False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit", "by(rule Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  c' \\<turnstile> Entry -IEdge\n                          (\\<lambda>s.\n                              False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "moreover"], ["proof (state)\nthis:\n  c' \\<turnstile> Entry -IEdge\n                          (\\<lambda>s.\n                              False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>c \\<turnstile> Label l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs c [] p\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs c [] p", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs c [] p\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>containsCall procs prog ps px\\<close> \\<open>(px,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p", "have \"containsCall procs prog (ps@[px]) p\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [px]) p", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [px]) p\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  c' \\<turnstile> Entry -IEdge\n                          (\\<lambda>s.\n                              False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n  containsCall procs prog (ps @ [px]) p", "have \"prog,procs \\<turnstile> (p,Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p,Exit)\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> Entry -IEdge\n                          (\\<lambda>s.\n                              False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n  containsCall procs prog (ps @ [px]) p\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n      False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)", "using \\<open>(p, ins', outs', c') \\<in> set procs\\<close>"], ["proof (prove)\nusing this:\n  c' \\<turnstile> Entry -IEdge\n                          (\\<lambda>s.\n                              False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\n  containsCall procs prog (ps @ [px]) p\n  (p, ins', outs', c') \\<in> set procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n      False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)", "by(fastforce intro:Proc)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n    False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a' = (p,Exit)\\<close> \\<open>(p, Entry) = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a' = (p, Exit)\n  targetnode a = (p, Entry)\n  prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n    False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a' = (p, Exit)\n  targetnode a = (p, Entry)\n  prog,procs \\<turnstile> (p, Entry) -(\\<lambda>s.\n    False)\\<^sub>\\<surd>\\<rightarrow> (p, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge wfp a'' \\<and>\n       sourcenode a'' = targetnode a \\<and>\n       targetnode a'' = sourcenode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge wfp a'' \\<and>\n     sourcenode a'' = targetnode a \\<and>\n     targetnode a'' = sourcenode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = targetnode a \\<and>\n                            targetnode a'' = sourcenode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "qed auto"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge wfp a'' \\<and>\n     sourcenode a'' = targetnode a \\<and>\n     targetnode a'' = sourcenode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. distinct_fst (lift_procs wfp)\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. distinct_fst (lift_procs wfp)\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix a a'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. distinct_fst (lift_procs wfp)\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge wfp a\" and \"a' \\<in> get_return_edges wfp a\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. distinct_fst (lift_procs wfp)\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "then"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a", "obtain Q r p fs l'\n      where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"valid_edge wfp a'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  a' \\<in> get_return_edges wfp a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         valid_edge wfp a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"kind a\")(fastforce simp:valid_edge_def get_return_edges_def)+"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge wfp a'\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. distinct_fst (lift_procs wfp)\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges wfp a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges wfp a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\" and \"targetnode a' = r\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges wfp a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        \\<lbrakk>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         targetnode a' = r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:get_return_edges_def)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  targetnode a' = r\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. distinct_fst (lift_procs wfp)\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"prog,procs \\<turnstile> sourcenode a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode\n                             a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n          a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode\n                           a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n        a\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; a' \\<in> get_return_edges wfp a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 5. distinct_fst (lift_procs wfp)\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "thus \"\\<exists>a''. valid_edge wfp a'' \\<and> sourcenode a'' = sourcenode a \\<and> \n      targetnode a'' = targetnode a' \\<and> kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode\n                           a -Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rightarrow> targetnode\n        a\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge wfp a'' \\<and>\n       sourcenode a'' = sourcenode a \\<and>\n       targetnode a'' = targetnode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "proof(induct \"sourcenode a\" \"Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "case (MainCall l es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (Main, n') = r\n  map interpret es = fs\n  (p, Entry) = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"prog,procs \\<turnstile> (Main,Label l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,n')\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (Main,\n                             Label\n                              l) -(\\<lambda>s.\nFalse)\\<^sub>\\<surd>\\<rightarrow> (Main, n')", "by(rule MainCallReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 n')\n\ngoal (4 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>l es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        (\\<lambda>s. True) = Q; (Main, n') = r; map interpret es = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym] \\<open>targetnode a' = r\\<close>\n        \\<open>(Main, n') = r\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, Label l)\n  targetnode a' = r\n  r = (Main, n')\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 n')", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = (Main, Label l)\n  targetnode a' = r\n  r = (Main, n')\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 n')\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge wfp a'' \\<and>\n       sourcenode a'' = sourcenode a \\<and>\n       targetnode a'' = targetnode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by(auto simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge wfp a'' \\<and>\n     sourcenode a'' = sourcenode a \\<and>\n     targetnode a'' = targetnode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "case (ProcCall px ins outs c l es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  (\\<lambda>s. True) = Q\n  (px, Label l') = r\n  map interpret es' = fs\n  (p, Entry) = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>(px,ins,outs,c) \\<in> set procs\\<close>         \\<open>containsCall procs prog ps px\\<close>\n        \\<open>c \\<turnstile> Label l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"prog,procs \\<turnstile> (px,Label l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (px,Label l')\""], ["proof (prove)\nusing this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  c \\<turnstile> Label\n                  l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (px,\n                             Label\n                              l) -(\\<lambda>s.\nFalse)\\<^sub>\\<surd>\\<rightarrow> (px, Label l')", "by(fastforce intro:ProcCallReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')\n\ngoal (3 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>pa ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps pa;\n        (pa, Label l) = sourcenode a; (\\<lambda>s. True) = Q;\n        (pa, Label l') = r; map interpret es' = fs;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>(px, Label l) = sourcenode a\\<close>[THEN sym] \\<open>targetnode a' = r\\<close>\n        \\<open>(px, Label l') = r\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (px, Label l)\n  targetnode a' = r\n  r = (px, Label l')\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = (px, Label l)\n  targetnode a' = r\n  r = (px, Label l')\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       valid_edge wfp a'' \\<and>\n       sourcenode a'' = sourcenode a \\<and>\n       targetnode a'' = targetnode a' \\<and>\n       kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by(auto simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge wfp a'' \\<and>\n     sourcenode a'' = sourcenode a \\<and>\n     targetnode a'' = targetnode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge\n                           (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            valid_edge wfp a'' \\<and>\n                            sourcenode a'' = sourcenode a \\<and>\n                            targetnode a'' = targetnode a' \\<and>\n                            kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "qed auto"], ["proof (state)\nthis:\n  \\<exists>a''.\n     valid_edge wfp a'' \\<and>\n     sourcenode a'' = sourcenode a \\<and>\n     targetnode a'' = targetnode a' \\<and>\n     kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. distinct_fst (lift_procs wfp)\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. distinct_fst (lift_procs wfp)\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix a Q r p fs"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. distinct_fst (lift_procs wfp)\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. distinct_fst (lift_procs wfp)\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 4. distinct_fst (lift_procs wfp)\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show \"\\<exists>!a'. valid_edge wfp a' \\<and>\n      sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')", "case (MainCall l p' es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"prog,procs \\<turnstile> (Main,Label l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,n')\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (Main,\n                             Label\n                              l) -(\\<lambda>s.\nFalse)\\<^sub>\\<surd>\\<rightarrow> (Main, n')", "by(rule MainCallReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 n')\n\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, Label l)\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 n')", "show \"\\<exists>a'. valid_edge wfp a' \\<and>\n          sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, Label l)\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 n')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "by(fastforce simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge wfp a' \\<and> sourcenode a' = sourcenode a \\<and> \n          intra_kind (kind a')\" and \"valid_edge wfp a'' \\<and>\n          sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\""], ["proof (state)\nthis:\n  valid_edge wfp a' \\<and>\n  sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "hence \"valid_edge wfp a'\" and \"sourcenode a' = sourcenode a\"\n          and \"intra_kind (kind a')\" and \"valid_edge wfp a''\"\n          and \"sourcenode a'' = sourcenode a\" and \"intra_kind (kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge wfp a' \\<and>\n  sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. (valid_edge wfp a' &&&\n     sourcenode a' = sourcenode a &&& intra_kind (kind a')) &&&\n    valid_edge wfp a'' &&&\n    sourcenode a'' = sourcenode a &&& intra_kind (kind a'')", "by simp_all"], ["proof (state)\nthis:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  intra_kind (kind a')\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a'\\<close> \\<open>sourcenode a' = sourcenode a\\<close>\n          \\<open>intra_kind (kind a')\\<close> \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n          \\<open>(Main, Label l) = sourcenode a\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  intra_kind (kind a')\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, Label l) = sourcenode a\n  well_formed procs", "have \"targetnode a' = (Main,Label (Suc l))\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  intra_kind (kind a')\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, Label l) = sourcenode a\n  well_formed procs\n\ngoal (1 subgoal):\n 1. targetnode a' = (Main, Label (Suc l))", "by(auto elim!:PCFG.cases dest:Proc_CFG_Call_Intra_edge_not_same_source \n            Proc_CFG_Call_Labels simp:intra_kind_def valid_edge_def)"], ["proof (state)\nthis:\n  targetnode a' = (Main, Label (Suc l))\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a''\\<close> \\<open>sourcenode a'' = sourcenode a\\<close>\n          \\<open>intra_kind (kind a'')\\<close> \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n          \\<open>(Main, Label l) = sourcenode a\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  intra_kind (kind a'')\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, Label l) = sourcenode a\n  well_formed procs", "have \"targetnode a'' = (Main,Label (Suc l))\""], ["proof (prove)\nusing this:\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  intra_kind (kind a'')\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, Label l) = sourcenode a\n  well_formed procs\n\ngoal (1 subgoal):\n 1. targetnode a'' = (Main, Label (Suc l))", "by(auto elim!:PCFG.cases dest:Proc_CFG_Call_Intra_edge_not_same_source \n            Proc_CFG_Call_Labels simp:intra_kind_def valid_edge_def)"], ["proof (state)\nthis:\n  targetnode a'' = (Main, Label (Suc l))\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>valid_edge wfp a'\\<close> \\<open>sourcenode a' = sourcenode a\\<close>\n          \\<open>valid_edge wfp a''\\<close> \\<open>sourcenode a'' = sourcenode a\\<close>\n          \\<open>targetnode a' = (Main,Label (Suc l))\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  targetnode a' = (Main, Label (Suc l))\n  well_formed procs\n  targetnode a'' = (Main, Label (Suc l))", "show \"a' = a''\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  targetnode a' = (Main, Label (Suc l))\n  well_formed procs\n  targetnode a'' = (Main, Label (Suc l))\n\ngoal (1 subgoal):\n 1. a' = a''", "by(cases a',cases a'')\n        (auto dest:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')", "case (ProcCall px ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>(px, ins, outs, c) \\<in> set procs\\<close> \\<open>containsCall procs prog ps px\\<close>\n          \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"prog,procs \\<turnstile> (px,Label l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (px,Label l')\""], ["proof (prove)\nusing this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (px,\n                             Label\n                              l) -(\\<lambda>s.\nFalse)\\<^sub>\\<surd>\\<rightarrow> (px, Label l')", "by -(rule ProcCallReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')\n\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>(px, Label l) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (px, Label l)\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')", "show \"\\<exists>a'. valid_edge wfp a' \\<and> sourcenode a' = sourcenode a \\<and> \n                   intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  sourcenode a = (px, Label l)\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "by(fastforce simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge wfp a' \\<and> sourcenode a' = sourcenode a \\<and> \n          intra_kind (kind a')\" and \"valid_edge wfp a'' \\<and>\n          sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\""], ["proof (state)\nthis:\n  valid_edge wfp a' \\<and>\n  sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "hence \"valid_edge wfp a'\" and \"sourcenode a' = sourcenode a\"\n          and \"intra_kind (kind a')\" and \"valid_edge wfp a''\"\n          and \"sourcenode a'' = sourcenode a\" and \"intra_kind (kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge wfp a' \\<and>\n  sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  sourcenode a'' = sourcenode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. (valid_edge wfp a' &&&\n     sourcenode a' = sourcenode a &&& intra_kind (kind a')) &&&\n    valid_edge wfp a'' &&&\n    sourcenode a'' = sourcenode a &&& intra_kind (kind a'')", "by simp_all"], ["proof (state)\nthis:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  intra_kind (kind a')\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a'\\<close> \\<open>sourcenode a' = sourcenode a\\<close>\n          \\<open>intra_kind (kind a')\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>\n          \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>\n          \\<open>(p', ins', outs', c') \\<in> set procs\\<close> wf\n          \\<open>containsCall procs prog ps px\\<close> \\<open>(px, Label l) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  intra_kind (kind a')\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a", "have \"targetnode a' = (px,Label (Suc l))\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  intra_kind (kind a')\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n\ngoal (1 subgoal):\n 1. targetnode a' = (px, Label (Suc l))", "apply(auto simp:valid_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na -kind a'\\<rightarrow> targetnode a';\n     sourcenode a' = sourcenode a; intra_kind (kind a');\n     (px, ins, outs, c) \\<in> set procs;\n     c \\<turnstile> Label\n                     l -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n     (p', ins', outs', c') \\<in> set procs; well_formed procs;\n     containsCall procs prog ps px; (px, Label l) = sourcenode a\\<rbrakk>\n    \\<Longrightarrow> targetnode a' = (px, Label (Suc l))", "apply(erule PCFG.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (Main, n); kind a' = et; targetnode a' = (Main, n');\n        prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))\n 2. \\<And>p insa outsa ca n et n' psa.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, n); kind a' = et; targetnode a' = (p, n');\n        (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))\n 3. \\<And>la p es rets n' insa outsa ca.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (Main, Label la);\n        kind a' =\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es;\n        targetnode a' = (p, Entry);\n        prog \\<turnstile> Label\n                           la -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))\n 4. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, Label la);\n        kind a' =\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es'a;\n        targetnode a' = (p'a, Entry); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))\n 5. \\<And>la p es rets l'a insa outsa ca.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, Exit);\n        kind a' =\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa);\n        targetnode a' = (Main, Label l'a);\n        prog \\<turnstile> Label\n                           la -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))\n 6. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p'a, Exit);\n        kind a' =\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets'a [:=] map cf outs'a);\n        targetnode a' = (p, Label l'a);\n        (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (Main, n);\n        kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a' = (Main, n');\n        prog \\<turnstile> n -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))\n 8. \\<And>p insa outsa ca n p'a es'a rets'a n' psa.\n       \\<lbrakk>sourcenode a' = sourcenode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, n); kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a' = (p, n'); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px, Label (Suc l))", "by(auto dest:Proc_CFG_Call_Intra_edge_not_same_source \n            Proc_CFG_Call_nodes_eq Proc_CFG_Call_Labels simp:intra_kind_def)"], ["proof (state)\nthis:\n  targetnode a' = (px, Label (Suc l))\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a''\\<close> \\<open>sourcenode a'' = sourcenode a\\<close>\n          \\<open>intra_kind (kind a'')\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>\n          \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>\n          \\<open>(p', ins', outs', c') \\<in> set procs\\<close> wf\n          \\<open>containsCall procs prog ps px\\<close> \\<open>(px, Label l) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  intra_kind (kind a'')\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a", "have \"targetnode a'' = (px,Label (Suc l))\""], ["proof (prove)\nusing this:\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  intra_kind (kind a'')\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n\ngoal (1 subgoal):\n 1. targetnode a'' = (px, Label (Suc l))", "apply(auto simp:valid_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na -kind a''\\<rightarrow> targetnode a'';\n     sourcenode a'' = sourcenode a; intra_kind (kind a'');\n     (px, ins, outs, c) \\<in> set procs;\n     c \\<turnstile> Label\n                     l -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n     (p', ins', outs', c') \\<in> set procs; well_formed procs;\n     containsCall procs prog ps px; (px, Label l) = sourcenode a\\<rbrakk>\n    \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))", "apply(erule PCFG.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (Main, n); kind a'' = et;\n        targetnode a'' = (Main, n');\n        prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))\n 2. \\<And>p insa outsa ca n et n' psa.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, n); kind a'' = et; targetnode a'' = (p, n');\n        (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))\n 3. \\<And>la p es rets n' insa outsa ca.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (Main, Label la);\n        kind a'' =\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es;\n        targetnode a'' = (p, Entry);\n        prog \\<turnstile> Label\n                           la -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))\n 4. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, Label la);\n        kind a'' =\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es'a;\n        targetnode a'' = (p'a, Entry); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))\n 5. \\<And>la p es rets l'a insa outsa ca.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, Exit);\n        kind a'' =\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa);\n        targetnode a'' = (Main, Label l'a);\n        prog \\<turnstile> Label\n                           la -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))\n 6. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p'a, Exit);\n        kind a'' =\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets'a [:=] map cf outs'a);\n        targetnode a'' = (p, Label l'a);\n        (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (Main, n);\n        kind a'' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a'' = (Main, n');\n        prog \\<turnstile> n -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))\n 8. \\<And>p insa outsa ca n p'a es'a rets'a n' psa.\n       \\<lbrakk>sourcenode a'' = sourcenode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        containsCall procs prog ps px; (px, Label l) = sourcenode a;\n        sourcenode a = (p, n); kind a'' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a'' = (p, n'); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> targetnode a'' = (px, Label (Suc l))", "by(auto dest:Proc_CFG_Call_Intra_edge_not_same_source \n            Proc_CFG_Call_nodes_eq Proc_CFG_Call_Labels simp:intra_kind_def)"], ["proof (state)\nthis:\n  targetnode a'' = (px, Label (Suc l))\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                sourcenode a' = sourcenode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        sourcenode y = sourcenode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>valid_edge wfp a'\\<close> \\<open>sourcenode a' = sourcenode a\\<close>\n          \\<open>valid_edge wfp a''\\<close> \\<open>sourcenode a'' = sourcenode a\\<close>\n          \\<open>targetnode a' = (px,Label (Suc l))\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  targetnode a' = (px, Label (Suc l))\n  well_formed procs\n  targetnode a'' = (px, Label (Suc l))", "show \"a' = a''\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  sourcenode a' = sourcenode a\n  valid_edge wfp a''\n  sourcenode a'' = sourcenode a\n  targetnode a' = (px, Label (Suc l))\n  well_formed procs\n  targetnode a'' = (px, Label (Suc l))\n\ngoal (1 subgoal):\n 1. a' = a''", "by(cases a',cases a'')\n        (auto dest:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            sourcenode a' = sourcenode a \\<and>\n                            intra_kind (kind a')", "qed auto"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. distinct_fst (lift_procs wfp)\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. distinct_fst (lift_procs wfp)\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix a Q' p f'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. distinct_fst (lift_procs wfp)\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. distinct_fst (lift_procs wfp)\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 3. distinct_fst (lift_procs wfp)\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from this \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "show \"\\<exists>!a'. valid_edge wfp a' \\<and>\n      targetnode a' = targetnode a \\<and> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')", "case (MainReturn l p' es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins, outs, c) \\<in> set procs\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"prog,procs \\<turnstile> (Main,Label l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> \n          (Main,Label l')\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (Main,\n                             Label\n                              l) -(\\<lambda>s.\nFalse)\\<^sub>\\<surd>\\<rightarrow> (Main, Label l')", "by(rule MainCallReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 Label l')\n\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>(Main, Label l') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (Main, Label l')\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 Label l')", "show \"\\<exists>a'. valid_edge wfp a' \\<and>\n          targetnode a' = targetnode a \\<and> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  targetnode a = (Main, Label l')\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                 Label l')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "by(fastforce simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge wfp a' \\<and> targetnode a' = targetnode a \\<and> \n          intra_kind (kind a')\" and \"valid_edge wfp a'' \\<and>\n          targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\""], ["proof (state)\nthis:\n  valid_edge wfp a' \\<and>\n  targetnode a' = targetnode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "hence \"valid_edge wfp a'\" and \"targetnode a' = targetnode a\"\n          and \"intra_kind (kind a')\" and \"valid_edge wfp a''\"\n          and \"targetnode a'' = targetnode a\" and \"intra_kind (kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge wfp a' \\<and>\n  targetnode a' = targetnode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. (valid_edge wfp a' &&&\n     targetnode a' = targetnode a &&& intra_kind (kind a')) &&&\n    valid_edge wfp a'' &&&\n    targetnode a'' = targetnode a &&& intra_kind (kind a'')", "by simp_all"], ["proof (state)\nthis:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a'\\<close> \\<open>targetnode a' = targetnode a\\<close>\n          \\<open>intra_kind (kind a')\\<close> \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>\n          \\<open>(Main, Label l') = targetnode a\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (Main, Label l') = targetnode a\n  well_formed procs", "have \"sourcenode a' = (Main,Label l)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (Main, Label l') = targetnode a\n  well_formed procs\n\ngoal (1 subgoal):\n 1. sourcenode a' = (Main, Label l)", "apply(auto elim!:PCFG.cases dest:Proc_CFG_Call_Intra_edge_not_same_target \n                      simp:valid_edge_def intra_kind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n p esa retsa.\n       \\<lbrakk>targetnode a' = (Main, Label l');\n        prog \\<turnstile> Label\n                           l -CEdge\n                               (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        well_formed procs; sourcenode a' = (Main, n);\n        kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (Main, Label l');\n        prog \\<turnstile> n -CEdge\n                              (p, esa,\n                               retsa)\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> n = Label l", "by(fastforce dest:Proc_CFG_Call_nodes_eq' Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  sourcenode a' = (Main, Label l)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a''\\<close> \\<open>targetnode a'' = targetnode a\\<close>\n          \\<open>intra_kind (kind a'')\\<close> \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>\n          \\<open>(Main, Label l') = targetnode a\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  intra_kind (kind a'')\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (Main, Label l') = targetnode a\n  well_formed procs", "have \"sourcenode a'' = (Main,Label l)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  intra_kind (kind a'')\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (Main, Label l') = targetnode a\n  well_formed procs\n\ngoal (1 subgoal):\n 1. sourcenode a'' = (Main, Label l)", "apply(auto elim!:PCFG.cases dest:Proc_CFG_Call_Intra_edge_not_same_target \n                      simp:valid_edge_def intra_kind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n p esa retsa.\n       \\<lbrakk>targetnode a'' = (Main, Label l');\n        prog \\<turnstile> Label\n                           l -CEdge\n                               (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        well_formed procs; sourcenode a'' = (Main, n);\n        kind a'' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (Main, Label l');\n        prog \\<turnstile> n -CEdge\n                              (p, esa,\n                               retsa)\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> n = Label l", "by(fastforce dest:Proc_CFG_Call_nodes_eq' Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  sourcenode a'' = (Main, Label l)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>valid_edge wfp a'\\<close> \\<open>targetnode a' = targetnode a\\<close>\n          \\<open>valid_edge wfp a''\\<close> \\<open>targetnode a'' = targetnode a\\<close>\n          \\<open>sourcenode a' = (Main,Label l)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  sourcenode a' = (Main, Label l)\n  well_formed procs\n  sourcenode a'' = (Main, Label l)", "show \"a' = a''\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  sourcenode a' = (Main, Label l)\n  well_formed procs\n  sourcenode a'' = (Main, Label l)\n\ngoal (1 subgoal):\n 1. a' = a''", "by(cases a',cases a'')\n        (auto dest:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')", "case (ProcReturn px ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n         map cf outs') =\n  kind a\n  (px, Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>(px, ins, outs, c) \\<in> set procs\\<close> \\<open>containsCall procs prog ps px\\<close>\n          \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"prog,procs \\<turnstile> (px,Label l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (px,Label l')\""], ["proof (prove)\nusing this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (px,\n                             Label\n                              l) -(\\<lambda>s.\nFalse)\\<^sub>\\<surd>\\<rightarrow> (px, Label l')", "by -(rule ProcCallReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')\n\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')\n 2. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>(px, Label l') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (px, Label l')\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')", "show \"\\<exists>a'. valid_edge wfp a' \\<and>\n          targetnode a' = targetnode a \\<and> intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  targetnode a = (px, Label l')\n  prog,procs \\<turnstile> (px,\n                           Label\n                            l) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (px,\n                                 Label l')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       valid_edge wfp a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "by(fastforce simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>a'.\n     valid_edge wfp a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' a''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"valid_edge wfp a' \\<and> targetnode a' = targetnode a \\<and> \n          intra_kind (kind a')\" and \"valid_edge wfp a'' \\<and>\n          targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\""], ["proof (state)\nthis:\n  valid_edge wfp a' \\<and>\n  targetnode a' = targetnode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "hence \"valid_edge wfp a'\" and \"targetnode a' = targetnode a\"\n          and \"intra_kind (kind a')\" and \"valid_edge wfp a''\"\n          and \"targetnode a'' = targetnode a\" and \"intra_kind (kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge wfp a' \\<and>\n  targetnode a' = targetnode a \\<and> intra_kind (kind a')\n  valid_edge wfp a'' \\<and>\n  targetnode a'' = targetnode a \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. (valid_edge wfp a' &&&\n     targetnode a' = targetnode a &&& intra_kind (kind a')) &&&\n    valid_edge wfp a'' &&&\n    targetnode a'' = targetnode a &&& intra_kind (kind a'')", "by simp_all"], ["proof (state)\nthis:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a'\\<close> \\<open>targetnode a' = targetnode a\\<close>\n          \\<open>intra_kind (kind a')\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>\n          \\<open>(p', ins', outs', c') \\<in> set procs\\<close> wf\n          \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>\n          \\<open>containsCall procs prog ps px\\<close> \\<open>(px, Label l') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n  (px, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps px\n  (px, Label l') = targetnode a", "have \"sourcenode a' = (px,Label l)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n  (px, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps px\n  (px, Label l') = targetnode a\n\ngoal (1 subgoal):\n 1. sourcenode a' = (px, Label l)", "apply(auto simp:valid_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na' -kind a'\\<rightarrow> targetnode a;\n     targetnode a' = targetnode a; intra_kind (kind a');\n     (px, ins, outs, c) \\<in> set procs;\n     (p', ins', outs', c') \\<in> set procs; well_formed procs;\n     c \\<turnstile> Label\n                     l -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n     containsCall procs prog ps px; (px, Label l') = targetnode a\\<rbrakk>\n    \\<Longrightarrow> sourcenode a' = (px, Label l)", "apply(erule PCFG.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (Main, n); kind a' = et; targetnode a = (Main, n');\n        prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)\n 2. \\<And>p insa outsa ca n et n' psa.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (p, n); kind a' = et; targetnode a = (p, n');\n        (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)\n 3. \\<And>la p es rets n' insa outsa ca.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (Main, Label la);\n        kind a' =\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es;\n        targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           la -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)\n 4. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (p, Label la);\n        kind a' =\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es'a;\n        targetnode a = (p'a, Entry); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)\n 5. \\<And>la p es rets l'a insa outsa ca.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (p, Exit);\n        kind a' =\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa);\n        targetnode a = (Main, Label l'a);\n        prog \\<turnstile> Label\n                           la -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)\n 6. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (p'a, Exit);\n        kind a' =\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets'a [:=] map cf outs'a);\n        targetnode a = (p, Label l'a); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (Main, n);\n        kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (Main, n');\n        prog \\<turnstile> n -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)\n 8. \\<And>p insa outsa ca n p'a es'a rets'a n' psa.\n       \\<lbrakk>targetnode a' = targetnode a; intra_kind (kind a');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a' = (p, n); kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (p, n'); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a' = (px, Label l)", "by(auto dest:Proc_CFG_Call_Intra_edge_not_same_target \n            Proc_CFG_Call_nodes_eq' simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a' = (px, Label l)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "from \\<open>valid_edge wfp a''\\<close> \\<open>targetnode a'' = targetnode a\\<close>\n          \\<open>intra_kind (kind a'')\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>\n          \\<open>(p', ins', outs', c') \\<in> set procs\\<close> wf\n          \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>\n          \\<open>containsCall procs prog ps px\\<close> \\<open>(px, Label l') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  intra_kind (kind a'')\n  (px, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps px\n  (px, Label l') = targetnode a", "have \"sourcenode a'' = (px,Label l)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  intra_kind (kind a'')\n  (px, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps px\n  (px, Label l') = targetnode a\n\ngoal (1 subgoal):\n 1. sourcenode a'' = (px, Label l)", "apply(auto simp:valid_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> sourcenode\na'' -kind a''\\<rightarrow> targetnode a;\n     targetnode a'' = targetnode a; intra_kind (kind a'');\n     (px, ins, outs, c) \\<in> set procs;\n     (p', ins', outs', c') \\<in> set procs; well_formed procs;\n     c \\<turnstile> Label\n                     l -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n     containsCall procs prog ps px; (px, Label l') = targetnode a\\<rbrakk>\n    \\<Longrightarrow> sourcenode a'' = (px, Label l)", "apply(erule PCFG.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (Main, n); kind a'' = et;\n        targetnode a = (Main, n');\n        prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)\n 2. \\<And>p insa outsa ca n et n' psa.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (p, n); kind a'' = et; targetnode a = (p, n');\n        (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)\n 3. \\<And>la p es rets n' insa outsa ca.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (Main, Label la);\n        kind a'' =\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es;\n        targetnode a = (p, Entry);\n        prog \\<turnstile> Label\n                           la -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)\n 4. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (p, Label la);\n        kind a'' =\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es'a;\n        targetnode a = (p'a, Entry); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)\n 5. \\<And>la p es rets l'a insa outsa ca.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (p, Exit);\n        kind a'' =\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa);\n        targetnode a = (Main, Label l'a);\n        prog \\<turnstile> Label\n                           la -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)\n 6. \\<And>p insa outsa ca la p'a es'a rets'a l'a ins'a outs'a c'a psa.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (p'a, Exit);\n        kind a'' =\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets'a [:=] map cf outs'a);\n        targetnode a = (p, Label l'a); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (Main, n);\n        kind a'' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (Main, n');\n        prog \\<turnstile> n -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)\n 8. \\<And>p insa outsa ca n p'a es'a rets'a n' psa.\n       \\<lbrakk>targetnode a'' = targetnode a; intra_kind (kind a'');\n        (px, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps px; (px, Label l') = targetnode a;\n        sourcenode a'' = (p, n);\n        kind a'' = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        targetnode a = (p, n'); (p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog psa p\\<rbrakk>\n       \\<Longrightarrow> sourcenode a'' = (px, Label l)", "by(auto dest:Proc_CFG_Call_Intra_edge_not_same_target \n            Proc_CFG_Call_nodes_eq' simp:intra_kind_def)"], ["proof (state)\nthis:\n  sourcenode a'' = (px, Label l)\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>valid_edge wfp a' \\<and>\n                targetnode a' = targetnode a \\<and> intra_kind (kind a');\n        valid_edge wfp y \\<and>\n        targetnode y = targetnode a \\<and> intra_kind (kind y)\\<rbrakk>\n       \\<Longrightarrow> a' = y", "with \\<open>valid_edge wfp a'\\<close> \\<open>targetnode a' = targetnode a\\<close>\n          \\<open>valid_edge wfp a''\\<close> \\<open>targetnode a'' = targetnode a\\<close>\n          \\<open>sourcenode a' = (px,Label l)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  sourcenode a' = (px, Label l)\n  well_formed procs\n  sourcenode a'' = (px, Label l)", "show \"a' = a''\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  targetnode a' = targetnode a\n  valid_edge wfp a''\n  targetnode a'' = targetnode a\n  sourcenode a' = (px, Label l)\n  well_formed procs\n  sourcenode a'' = (px, Label l)\n\ngoal (1 subgoal):\n 1. a' = a''", "by(cases a',cases a'')\n        (auto dest:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')\n 6. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            valid_edge wfp a' \\<and>\n                            targetnode a' = targetnode a \\<and>\n                            intra_kind (kind a')", "qed auto"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge wfp a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. distinct_fst (lift_procs wfp)\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. distinct_fst (lift_procs wfp)\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2 fs\\<^sub>2"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. distinct_fst (lift_procs wfp)\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"valid_edge wfp a\" and \"valid_edge wfp a'\"\n      and \"kind a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\" and \"kind a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  valid_edge wfp a'\n  kind a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  kind a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        kind a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        kind a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> targetnode a = targetnode a'\n 2. distinct_fst (lift_procs wfp)\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "thus \"targetnode a = targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  valid_edge wfp a'\n  kind a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  kind a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. targetnode a = targetnode a'", "by(auto elim!:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode a = targetnode a'\n\ngoal (3 subgoals):\n 1. distinct_fst (lift_procs wfp)\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct_fst (lift_procs wfp)\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from wf"], ["proof (chain)\npicking this:\n  well_formed procs", "show \"distinct_fst (lift_procs wfp)\""], ["proof (prove)\nusing this:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. distinct_fst (lift_procs wfp)", "by(fastforce simp:well_formed_def distinct_fst_def o_def)"], ["proof (state)\nthis:\n  distinct_fst (lift_procs wfp)\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix p ins outs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"(p, ins, outs) \\<in> set (lift_procs wfp)\""], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close> wf"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  well_formed procs", "show \"distinct ins\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. distinct ins", "by(fastforce simp:well_formed_def wf_proc_def)"], ["proof (state)\nthis:\n  distinct ins\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "fix p ins outs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "assume \"(p, ins, outs) \\<in> set (lift_procs wfp)\""], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set (lift_procs wfp) \\<Longrightarrow>\n       distinct outs", "from \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close> wf"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  well_formed procs", "show \"distinct outs\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. distinct outs", "by(fastforce simp:well_formed_def wf_proc_def)"], ["proof (state)\nthis:\n  distinct outs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n   (get_return_edges wfp) (lift_procs wfp) Main\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instatiation of the \\<open>CFGExit\\<close> locale\\<close>"], ["", "interpretation ProcCFGExit:\n  CFGExit sourcenode targetnode kind \"valid_edge wfp\" \"(Main,Entry)\"\n  get_proc \"get_return_edges wfp\" \"lift_procs wfp\" Main \"(Main,Exit)\"\n  for wfp"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "from Rep_wf_prog[of wfp]"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp \\<in> wf_prog", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp \\<in> wf_prog\n\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:wf_prog_def)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "hence wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "show \"CFGExit sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n    get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; sourcenode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. get_proc (Main, Exit) = Main\n 3. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; sourcenode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. get_proc (Main, Exit) = Main\n 3. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"valid_edge wfp a\" and \"sourcenode a = (Main, Exit)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  sourcenode a = (Main, Exit)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge wfp a; sourcenode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. get_proc (Main, Exit) = Main\n 3. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  valid_edge wfp a\n  sourcenode a = (Main, Exit)", "show False"], ["proof (prove)\nusing this:\n  well_formed procs\n  valid_edge wfp a\n  sourcenode a = (Main, Exit)\n\ngoal (1 subgoal):\n 1. False", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. get_proc (Main, Exit) = Main\n 2. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. get_proc (Main, Exit) = Main\n 2. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "show \"get_proc (Main, Exit) = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc (Main, Exit) = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (Main, Exit) = Main\n\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a Q p f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"valid_edge wfp a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n      and \"targetnode a = (Main, Exit)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (Main, Exit)\n\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = (Main, Exit)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = (Main, Exit)\n\ngoal (1 subgoal):\n 1. False", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "have \"prog,procs \\<turnstile> (Main,Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (Main,\n                             Entry) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (Main, Exit)", "by(fastforce intro:Main Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (Main,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus \"\\<exists>a. valid_edge wfp a \\<and>\n      sourcenode a = (Main, Entry) \\<and>\n      targetnode a = (Main, Exit) \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (Main,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge wfp a \\<and>\n       sourcenode a = (Main, Entry) \\<and>\n       targetnode a = (Main, Exit) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge wfp a \\<and>\n     sourcenode a = (Main, Entry) \\<and>\n     targetnode a = (Main, Exit) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n   (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}