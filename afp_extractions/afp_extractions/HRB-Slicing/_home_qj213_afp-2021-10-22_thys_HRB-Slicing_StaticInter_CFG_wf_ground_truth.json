{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/CFG_wf.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma CFG_equal_Use_equal_call:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"valid_edge a'\"\n  and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\" and \"sourcenode a = sourcenode a'\"\n  and \"pred (kind a) s\" and \"pred (kind a') s'\" \n  and \"snd (hd s) = snd (hd s')\" and \"length s = length s'\"\n  and \"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\"\n  shows \"a = a'\"", "lemma CFG_call_edge_param_in:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"i < length ins\"\n  and \"(p,ins,outs) \\<in> set procs\" and \"pred (kind a) s\" and \"pred (kind a) s'\"\n  and \"\\<forall>V \\<in> (ParamUses (sourcenode a))!i. state_val s V = state_val s' V\"\n  shows \"state_val (transfer (kind a) s) (ins!i) = \n         state_val (transfer (kind a) s') (ins!i)\"", "lemma CFG_call_edge_no_param:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"V \\<notin> set ins\"\n  and \"(p,ins,outs) \\<in> set procs\" and \"pred (kind a) s\"\n  shows \"state_val (transfer (kind a) s) V = None\"", "lemma CFG_return_edge_param_out:\n  assumes \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"i < length outs\"\n  and \"(p,ins,outs) \\<in> set procs\" and \"state_val s (outs!i) = state_val s' (outs!i)\"\n  and \"s = cf#cfx#cfs\" and \"s' = cf'#cfx'#cfs'\"\n  shows \"state_val (transfer (kind a) s) ((ParamDefs (targetnode a))!i) =\n         state_val (transfer (kind a) s') ((ParamDefs (targetnode a))!i)\"", "lemma CFG_slp_no_Def_equal:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" and \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  and \"V \\<notin> set (ParamDefs (targetnode a'))\" and \"preds (kinds (a#as@[a'])) s\"\n  shows \"state_val (transfers (kinds (a#as@[a'])) s) V = state_val s V\"", "lemma [dest!]: \"V \\<in> Use (_Entry_) \\<Longrightarrow> False\"", "lemma [dest!]: \"V \\<in> Def (_Entry_) \\<Longrightarrow> False\"", "lemma CFG_intra_path_no_Def_equal:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"\\<forall>n \\<in> set (sourcenodes as). V \\<notin> Def n\"\n  and \"preds (kinds as) s\"\n  shows \"state_val (transfers (kinds as) s) V = state_val s V\"", "lemma slpa_preds:\n  \"\\<lbrakk>same_level_path_aux cs as; s = cfsx@cf#cfs; s' = cfsx@cf#cfs'; \n    length cfs = length cfs'; \\<forall>a \\<in> set as. valid_edge a; length cs = length cfsx; \n    preds (kinds as) s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) s'\"", "lemma slp_preds:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" and \"preds (kinds as) (cf#cfs)\" \n  and \"length cfs = length cfs'\"\n  shows \"preds (kinds as) (cf#cfs')\""], "translations": [["", "lemma CFG_equal_Use_equal_call:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"valid_edge a'\"\n  and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\" and \"sourcenode a = sourcenode a'\"\n  and \"pred (kind a) s\" and \"pred (kind a') s'\" \n  and \"snd (hd s) = snd (hd s')\" and \"length s = length s'\"\n  and \"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\"\n  shows \"a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = a'", "from \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>snd (hd s) = snd (hd s')\\<close>\n    \\<open>\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\\<close> \\<open>length s = length s'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  pred (kind a) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  length s = length s'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  pred (kind a) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(rule CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. a = a'", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>\n    \\<open>sourcenode a = sourcenode a'\\<close> \\<open>pred (kind a') s'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  sourcenode a = sourcenode a'\n  pred (kind a') s'\n  pred (kind a) s'", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  sourcenode a = sourcenode a'\n  pred (kind a') s'\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. a = a'", "by -(rule CFG_call_determ)"], ["proof (state)\nthis:\n  a = a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CFG_call_edge_param_in:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"i < length ins\"\n  and \"(p,ins,outs) \\<in> set procs\" and \"pred (kind a) s\" and \"pred (kind a) s'\"\n  and \"\\<forall>V \\<in> (ParamUses (sourcenode a))!i. state_val s V = state_val s' V\"\n  shows \"state_val (transfer (kind a) s) (ins!i) = \n         state_val (transfer (kind a) s') (ins!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "from assms"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  pred (kind a) s\n  pred (kind a) s'\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     state_val s V = state_val s' V", "have params:\"(params fs (fst (hd s)))!i = (params fs (fst (hd s')))!i\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  pred (kind a) s\n  pred (kind a) s'\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. params fs (state_val s) ! i = params fs (state_val s') ! i", "by(rule CFG_call_edge_params)"], ["proof (state)\nthis:\n  params fs (state_val s) ! i = params fs (state_val s') ! i\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have [simp]:\"(THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs) = ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins", "by(rule formal_in_THE)"], ["proof (state)\nthis:\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "from \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  pred (kind a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "from \\<open>pred (kind a) s'\\<close>"], ["proof (chain)\npicking this:\n  pred (kind a) s'", "obtain cf' cfs' where [simp]:\"s' = cf'#cfs'\""], ["proof (prove)\nusing this:\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        s' = cf' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s') auto"], ["proof (state)\nthis:\n  s' = cf' # cfs'\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have eqs:\"fst (hd (transfer (kind a) s)) = (Map.empty(ins [:=] params fs (fst cf)))\"\n    \"fst (hd (transfer (kind a) s')) = (Map.empty(ins [:=] params fs (fst cf')))\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) = Map.empty(ins [:=]\n    params fs (fst cf)) &&&\n    state_val (transfer (kind a) s') = Map.empty(ins [:=]\n    params fs (fst cf'))", "by simp_all"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) = Map.empty(ins [:=] params fs (fst cf))\n  state_val (transfer (kind a) s') = Map.empty(ins [:=] params fs (fst cf'))\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have \"length fs = length ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length fs = length ins", "by(rule CFG_call_edge_length)"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "from \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set procs", "have \"distinct ins\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. distinct ins", "by(rule distinct_formal_ins)"], ["proof (state)\nthis:\n  distinct ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "with \\<open>i < length ins\\<close> \\<open>length fs = length ins\\<close>"], ["proof (chain)\npicking this:\n  i < length ins\n  length fs = length ins\n  distinct ins", "have \"(Map.empty(ins [:=] params fs (fst cf))) (ins!i) = (params fs (fst cf))!i\"\n    \"(Map.empty(ins [:=] params fs (fst cf'))) (ins!i) = (params fs (fst cf'))!i\""], ["proof (prove)\nusing this:\n  i < length ins\n  length fs = length ins\n  distinct ins\n\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf)) (ins ! i) =\n    params fs (fst cf) ! i &&&\n    Map.empty(ins [:=] params fs (fst cf')) (ins ! i) =\n    params fs (fst cf') ! i", "by(fastforce intro:fun_upds_nth)+"], ["proof (state)\nthis:\n  Map.empty(ins [:=] params fs (fst cf)) (ins ! i) = params fs (fst cf) ! i\n  Map.empty(ins [:=] params fs (fst cf')) (ins ! i) =\n  params fs (fst cf') ! i\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "with eqs \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> params"], ["proof (chain)\npicking this:\n  state_val (transfer (kind a) s) = Map.empty(ins [:=] params fs (fst cf))\n  state_val (transfer (kind a) s') = Map.empty(ins [:=] params fs (fst cf'))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  params fs (state_val s) ! i = params fs (state_val s') ! i\n  Map.empty(ins [:=] params fs (fst cf)) (ins ! i) = params fs (fst cf) ! i\n  Map.empty(ins [:=] params fs (fst cf')) (ins ! i) =\n  params fs (fst cf') ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  state_val (transfer (kind a) s) = Map.empty(ins [:=] params fs (fst cf))\n  state_val (transfer (kind a) s') = Map.empty(ins [:=] params fs (fst cf'))\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  params fs (state_val s) ! i = params fs (state_val s') ! i\n  Map.empty(ins [:=] params fs (fst cf)) (ins ! i) = params fs (fst cf) ! i\n  Map.empty(ins [:=] params fs (fst cf')) (ins ! i) =\n  params fs (fst cf') ! i\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ins ! i) =\n    state_val (transfer (kind a) s') (ins ! i)", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) (ins ! i) =\n  state_val (transfer (kind a) s') (ins ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CFG_call_edge_no_param:\n  assumes \"valid_edge a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"V \\<notin> set ins\"\n  and \"(p,ins,outs) \\<in> set procs\" and \"pred (kind a) s\"\n  shows \"state_val (transfer (kind a) s) V = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = None", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have [simp]:\"(THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs) = ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins", "by(rule formal_in_THE)"], ["proof (state)\nthis:\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = None", "from \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  pred (kind a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = None", "from \\<open>V \\<notin> set ins\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> set ins", "have \"(Map.empty(ins [:=] params fs (fst cf))) V = None\""], ["proof (prove)\nusing this:\n  V \\<notin> set ins\n\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf)) V = None", "by(auto dest:fun_upds_notin)"], ["proof (state)\nthis:\n  Map.empty(ins [:=] params fs (fst cf)) V = None\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = None", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  Map.empty(ins [:=] params fs (fst cf)) V = None", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  Map.empty(ins [:=] params fs (fst cf)) V = None\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = None", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) V = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CFG_return_edge_param_out:\n  assumes \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"i < length outs\"\n  and \"(p,ins,outs) \\<in> set procs\" and \"state_val s (outs!i) = state_val s' (outs!i)\"\n  and \"s = cf#cfx#cfs\" and \"s' = cf'#cfx'#cfs'\"\n  shows \"state_val (transfer (kind a) s) ((ParamDefs (targetnode a))!i) =\n         state_val (transfer (kind a) s') ((ParamDefs (targetnode a))!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs", "have [simp]:\"(THE outs. \\<exists>ins. (p,ins,outs) \\<in> set procs) = outs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE outs. \\<exists>ins. (p, ins, outs) \\<in> set procs) = outs", "by(rule formal_out_THE)"], ["proof (state)\nthis:\n  (THE outs. \\<exists>ins. (p, ins, outs) \\<in> set procs) = outs\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>s = cf#cfx#cfs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  s = cf # cfx # cfs", "have transfer:\"fst (hd (transfer (kind a) s)) = \n    (fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf) outs)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  s = cf # cfx # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) = fst cfx(ParamDefs (targetnode a) [:=]\n    map (fst cf) outs)", "by(fastforce intro:CFG_return_edge_fun)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) = fst cfx(ParamDefs (targetnode a) [:=]\n  map (fst cf) outs)\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  s' = cf' # cfx' # cfs'", "have transfer':\"fst (hd (transfer (kind a) s')) = \n    (fst cfx')(ParamDefs (targetnode a) [:=] map (fst cf') outs)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  s' = cf' # cfx' # cfs'\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s') = fst cfx'(ParamDefs (targetnode a) \n    [:=] map (fst cf') outs)", "by(fastforce intro:CFG_return_edge_fun)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s') = fst cfx'(ParamDefs (targetnode a) [:=]\n  map (fst cf') outs)\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "from \\<open>state_val s (outs!i) = state_val s' (outs!i)\\<close> \\<open>i < length outs\\<close>\n    \\<open>s = cf#cfx#cfs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  state_val s (outs ! i) = state_val s' (outs ! i)\n  i < length outs\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'", "have \"(fst cf) (outs!i) = (fst cf') (outs!i)\""], ["proof (prove)\nusing this:\n  state_val s (outs ! i) = state_val s' (outs ! i)\n  i < length outs\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n\ngoal (1 subgoal):\n 1. fst cf (outs ! i) = fst cf' (outs ! i)", "by simp"], ["proof (state)\nthis:\n  fst cf (outs ! i) = fst cf' (outs ! i)\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"distinct (ParamDefs (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs (targetnode a))", "by(fastforce intro:distinct_ParamDefs)"], ["proof (state)\nthis:\n  distinct (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs", "have \"length(ParamDefs (targetnode a)) = length outs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (ParamDefs (targetnode a)) = length outs", "by(fastforce intro:ParamDefs_return_target_length)"], ["proof (state)\nthis:\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "with \\<open>i < length outs\\<close> \\<open>distinct (ParamDefs (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  i < length outs\n  distinct (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs", "have \"(fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf) outs)\n    ((ParamDefs (targetnode a))!i) = (map (fst cf) outs)!i\" \n    and \"(fst cfx')(ParamDefs (targetnode a) [:=] map (fst cf') outs)\n             ((ParamDefs (targetnode a))!i) = (map (fst cf') outs)!i\""], ["proof (prove)\nusing this:\n  i < length outs\n  distinct (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf) outs)\n     (ParamDefs (targetnode a) ! i) =\n    map (fst cf) outs ! i &&&\n    fst cfx'(ParamDefs (targetnode a) [:=] map (fst cf') outs)\n     (ParamDefs (targetnode a) ! i) =\n    map (fst cf') outs ! i", "by(fastforce intro:fun_upds_nth)+"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf) outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf) outs ! i\n  fst cfx'(ParamDefs (targetnode a) [:=] map (fst cf') outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf') outs ! i\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "with transfer transfer' \\<open>(fst cf) (outs!i) = (fst cf') (outs!i)\\<close> \\<open>i < length outs\\<close>"], ["proof (chain)\npicking this:\n  state_val (transfer (kind a) s) = fst cfx(ParamDefs (targetnode a) [:=]\n  map (fst cf) outs)\n  state_val (transfer (kind a) s') = fst cfx'(ParamDefs (targetnode a) [:=]\n  map (fst cf') outs)\n  fst cf (outs ! i) = fst cf' (outs ! i)\n  i < length outs\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf) outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf) outs ! i\n  fst cfx'(ParamDefs (targetnode a) [:=] map (fst cf') outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf') outs ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  state_val (transfer (kind a) s) = fst cfx(ParamDefs (targetnode a) [:=]\n  map (fst cf) outs)\n  state_val (transfer (kind a) s') = fst cfx'(ParamDefs (targetnode a) [:=]\n  map (fst cf') outs)\n  fst cf (outs ! i) = fst cf' (outs ! i)\n  i < length outs\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf) outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf) outs ! i\n  fst cfx'(ParamDefs (targetnode a) [:=] map (fst cf') outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf') outs ! i\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n    state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) (ParamDefs (targetnode a) ! i) =\n  state_val (transfer (kind a) s') (ParamDefs (targetnode a) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CFG_slp_no_Def_equal:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" and \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  and \"V \\<notin> set (ParamDefs (targetnode a'))\" and \"preds (kinds (a#as@[a'])) s\"\n  shows \"state_val (transfers (kinds (a#as@[a'])) s) V = state_val s V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q r p fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "with \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "from \\<open>preds (kinds (a#as@[a'])) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as @ [a'])) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as @ [a'])) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s,auto simp:kinds_def)"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain ins outs \n    where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain cfx where \"transfer (kind a) s = cfx#cf#cfs\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        transfer (kind a) s = cfx # cf # cfs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  transfer (kind a) s = cfx # cf # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "moreover"], ["proof (state)\nthis:\n  transfer (kind a) s = cfx # cf # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "from \\<open>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "obtain cfx' \n    where \"transfers (kinds as) (cfx#cf#cfs) = cfx'#cf#cfs\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>cfx'.\n        transfers (kinds as) (cfx # cf # cfs) =\n        cfx' # cf # cfs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:slp_callstack_length_equal)"], ["proof (state)\nthis:\n  transfers (kinds as) (cfx # cf # cfs) = cfx' # cf # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "moreover"], ["proof (state)\nthis:\n  transfers (kinds as) (cfx # cf # cfs) = cfx' # cf # cfs\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "from \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>valid_edge a'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge a'\n  (p, ins, outs) \\<in> set procs", "have \"fst (hd (transfer (kind a') (cfx'#cf#cfs))) = \n    (fst cf)(ParamDefs (targetnode a') [:=] map (fst cfx') outs)\""], ["proof (prove)\nusing this:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge a'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a') (cfx' # cf # cfs)) =\n    fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)", "by(simp,simp only:formal_out_THE,fastforce intro:CFG_return_edge_fun)"], ["proof (state)\nthis:\n  state_val (transfer (kind a') (cfx' # cf # cfs)) =\n  fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "ultimately"], ["proof (chain)\npicking this:\n  transfer (kind a) s = cfx # cf # cfs\n  transfers (kinds as) (cfx # cf # cfs) = cfx' # cf # cfs\n  state_val (transfer (kind a') (cfx' # cf # cfs)) =\n  fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)", "have \"fst (hd (transfers (kinds (a#as@[a'])) s)) = \n    (fst cf)(ParamDefs (targetnode a') [:=] map (fst cfx') outs)\""], ["proof (prove)\nusing this:\n  transfer (kind a) s = cfx # cf # cfs\n  transfers (kinds as) (cfx # cf # cfs) = cfx' # cf # cfs\n  state_val (transfer (kind a') (cfx' # cf # cfs)) =\n  fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) =\n    fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)", "by(simp add:kinds_def transfers_split)"], ["proof (state)\nthis:\n  state_val (transfers (kinds (a # as @ [a'])) s) =\n  fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "with \\<open>V \\<notin> set (ParamDefs (targetnode a'))\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> set (ParamDefs (targetnode a'))\n  state_val (transfers (kinds (a # as @ [a'])) s) =\n  fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<notin> set (ParamDefs (targetnode a'))\n  state_val (transfers (kinds (a # as @ [a'])) s) =\n  fst cf(ParamDefs (targetnode a') [:=] map (fst cfx') outs)\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V", "by(simp add:fun_upds_notin)"], ["proof (state)\nthis:\n  state_val (transfers (kinds (a # as @ [a'])) s) V = state_val s V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [dest!]: \"V \\<in> Use (_Entry_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> Use (_Entry_) \\<Longrightarrow> False", "by(simp add:Entry_empty)"], ["", "lemma [dest!]: \"V \\<in> Def (_Entry_) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> Def (_Entry_) \\<Longrightarrow> False", "by(simp add:Entry_empty)"], ["", "lemma CFG_intra_path_no_Def_equal:\n  assumes \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"\\<forall>n \\<in> set (sourcenodes as). V \\<notin> Def n\"\n  and \"preds (kinds as) s\"\n  shows \"state_val (transfers (kinds as) s) V = state_val s V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfers (kinds as) s) V = state_val s V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_val (transfers (kinds as) s) V = state_val s V", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "have \"n -as\\<rightarrow>* n'\" and \"\\<forall>a \\<in> set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* n' &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds as) s) V = state_val s V", "from this \\<open>\\<forall>n \\<in> set (sourcenodes as). V \\<notin> Def n\\<close> \\<open>preds (kinds as) s\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n\n  preds (kinds as) s", "have \"state_val (transfers (kinds as) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n\n  preds (kinds as) s\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds as) s) V = state_val s V", "proof(induct arbitrary:s rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>valid_node n; \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes []). V \\<notin> Def n;\n        preds (kinds []) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds []) s) V =\n                         state_val s V\n 2. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "case (empty_path n)"], ["proof (state)\nthis:\n  valid_node n\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  \\<forall>n\\<in>set (sourcenodes []). V \\<notin> Def n\n  preds (kinds []) s\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>valid_node n; \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes []). V \\<notin> Def n;\n        preds (kinds []) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds []) s) V =\n                         state_val s V\n 2. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node n\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  \\<forall>n\\<in>set (sourcenodes []). V \\<notin> Def n\n  preds (kinds []) s\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds []) s) V = state_val s V", "by(simp add:sourcenodes_def kinds_def)"], ["proof (state)\nthis:\n  state_val (transfers (kinds []) s) V = state_val s V\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "case (Cons_path n'' as n' a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n   \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n   preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> state_val (transfers (kinds as) ?s) V = state_val ?s V\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n  \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "note IH = \\<open>\\<And>s. \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a); \n                    \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n; preds (kinds as) s\\<rbrakk> \n      \\<Longrightarrow> state_val (transfers (kinds as) s) V = state_val s V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n   \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n   preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> state_val (transfers (kinds as) ?s) V = state_val ?s V\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "from \\<open>preds (kinds (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\"\n      and \"preds (kinds as) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s &&& preds (kinds as) (transfer (kind a) s)", "by(simp_all add:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n  preds (kinds as) (transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "from \\<open>\\<forall>n\\<in>set (sourcenodes (a#as)). V \\<notin> Def n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n", "have noDef:\"V \\<notin> Def (sourcenode a)\" \n      and all:\"\\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) &&&\n    \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<notin> Def (sourcenode a)\n  \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "from \\<open>\\<forall>a\\<in>set (a#as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\" and all':\"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by auto"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "from \\<open>valid_edge a\\<close> noDef \\<open>intra_kind (kind a)\\<close> \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  pred (kind a) s", "have \"state_val (transfer (kind a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = state_val s V", "by -(rule CFG_intra_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) V = state_val s V\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>\\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n\\<in>set (sourcenodes as). V \\<notin> Def n;\n            preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> state_val (transfers (kinds as) s) V =\n                             state_val s V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n\\<in>set (sourcenodes (a # as)). V \\<notin> Def n;\n        preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfers (kinds (a # as)) s) V =\n                         state_val s V", "with IH[OF all' all \\<open>preds (kinds as) (transfer (kind a) s)\\<close>]"], ["proof (chain)\npicking this:\n  state_val (transfers (kinds as) (transfer (kind a) s)) V =\n  state_val (transfer (kind a) s) V\n  state_val (transfer (kind a) s) V = state_val s V", "show ?case"], ["proof (prove)\nusing this:\n  state_val (transfers (kinds as) (transfer (kind a) s)) V =\n  state_val (transfer (kind a) s) V\n  state_val (transfer (kind a) s) V = state_val s V\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds (a # as)) s) V = state_val s V", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  state_val (transfers (kinds (a # as)) s) V = state_val s V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfers (kinds as) s) V = state_val s V\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds as) s) V = state_val s V", "thus ?thesis"], ["proof (prove)\nusing this:\n  state_val (transfers (kinds as) s) V = state_val s V\n\ngoal (1 subgoal):\n 1. state_val (transfers (kinds as) s) V = state_val s V", "by blast"], ["proof (state)\nthis:\n  state_val (transfers (kinds as) s) V = state_val s V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slpa_preds:\n  \"\\<lbrakk>same_level_path_aux cs as; s = cfsx@cf#cfs; s' = cfsx@cf#cfs'; \n    length cfs = length cfs'; \\<forall>a \\<in> set as. valid_edge a; length cs = length cfsx; \n    preds (kinds as) s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as; s = cfsx @ cf # cfs;\n     s' = cfsx @ cf # cfs'; length cfs = length cfs';\n     \\<forall>a\\<in>set as. valid_edge a; length cs = length cfsx;\n     preds (kinds as) s\\<rbrakk>\n    \\<Longrightarrow> preds (kinds as) s'", "proof(induct arbitrary:s s' cf cfsx rule:slpa_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs s s' cf cfsx.\n       \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set []) valid_edge;\n        length cs = length cfsx; preds (kinds []) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds []) s'\n 2. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 4. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n  \\<forall>a\\<in>set []. valid_edge a\n  length cs = length cfsx\n  preds (kinds []) s\n\ngoal (4 subgoals):\n 1. \\<And>cs s s' cf cfsx.\n       \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set []) valid_edge;\n        length cs = length cfsx; preds (kinds []) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds []) s'\n 2. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 4. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "thus ?case"], ["proof (prove)\nusing this:\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n  \\<forall>a\\<in>set []. valid_edge a\n  length cs = length cfsx\n  preds (kinds []) s\n\ngoal (1 subgoal):\n 1. preds (kinds []) s'", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  preds (kinds []) s'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  \\<lbrakk>?s = ?cfsx @ ?cf # cfs; ?s' = ?cfsx @ ?cf # cfs';\n   length cfs = length cfs'; \\<forall>a\\<in>set as. valid_edge a;\n   length cs = length ?cfsx; preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) ?s'\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n  \\<forall>a\\<in>set (a # as). valid_edge a\n  length cs = length cfsx\n  preds (kinds (a # as)) s\n\ngoal (3 subgoals):\n 1. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "note IH = \\<open>\\<And>s s' cf cfsx. \\<lbrakk>s = cfsx@cf#cfs; s' = cfsx@cf#cfs';\n    length cfs = length cfs'; \\<forall>a \\<in> set as. valid_edge a; length cs = length cfsx; \n    preds (kinds as) s\\<rbrakk> \\<Longrightarrow> preds (kinds as) s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?s = ?cfsx @ ?cf # cfs; ?s' = ?cfsx @ ?cf # cfs';\n   length cfs = length cfs'; \\<forall>a\\<in>set as. valid_edge a;\n   length cs = length ?cfsx; preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) ?s'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>\\<forall>a\\<in>set (a#as). valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). valid_edge a", "have \"valid_edge a\"\n    and \"\\<forall>a \\<in> set as. valid_edge a\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). valid_edge a\n\ngoal (1 subgoal):\n 1. valid_edge a &&& \\<forall>a\\<in>set as. valid_edge a", "by simp_all"], ["proof (state)\nthis:\n  valid_edge a\n  \\<forall>a\\<in>set as. valid_edge a\n\ngoal (3 subgoals):\n 1. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>preds (kinds (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\"\n    and \"preds (kinds as) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s &&& preds (kinds as) (transfer (kind a) s)", "by(simp_all add:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n  preds (kinds as) (transfer (kind a) s)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as s s' cf cfsx.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 3. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. preds (kinds (a # as)) s'", "proof(cases cfsx)"], ["proof (state)\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "case Nil"], ["proof (state)\nthis:\n  cfsx = []\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "with \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  length cs = length cfsx\n  cfsx = []", "have \"length cs = length []\""], ["proof (prove)\nusing this:\n  length cs = length cfsx\n  cfsx = []\n\ngoal (1 subgoal):\n 1. length cs = length []", "by simp"], ["proof (state)\nthis:\n  length cs = length []\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from Nil \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  cfsx = []\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  intra_kind (kind a)", "obtain cfx where \"transfer (kind a) s = []@cfx#cfs\"\n      and \"transfer (kind a) s' = []@cfx#cfs'\""], ["proof (prove)\nusing this:\n  cfsx = []\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        \\<lbrakk>transfer (kind a) s = [] @ cfx # cfs;\n         transfer (kind a) s' = [] @ cfx # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"kind a\",auto simp:kinds_def intra_kind_def)"], ["proof (state)\nthis:\n  transfer (kind a) s = [] @ cfx # cfs\n  transfer (kind a) s' = [] @ cfx # cfs'\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from IH[OF this \\<open>length cfs = length cfs'\\<close> \\<open>\\<forall>a \\<in> set as. valid_edge a\\<close>\n      \\<open>length cs = length []\\<close> \\<open>preds (kinds as) (transfer (kind a) s)\\<close>]"], ["proof (chain)\npicking this:\n  preds (kinds as) (transfer (kind a) s')", "have \"preds (kinds as) (transfer (kind a) s')\""], ["proof (prove)\nusing this:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (1 subgoal):\n 1. preds (kinds as) (transfer (kind a) s')", "."], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "moreover"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from Nil \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>\n      \\<open>length cfs = length cfs'\\<close>"], ["proof (chain)\npicking this:\n  cfsx = []\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  cfsx = []\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(fastforce intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. cfsx = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "ultimately"], ["proof (chain)\npicking this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'", "show ?thesis"], ["proof (prove)\nusing this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. preds (kinds (a # as)) s'", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  preds (kinds (a # as)) s'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "case (Cons x xs)"], ["proof (state)\nthis:\n  cfsx = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "with \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  intra_kind (kind a)\n  cfsx = x # xs", "obtain cfx where \"transfer (kind a) s = (cfx#xs)@cf#cfs\"\n      and \"transfer (kind a) s' = (cfx#xs)@cf#cfs'\""], ["proof (prove)\nusing this:\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  intra_kind (kind a)\n  cfsx = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        \\<lbrakk>transfer (kind a) s = (cfx # xs) @ cf # cfs;\n         transfer (kind a) s' = (cfx # xs) @ cf # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"kind a\",auto simp:kinds_def intra_kind_def)"], ["proof (state)\nthis:\n  transfer (kind a) s = (cfx # xs) @ cf # cfs\n  transfer (kind a) s' = (cfx # xs) @ cf # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from IH[OF this \\<open>length cfs = length cfs'\\<close> \\<open>\\<forall>a \\<in> set as. valid_edge a\\<close> _ \n      \\<open>preds (kinds as) (transfer (kind a) s)\\<close>] \\<open>length cs = length cfsx\\<close> Cons"], ["proof (chain)\npicking this:\n  length cs = length (cfx # xs) \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  length cs = length cfsx\n  cfsx = x # xs", "have \"preds (kinds as) (transfer (kind a) s')\""], ["proof (prove)\nusing this:\n  length cs = length (cfx # xs) \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  length cs = length cfsx\n  cfsx = x # xs\n\ngoal (1 subgoal):\n 1. preds (kinds as) (transfer (kind a) s')", "by simp"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "moreover"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from Cons \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>\n      \\<open>length cfs = length cfs'\\<close>"], ["proof (chain)\npicking this:\n  cfsx = x # xs\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  cfsx = x # xs\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(fastforce intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cfsx = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "ultimately"], ["proof (chain)\npicking this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'", "show ?thesis"], ["proof (prove)\nusing this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. preds (kinds (a # as)) s'", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  preds (kinds (a # as)) s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  preds (kinds (a # as)) s'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  \\<lbrakk>?s = ?cfsx @ ?cf # cfs; ?s' = ?cfsx @ ?cf # cfs';\n   length cfs = length cfs'; \\<forall>a\\<in>set as. valid_edge a;\n   length (a # cs) = length ?cfsx; preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) ?s'\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n  \\<forall>a\\<in>set (a # as). valid_edge a\n  length cs = length cfsx\n  preds (kinds (a # as)) s\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "note IH = \\<open>\\<And>s s' cf cfsx. \\<lbrakk>s = cfsx@cf#cfs; s' = cfsx@cf#cfs';\n    length cfs = length cfs'; \\<forall>a \\<in> set as. valid_edge a; length (a#cs) = length cfsx;\n    preds (kinds as) s\\<rbrakk> \\<Longrightarrow> preds (kinds as) s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?s = ?cfsx @ ?cf # cfs; ?s' = ?cfsx @ ?cf # cfs';\n   length cfs = length cfs'; \\<forall>a\\<in>set as. valid_edge a;\n   length (a # cs) = length ?cfsx; preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) ?s'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>\\<forall>a\\<in>set (a#as). valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). valid_edge a", "have \"valid_edge a\"\n    and \"\\<forall>a \\<in> set as. valid_edge a\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). valid_edge a\n\ngoal (1 subgoal):\n 1. valid_edge a &&& \\<forall>a\\<in>set as. valid_edge a", "by simp_all"], ["proof (state)\nthis:\n  valid_edge a\n  \\<forall>a\\<in>set as. valid_edge a\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>preds (kinds (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\"\n    and \"preds (kinds as) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s &&& preds (kinds as) (transfer (kind a) s)", "by(simp_all add:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n  preds (kinds as) (transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'", "obtain cfx\n    where \"transfer (kind a) s = (cfx#cfsx)@cf#cfs\"\n    and \"transfer (kind a) s' = (cfx#cfsx)@cf#cfs'\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        \\<lbrakk>transfer (kind a) s = (cfx # cfsx) @ cf # cfs;\n         transfer (kind a) s' = (cfx # cfsx) @ cf # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cfsx) auto"], ["proof (state)\nthis:\n  transfer (kind a) s = (cfx # cfsx) @ cf # cfs\n  transfer (kind a) s' = (cfx # cfsx) @ cf # cfs'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from IH[OF this \\<open>length cfs = length cfs'\\<close> \\<open>\\<forall>a \\<in> set as. valid_edge a\\<close> _ \n    \\<open>preds (kinds as) (transfer (kind a) s)\\<close>] \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  length (a # cs) = length (cfx # cfsx) \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  length cs = length cfsx", "have \"preds (kinds as) (transfer (kind a) s')\""], ["proof (prove)\nusing this:\n  length (a # cs) = length (cfx # cfsx) \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  length cs = length cfsx\n\ngoal (1 subgoal):\n 1. preds (kinds as) (transfer (kind a) s')", "by simp"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "moreover"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>\n    \\<open>length cfs = length cfs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(cases cfsx)(auto intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs s s' cf cfsx.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length (a # cs) = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "ultimately"], ["proof (chain)\npicking this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'", "show ?case"], ["proof (prove)\nusing this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. preds (kinds (a # as)) s'", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  preds (kinds (a # as)) s'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "case (slpa_Return cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>?s = ?cfsx @ ?cf # cfs; ?s' = ?cfsx @ ?cf # cfs';\n   length cfs = length cfs'; \\<forall>a\\<in>set as. valid_edge a;\n   length cs' = length ?cfsx; preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) ?s'\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n  \\<forall>a\\<in>set (a # as). valid_edge a\n  length cs = length cfsx\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "note IH = \\<open>\\<And>s s' cf cfsx. \\<lbrakk>s = cfsx@cf#cfs; s' = cfsx@cf#cfs';\n    length cfs = length cfs'; \\<forall>a \\<in> set as. valid_edge a; length cs' = length cfsx; \n    preds (kinds as) s\\<rbrakk> \\<Longrightarrow> preds (kinds as) s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?s = ?cfsx @ ?cf # cfs; ?s' = ?cfsx @ ?cf # cfs';\n   length cfs = length cfs'; \\<forall>a\\<in>set as. valid_edge a;\n   length cs' = length ?cfsx; preds (kinds as) ?s\\<rbrakk>\n  \\<Longrightarrow> preds (kinds as) ?s'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>\\<forall>a\\<in>set (a#as). valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). valid_edge a", "have \"valid_edge a\"\n    and \"\\<forall>a \\<in> set as. valid_edge a\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). valid_edge a\n\ngoal (1 subgoal):\n 1. valid_edge a &&& \\<forall>a\\<in>set as. valid_edge a", "by simp_all"], ["proof (state)\nthis:\n  valid_edge a\n  \\<forall>a\\<in>set as. valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>preds (kinds (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\"\n    and \"preds (kinds as) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s &&& preds (kinds as) (transfer (kind a) s)", "by(simp_all add:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n  preds (kinds as) (transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' s s' cf cfsx.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>s s' cf cfsx.\n           \\<lbrakk>s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n            length cfs = length cfs'; Ball (set as) valid_edge;\n            length cs' = length cfsx; preds (kinds as) s\\<rbrakk>\n           \\<Longrightarrow> preds (kinds as) s';\n        s = cfsx @ cf # cfs; s' = cfsx @ cf # cfs';\n        length cfs = length cfs'; Ball (set (a # as)) valid_edge;\n        length cs = length cfsx; preds (kinds (a # as)) s\\<rbrakk>\n       \\<Longrightarrow> preds (kinds (a # as)) s'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. preds (kinds (a # as)) s'", "proof(cases cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "case Nil"], ["proof (state)\nthis:\n  cs' = []\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "with \\<open>cs = c'#cs'\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>\n      \\<open>length cs = length cfsx\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cs = length cfsx\n  cs' = []", "obtain cf' where \"s = cf'#cf#cfs\" and \"s' = cf'#cf#cfs'\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cs = length cfsx\n  cs' = []\n\ngoal (1 subgoal):\n 1. (\\<And>cf'.\n        \\<lbrakk>s = cf' # cf # cfs; s' = cf' # cf # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cfsx) auto"], ["proof (state)\nthis:\n  s = cf' # cf # cfs\n  s' = cf' # cf # cfs'\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  s = cf' # cf # cfs\n  s' = cf' # cf # cfs'", "obtain cf'' where \"transfer (kind a) s = []@cf''#cfs\"\n      and \"transfer (kind a) s' = []@cf''#cfs'\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  s = cf' # cf # cfs\n  s' = cf' # cf # cfs'\n\ngoal (1 subgoal):\n 1. (\\<And>cf''.\n        \\<lbrakk>transfer (kind a) s = [] @ cf'' # cfs;\n         transfer (kind a) s' = [] @ cf'' # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transfer (kind a) s = [] @ cf'' # cfs\n  transfer (kind a) s' = [] @ cf'' # cfs'\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from IH[OF this \\<open>length cfs = length cfs'\\<close> \\<open>\\<forall>a \\<in> set as. valid_edge a\\<close> _ \n      \\<open>preds (kinds as) (transfer (kind a) s)\\<close>] Nil"], ["proof (chain)\npicking this:\n  length cs' = length [] \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  cs' = []", "have \"preds (kinds as) (transfer (kind a) s')\""], ["proof (prove)\nusing this:\n  length cs' = length [] \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  cs' = []\n\ngoal (1 subgoal):\n 1. preds (kinds as) (transfer (kind a) s')", "by simp"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "moreover"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>\n      \\<open>length cfs = length cfs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(cases cfsx)(auto intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. cs' = [] \\<Longrightarrow> preds (kinds (a # as)) s'\n 2. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "ultimately"], ["proof (chain)\npicking this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'", "show ?thesis"], ["proof (prove)\nusing this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. preds (kinds (a # as)) s'", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  preds (kinds (a # as)) s'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "case (Cons cx csx)"], ["proof (state)\nthis:\n  cs' = cx # csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "with \\<open>cs = c'#cs'\\<close> \\<open>length cs = length cfsx\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>"], ["proof (chain)\npicking this:\n  cs = c' # cs'\n  length cs = length cfsx\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  cs' = cx # csx", "obtain x x' xs where \"s = (x#x'#xs)@cf#cfs\" and \"s' = (x#x'#xs)@cf#cfs'\"\n      and \"length xs = length csx\""], ["proof (prove)\nusing this:\n  cs = c' # cs'\n  length cs = length cfsx\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  cs' = cx # csx\n\ngoal (1 subgoal):\n 1. (\\<And>x x' xs.\n        \\<lbrakk>s = (x # x' # xs) @ cf # cfs;\n         s' = (x # x' # xs) @ cf # cfs'; length xs = length csx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cfsx,auto,case_tac list,fastforce+)"], ["proof (state)\nthis:\n  s = (x # x' # xs) @ cf # cfs\n  s' = (x # x' # xs) @ cf # cfs'\n  length xs = length csx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  s = (x # x' # xs) @ cf # cfs\n  s' = (x # x' # xs) @ cf # cfs'\n  length xs = length csx", "obtain cf' where \"transfer (kind a) s = (cf'#xs)@cf#cfs\"\n      and \"transfer (kind a) s' = (cf'#xs)@cf#cfs'\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  s = (x # x' # xs) @ cf # cfs\n  s' = (x # x' # xs) @ cf # cfs'\n  length xs = length csx\n\ngoal (1 subgoal):\n 1. (\\<And>cf'.\n        \\<lbrakk>transfer (kind a) s = (cf' # xs) @ cf # cfs;\n         transfer (kind a) s' = (cf' # xs) @ cf # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  transfer (kind a) s = (cf' # xs) @ cf # cfs\n  transfer (kind a) s' = (cf' # xs) @ cf # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from IH[OF this \\<open>length cfs = length cfs'\\<close> \\<open>\\<forall>a \\<in> set as. valid_edge a\\<close> _ \n      \\<open>preds (kinds as) (transfer (kind a) s)\\<close>] Cons \\<open>length xs = length csx\\<close>"], ["proof (chain)\npicking this:\n  length cs' = length (cf' # xs) \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  cs' = cx # csx\n  length xs = length csx", "have \"preds (kinds as) (transfer (kind a) s')\""], ["proof (prove)\nusing this:\n  length cs' = length (cf' # xs) \\<Longrightarrow>\n  preds (kinds as) (transfer (kind a) s')\n  cs' = cx # csx\n  length xs = length csx\n\ngoal (1 subgoal):\n 1. preds (kinds as) (transfer (kind a) s')", "by simp"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "moreover"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "from \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>s = cfsx@cf#cfs\\<close> \\<open>s' = cfsx@cf#cfs'\\<close>\n      \\<open>length cfs = length cfs'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  pred (kind a) s\n  s = cfsx @ cf # cfs\n  s' = cfsx @ cf # cfs'\n  length cfs = length cfs'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(cases cfsx)(auto intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       cs' = aa # list \\<Longrightarrow> preds (kinds (a # as)) s'", "ultimately"], ["proof (chain)\npicking this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'", "show ?thesis"], ["proof (prove)\nusing this:\n  preds (kinds as) (transfer (kind a) s')\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. preds (kinds (a # as)) s'", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  preds (kinds (a # as)) s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  preds (kinds (a # as)) s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slp_preds:\n  assumes \"n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\" and \"preds (kinds as) (cf#cfs)\" \n  and \"length cfs = length cfs'\"\n  shows \"preds (kinds as) (cf#cfs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preds (kinds as) (cf # cfs')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. preds (kinds as) (cf # cfs')", "from \\<open>n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'", "have \"n -as\\<rightarrow>* n'\" and \"same_level_path_aux [] as\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^bsub>sl\\<^esub>* n'\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* n' &&& same_level_path_aux [] as", "by(simp_all add:slp_def same_level_path_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  same_level_path_aux [] as\n\ngoal (1 subgoal):\n 1. preds (kinds as) (cf # cfs')", "from \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'", "have \"\\<forall>a \\<in> set as. valid_edge a\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. valid_edge a", "by(rule path_valid_edges)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. valid_edge a\n\ngoal (1 subgoal):\n 1. preds (kinds as) (cf # cfs')", "with \\<open>same_level_path_aux [] as\\<close> \\<open>preds (kinds as) (cf#cfs)\\<close> \n    \\<open>length cfs = length cfs'\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  preds (kinds as) (cf # cfs)\n  length cfs = length cfs'\n  \\<forall>a\\<in>set as. valid_edge a", "show ?thesis"], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  preds (kinds as) (cf # cfs)\n  length cfs = length cfs'\n  \\<forall>a\\<in>set as. valid_edge a\n\ngoal (1 subgoal):\n 1. preds (kinds as) (cf # cfs')", "by(fastforce elim!:slpa_preds)"], ["proof (state)\nthis:\n  preds (kinds as) (cf # cfs')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}