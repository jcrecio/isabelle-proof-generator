{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/Proc/ValidPaths.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma Proc_CFG_edge_SeqFirst_nodes_Label:\n  \"prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l' \\<Longrightarrow> prog;;c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'\"", "lemma Proc_CFG_edge_SeqFirst_source_Label:\n  assumes \"prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n'\"\n  obtains nx where \"prog;;c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p nx\"", "lemma Proc_CFG_edge_SeqFirst_target_Label:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; Label l' = n'\\<rbrakk> \\<Longrightarrow> prog;;c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\"", "lemma PCFG_edge_SeqFirst_source_Label:\n  assumes \"prog,procs \\<turnstile> (p,Label l) -et\\<rightarrow> (p',n')\"\n  obtains nx where \"prog;;c\\<^sub>2,procs \\<turnstile> (p,Label l) -et\\<rightarrow> (p',nx)\"", "lemma PCFG_edge_SeqFirst_target_Label:\n  \"prog,procs \\<turnstile> (p,n) -et\\<rightarrow> (p',Label l') \n  \\<Longrightarrow> prog;;c\\<^sub>2,procs \\<turnstile> (p,n) -et\\<rightarrow> (p',Label l')\"", "lemma path_SeqFirst:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"Rep_wf_prog wfp' = (prog;;c\\<^sub>2,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (p,n) -as\\<rightarrow>* (p,Label l); \\<forall>a \\<in> set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (p,n) -as\\<rightarrow>* (p,Label l)\"", "lemma Proc_CFG_edge_SeqSecond_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\"", "lemma PCFG_Main_edge_SeqSecond_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>1;;prog,procs \\<turnstile> (Main,n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',n' \\<oplus> #:c\\<^sub>1)\"", "lemma valid_node_Main_SeqSecond:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (c\\<^sub>1;;prog,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n \\<oplus> #:c\\<^sub>1)\"", "lemma path_Main_SeqSecond:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"Rep_wf_prog wfp' = (c\\<^sub>1;;prog,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> #:c\\<^sub>1) -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* (p',n' \\<oplus> #:c\\<^sub>1)\"", "lemma Proc_CFG_edge_CondTrue_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> if (b) prog else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\"", "lemma PCFG_Main_edge_CondTrue_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,n \\<oplus> 1) -et\\<rightarrow> (p',n' \\<oplus> 1)\"", "lemma valid_node_Main_CondTrue:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n \\<oplus> 1)\"", "lemma path_Main_CondTrue:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> 1) -as \\<oplus>s 1\\<rightarrow>* (p',n' \\<oplus> 1)\"", "lemma Proc_CFG_edge_CondFalse_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \n  \\<Longrightarrow> if (b) c\\<^sub>1 else prog \\<turnstile> n \\<oplus> (#:c\\<^sub>1 + 1) -et\\<rightarrow>\\<^sub>p n' \\<oplus> (#:c\\<^sub>1 + 1)\"", "lemma PCFG_Main_edge_CondFalse_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,n \\<oplus> (#:c\\<^sub>1 + 1)) -et\\<rightarrow> (p',n' \\<oplus> (#:c\\<^sub>1 + 1))\"", "lemma valid_node_Main_CondFalse:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') \n  (Main, n \\<oplus> (#:c\\<^sub>1 + 1))\"", "lemma path_Main_CondFalse:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> (#:c\\<^sub>1 + 1)) -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* (p',n' \\<oplus> (#:c\\<^sub>1 + 1))\"", "lemma Proc_CFG_edge_WhileBody_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk> \n  \\<Longrightarrow> while (b) prog \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\"", "lemma PCFG_Main_edge_WhileBody_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; n' \\<noteq> Exit; intra_kind et; \n  well_formed procs\\<rbrakk> \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,n \\<oplus> 2) -et\\<rightarrow> (p',n' \\<oplus> 2)\"", "lemma valid_node_Main_WhileBody:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (while (b) prog,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n \\<oplus> 2)\"", "lemma path_Main_WhileBody:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (while (b) prog,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); \n    n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> 2) -as \\<oplus>s 2\\<rightarrow>* (p',n' \\<oplus> 2)\"", "lemma Label_Proc_CFG_Entry_Exit_path_Main:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"l < #:prog\"\n  obtains as as' where \"wfp \\<turnstile> (Main,Label l) -as\\<rightarrow>* (Main,Exit)\"\n  and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n  and \"wfp \\<turnstile> (Main,Entry) -as'\\<rightarrow>* (Main,Label l)\"\n  and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\"", "lemma lift_edge_Main_Main:\n  \"\\<lbrakk>c,procs \\<turnstile> (Main, n) -et\\<rightarrow> (Main, n'); (p,ins,outs,c) \\<in> set procs;\n  containsCall procs prog ps p; well_formed procs\\<rbrakk> \n  \\<Longrightarrow> prog,procs \\<turnstile> (p, n) -et\\<rightarrow> (p, n')\"", "lemma lift_edge_Main_Proc:\n  \"\\<lbrakk>c,procs \\<turnstile> (Main, n) -et\\<rightarrow> (q, n'); q \\<noteq> Main; (p,ins,outs,c) \\<in> set procs;\n  containsCall procs prog ps p; well_formed procs\\<rbrakk> \n  \\<Longrightarrow> \\<exists>et'. prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (q, n')\"", "lemma lift_edge_Proc_Main:\n  \"\\<lbrakk>c,procs \\<turnstile> (q, n) -et\\<rightarrow> (Main, n'); q \\<noteq> Main; (p,ins,outs,c) \\<in> set procs;\n  containsCall procs prog ps p; well_formed procs\\<rbrakk> \n  \\<Longrightarrow> \\<exists>et'. prog,procs \\<turnstile> (q, n) -et'\\<rightarrow> (p, n')\"", "lemma lift_path_Proc: \n  assumes \"Rep_wf_prog wfp' = (c,procs)\" and \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"containsCall procs prog ps p\"\n  shows \"\\<lbrakk>wfp' \\<turnstile> (Main,n) -as\\<rightarrow>* (Main,n'); \\<forall>a \\<in> set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> wfp \\<turnstile> (p,n) -lift_path as p\\<rightarrow>* (p,n')\"", "lemma Label_Proc_CFG_Entry_Exit_path_Proc:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"l < #:c\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"containsCall procs prog ps p\"\n  obtains as as' where \"wfp \\<turnstile> (p,Label l) -as\\<rightarrow>* (p,Exit)\"\n  and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n  and \"wfp \\<turnstile> (p,Entry) -as'\\<rightarrow>* (p,Label l)\"\n  and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\"", "lemma Entry_to_Entry_and_Exit_to_Exit: \n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"containsCall procs prog ps p\" and \"(p,ins,outs,c) \\<in> set procs\"\n  obtains as as' where \"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (Main,Entry) as (p,Entry)\"\n  and \"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (p,Exit) as' (Main,Exit)\"", "lemma edge_valid_paths:\n  assumes \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\"\n  and disj:\"(p,n) = sourcenode a \\<or> (p,n) = targetnode a\" \n  and [simp]:\"Rep_wf_prog wfp = (prog,procs)\"\n  shows \"\\<exists>as as'. CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n                (get_return_edges wfp) (Main,Entry) as (p,n) \\<and>\n              CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n                (get_return_edges wfp) (p,n) as' (Main,Exit)\""], "translations": [["", "lemma Proc_CFG_edge_SeqFirst_nodes_Label:\n  \"prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l' \\<Longrightarrow> prog;;c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> Label\n                       l -et\\<rightarrow>\\<^sub>p Label l' \\<Longrightarrow>\n    prog;; c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'", "proof(induct prog \"Label l\" et \"Label l'\" rule:Proc_CFG.induct)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l;\n        n' \\<oplus> 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>b c'.\n        \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -IEdge\n                (\\<lambda>cf.\n                    state_check cf b\n                     (Some\n                       false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\nA total of 13 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2' n et n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>2';;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  n' \\<oplus> #:c\\<^sub>1 = Label l'\n\ngoal (13 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l;\n        n' \\<oplus> 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>b c'.\n        \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -IEdge\n                (\\<lambda>cf.\n                    state_check cf b\n                     (Some\n                       false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\nA total of 13 subgoals...", "hence \"(c\\<^sub>1;; c\\<^sub>2');; c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>2';;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  n' \\<oplus> #:c\\<^sub>1 = Label l'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;; c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_SeqSecond)"], ["proof (state)\nthis:\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (13 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l;\n        n' \\<oplus> 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>b c'.\n        \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -IEdge\n                (\\<lambda>cf.\n                    state_check cf b\n                     (Some\n                       false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\nA total of 13 subgoals...", "with \\<open>n \\<oplus> #:c\\<^sub>1 = Label l\\<close> \\<open>n' \\<oplus> #:c\\<^sub>1 = Label l'\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  n' \\<oplus> #:c\\<^sub>1 = Label l'\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  n' \\<oplus> #:c\\<^sub>1 = Label l'\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;; c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'", "by fastforce"], ["proof (state)\nthis:\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'\n\ngoal (12 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l;\n        n' \\<oplus> 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n         \\<Longrightarrow> c';;\n                           c\\<^sub>2 \\<turnstile> Label\n             l -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         n' \\<oplus> 2 = Label l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l;\n        n' \\<oplus> 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n         \\<Longrightarrow> c';;\n                           c\\<^sub>2 \\<turnstile> Label\n             l -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         n' \\<oplus> 2 = Label l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 12 subgoals...", "case (Proc_CFG_CondThen c\\<^sub>1 n et n' b c\\<^sub>2')"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>1;;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n \\<oplus> 1 = Label l\n  n' \\<oplus> 1 = Label l'\n\ngoal (12 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l;\n        n' \\<oplus> 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n         \\<Longrightarrow> c';;\n                           c\\<^sub>2 \\<turnstile> Label\n             l -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         n' \\<oplus> 2 = Label l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 12 subgoals...", "hence \"if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>1;;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n \\<oplus> 1 = Label l\n  n' \\<oplus> 1 = Label l'\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1 else c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_CondThen)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (12 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l;\n        n' \\<oplus> 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n         \\<Longrightarrow> c';;\n                           c\\<^sub>2 \\<turnstile> Label\n             l -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         n' \\<oplus> 2 = Label l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 12 subgoals...", "with \\<open>n \\<oplus> 1 = Label l\\<close> \\<open>n' \\<oplus> 1 = Label l'\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 1 = Label l\n  n' \\<oplus> 1 = Label l'\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> 1 = Label l\n  n' \\<oplus> 1 = Label l'\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1 else c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'", "by fastforce"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'\n\ngoal (11 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 11 subgoals...", "case (Proc_CFG_CondElse c\\<^sub>1 n et n' b c\\<^sub>2')"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>1;;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>2' + 1 = Label l\n  n' \\<oplus> #:c\\<^sub>2' + 1 = Label l'\n\ngoal (11 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 11 subgoals...", "hence \"if (b) c\\<^sub>2' else c\\<^sub>1 ;; c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' + 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> (#:c\\<^sub>2' + 1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>1;;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>2' + 1 = Label l\n  n' \\<oplus> #:c\\<^sub>2' + 1 = Label l'\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>2' else c\\<^sub>1;;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' + 1", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_CondElse)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n                                    1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' +\n                                     1\n\ngoal (11 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = Label l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n        \\<Longrightarrow> while (b) c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l'\nA total of 11 subgoals...", "with \\<open>n \\<oplus> #:c\\<^sub>2' + 1 = Label l\\<close> \\<open>n' \\<oplus> #:c\\<^sub>2' + 1 = Label l'\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>2' + 1 = Label l\n  n' \\<oplus> #:c\\<^sub>2' + 1 = Label l'\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n                                    1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' +\n                                     1", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>2' + 1 = Label l\n  n' \\<oplus> #:c\\<^sub>2' + 1 = Label l'\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n                                    1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' +\n                                     1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>2' else c\\<^sub>1;;\n    c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'", "by fastforce"], ["proof (state)\nthis:\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'\n\ngoal (10 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>p es rets.\n        \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n        \\<Longrightarrow> Call p es rets;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>p es rets.\n        \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n        \\<Longrightarrow> Call p es rets;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "case (Proc_CFG_WhileBody c' n et n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c';;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = Label l\n  n' \\<oplus> 2 = Label l'\n\ngoal (10 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>p es rets.\n        \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n        \\<Longrightarrow> Call p es rets;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "hence \"while (b) c';; c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n  \\<Longrightarrow> c';;\n                    c\\<^sub>2 \\<turnstile> Label\n      l -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = Label l\n  n' \\<oplus> 2 = Label l'\n\ngoal (1 subgoal):\n 1. while (b) c';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_WhileBody)"], ["proof (state)\nthis:\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (10 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>n = Label l; n' = Label l'\\<rbrakk>\n        \\<Longrightarrow> c';;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        n' \\<oplus> 2 = Label l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>p es rets.\n        \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n        \\<Longrightarrow> Call p es rets;;\n                          c\\<^sub>2 \\<turnstile> Label\n            l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "with \\<open>n \\<oplus> 2 = Label l\\<close> \\<open>n' \\<oplus> 2 = Label l'\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l\n  n' \\<oplus> 2 = Label l'\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n  n' \\<oplus> 2 = Label l'\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) c';;\n    c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'", "by fastforce"], ["proof (state)\nthis:\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'\n\ngoal (9 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>p es rets.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> Call p es rets;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>p es rets.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> Call p es rets;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "case (Proc_CFG_WhileBodyExit c' n et b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry\n  n \\<oplus> 2 = Label l\n  0 = l'\n\ngoal (9 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>p es rets.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> Call p es rets;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "hence \"while (b) c';; c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p Label 0\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry\n  n \\<oplus> 2 = Label l\n  0 = l'\n\ngoal (1 subgoal):\n 1. while (b) c';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p Label 0", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_WhileBodyExit)"], ["proof (state)\nthis:\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p Label 0\n\ngoal (9 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; 0 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>p es rets.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> Call p es rets;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "with \\<open>n \\<oplus> 2 = Label l\\<close> \\<open>0 = l'\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l\n  0 = l'\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p Label 0", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n  0 = l'\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p Label 0\n\ngoal (1 subgoal):\n 1. while (b) c';;\n    c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'", "by fastforce"], ["proof (state)\nthis:\n  while (b) c';;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l'\n\ngoal (8 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> V:=e;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               \\<Up>\\<lambda>cf. update cf V e\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Label l';\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Label l';\n        Label l' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>c\\<^sub>1 et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        Label l \\<noteq> Entry; #:c\\<^sub>1 = l'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -et\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       \\<lbrakk>0 = l; #:c\\<^sub>1 + 1 = l'\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>b c'.\n       \\<lbrakk>0 = l; 2 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 7. \\<And>b c'.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> while (b) c';;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -IEdge\n               (\\<lambda>cf.\n                   state_check cf b\n                    (Some\n                      false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 8. \\<And>p es rets.\n       \\<lbrakk>0 = l; 1 = l'\\<rbrakk>\n       \\<Longrightarrow> Call p es rets;;\n                         c\\<^sub>2 \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "qed (auto intro:Proc_CFG.intros)"], ["", "lemma Proc_CFG_edge_SeqFirst_source_Label:\n  assumes \"prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n'\"\n  obtains nx where \"prog;;c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        prog;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l) et)", "from \\<open>prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n'", "obtain n where \"prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\" and \"Label l = n\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n\n\ngoal (1 subgoal):\n 1. Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l) et)", "thus \"\\<exists>nx. prog;;c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n\n\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p nx", "proof(induct prog n et n' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>2';; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n        Label l = Label 0 \\<Longrightarrow>\n        Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2)\n             (Label l)\n             (IEdge\n               (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\nA total of 19 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2' n et n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> #:c\\<^sub>1\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>2';; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n        Label l = Label 0 \\<Longrightarrow>\n        Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2)\n             (Label l)\n             (IEdge\n               (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\nA total of 19 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "proof(cases \"n' = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "case True"], ["proof (state)\nthis:\n  n' = Exit\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' = Exit", "have \"c\\<^sub>1;; c\\<^sub>2' \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' = Exit\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    c\\<^sub>2' \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG.Proc_CFG_SeqSecond)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  c\\<^sub>2' \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "moreover"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  c\\<^sub>2' \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "from \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry", "have \"n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry", "by(cases n) auto"], ["proof (state)\nthis:\n  n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "ultimately"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2' \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\n  n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry", "have \"c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label (#:c\\<^sub>1;; c\\<^sub>2')\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2' \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\n  n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;; c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n#:c\\<^sub>1;; c\\<^sub>2'", "by(fastforce intro:Proc_CFG_SeqConnect)"], ["proof (state)\nthis:\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n                                    #:c\\<^sub>1;; c\\<^sub>2'\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>Label l = n \\<oplus> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Label l = n \\<oplus> #:c\\<^sub>1\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n                                    #:c\\<^sub>1;; c\\<^sub>2'", "show ?thesis"], ["proof (prove)\nusing this:\n  Label l = n \\<oplus> #:c\\<^sub>1\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n                                    #:c\\<^sub>1;; c\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "case False"], ["proof (state)\nthis:\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with Proc_CFG_SeqSecond"], ["proof (chain)\npicking this:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> #:c\\<^sub>1\n  n' \\<noteq> Exit", "have \"(c\\<^sub>1;; c\\<^sub>2');; c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> #:c\\<^sub>1\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;; c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_SeqSecond)"], ["proof (state)\nthis:\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>Label l = n \\<oplus> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Label l = n \\<oplus> #:c\\<^sub>1\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  Label l = n \\<oplus> #:c\\<^sub>1\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. c\\<^sub>1;; c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l = n \\<Longrightarrow>\n         Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n         n \\<noteq> Entry; Label l = n \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> Ex (Proc_CFG\n                               (if (b) c\\<^sub>1 else c\\<^sub>2';;\n                                c\\<^sub>2)\n                               (Label l) et)\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l = n \\<Longrightarrow>\n         Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n         n \\<noteq> Entry; Label l = n \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> Ex (Proc_CFG\n                               (if (b) c\\<^sub>1 else c\\<^sub>2';;\n                                c\\<^sub>2)\n                               (Label l) et)\nA total of 18 subgoals...", "case (Proc_CFG_CondThen c\\<^sub>1 n et n' b c\\<^sub>2')"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> 1\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l = n \\<Longrightarrow>\n         Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n         n \\<noteq> Entry; Label l = n \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> Ex (Proc_CFG\n                               (if (b) c\\<^sub>1 else c\\<^sub>2';;\n                                c\\<^sub>2)\n                               (Label l) et)\nA total of 18 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "proof(cases \"n' = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "case True"], ["proof (state)\nthis:\n  n' = Exit\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' = Exit", "have \"if (b) c\\<^sub>1 else c\\<^sub>2' \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' = Exit\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2' \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1", "by(fastforce intro:Proc_CFG.Proc_CFG_CondThen)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2' \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "moreover"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2' \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "from \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry", "have \"n \\<oplus> 1 \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. n \\<oplus> 1 \\<noteq> Entry", "by(cases n) auto"], ["proof (state)\nthis:\n  n \\<oplus> 1 \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "ultimately"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2' \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\n  n \\<oplus> 1 \\<noteq> Entry", "have \"if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label (#:if (b) c\\<^sub>1 else c\\<^sub>2')\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2' \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\n  n \\<oplus> 1 \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1 else c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n                            #:if (b) c\\<^sub>1 else c\\<^sub>2'", "by(fastforce intro:Proc_CFG_SeqConnect)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n                          #:if (b) c\\<^sub>1 else c\\<^sub>2'\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>Label l = n \\<oplus> 1\\<close>"], ["proof (chain)\npicking this:\n  Label l = n \\<oplus> 1\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n                          #:if (b) c\\<^sub>1 else c\\<^sub>2'", "show ?thesis"], ["proof (prove)\nusing this:\n  Label l = n \\<oplus> 1\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n                          #:if (b) c\\<^sub>1 else c\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "case False"], ["proof (state)\nthis:\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "hence \"n' \\<oplus> 1 \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. n' \\<oplus> 1 \\<noteq> Exit", "by(cases n') auto"], ["proof (state)\nthis:\n  n' \\<oplus> 1 \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with Proc_CFG_CondThen"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> 1\n  n' \\<oplus> 1 \\<noteq> Exit", "have  \"if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> 1\n  n' \\<oplus> 1 \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1 else c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_CondThen)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>Label l = n \\<oplus> 1\\<close>"], ["proof (chain)\npicking this:\n  Label l = n \\<oplus> 1\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  Label l = n \\<oplus> 1\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. if (b) c\\<^sub>1 else c\\<^sub>2';;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal (17 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\n 10. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n        \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l = n \\<Longrightarrow>\n         Ex (Proc_CFG (c\\<^sub>2';; c\\<^sub>2) (Label l) et);\n         n \\<noteq> Entry; Label l = n \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> Ex (Proc_CFG\n                               (if (b) c\\<^sub>1 else c\\<^sub>2';;\n                                c\\<^sub>2)\n                               (Label l) et)\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\n 10. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n        \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l = n \\<Longrightarrow>\n         Ex (Proc_CFG (c\\<^sub>2';; c\\<^sub>2) (Label l) et);\n         n \\<noteq> Entry; Label l = n \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> Ex (Proc_CFG\n                               (if (b) c\\<^sub>1 else c\\<^sub>2';;\n                                c\\<^sub>2)\n                               (Label l) et)\nA total of 17 subgoals...", "case (Proc_CFG_CondElse c\\<^sub>1 n et n' b c\\<^sub>2')"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> #:c\\<^sub>2' + 1\n\ngoal (17 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\n 10. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n        \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l = n \\<Longrightarrow>\n         Ex (Proc_CFG (c\\<^sub>2';; c\\<^sub>2) (Label l) et);\n         n \\<noteq> Entry; Label l = n \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> Ex (Proc_CFG\n                               (if (b) c\\<^sub>1 else c\\<^sub>2';;\n                                c\\<^sub>2)\n                               (Label l) et)\nA total of 17 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "proof(cases \"n' = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "case True"], ["proof (state)\nthis:\n  n' = Exit\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' = Exit", "have \"if (b) c\\<^sub>2' else c\\<^sub>1 \\<turnstile> n \\<oplus> (#:c\\<^sub>2' + 1) -et\\<rightarrow>\\<^sub>p Exit \\<oplus> (#:c\\<^sub>2' + 1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' = Exit\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>2'\n    else c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n     1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>2' + 1", "by(fastforce intro:Proc_CFG.Proc_CFG_CondElse)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>2'\n  else c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n   1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>2' + 1\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "moreover"], ["proof (state)\nthis:\n  if (b) c\\<^sub>2'\n  else c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n   1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>2' + 1\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "from \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry", "have \"n \\<oplus> (#:c\\<^sub>2' + 1) \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. n \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Entry", "by(cases n) auto"], ["proof (state)\nthis:\n  n \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "ultimately"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>2'\n  else c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n   1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>2' + 1\n  n \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Entry", "have \"if (b) c\\<^sub>2' else c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n \\<oplus> (#:c\\<^sub>2' + 1) -et\\<rightarrow>\\<^sub>p \n        Label (#:if (b) c\\<^sub>2' else c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>2'\n  else c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n   1 -et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>2' + 1\n  n \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>2' else c\\<^sub>1;;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n1 -et\\<rightarrow>\\<^sub>p Label #:if (b) c\\<^sub>2' else c\\<^sub>1", "by(fastforce intro:Proc_CFG_SeqConnect)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n                                    1 -et\\<rightarrow>\\<^sub>p Label\n                          #:if (b) c\\<^sub>2' else c\\<^sub>1\n\ngoal (2 subgoals):\n 1. n' = Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n 2. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>Label l = n \\<oplus> (#:c\\<^sub>2' + 1)\\<close>"], ["proof (chain)\npicking this:\n  Label l = n \\<oplus> #:c\\<^sub>2' + 1\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n                                    1 -et\\<rightarrow>\\<^sub>p Label\n                          #:if (b) c\\<^sub>2' else c\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  Label l = n \\<oplus> #:c\\<^sub>2' + 1\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>2' +\n                                    1 -et\\<rightarrow>\\<^sub>p Label\n                          #:if (b) c\\<^sub>2' else c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "case False"], ["proof (state)\nthis:\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "hence \"n' \\<oplus> (#:c\\<^sub>2' + 1) \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. n' \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Exit", "by(cases n') auto"], ["proof (state)\nthis:\n  n' \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with Proc_CFG_CondElse"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> #:c\\<^sub>2' + 1\n  n' \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Exit", "have  \"if (b) c\\<^sub>2' else c\\<^sub>1 ;; c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<oplus> (#:c\\<^sub>2' + 1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l = n \\<Longrightarrow>\n  \\<exists>a. c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n  n \\<noteq> Entry\n  Label l = n \\<oplus> #:c\\<^sub>2' + 1\n  n' \\<oplus> #:c\\<^sub>2' + 1 \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>2' else c\\<^sub>1;;\n    c\\<^sub>2 \\<turnstile> Label\n                            l -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' +\n                             1", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_CondElse)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' +\n                           1\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "with \\<open>Label l = n \\<oplus> (#:c\\<^sub>2' + 1)\\<close>"], ["proof (chain)\npicking this:\n  Label l = n \\<oplus> #:c\\<^sub>2' + 1\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' +\n                           1", "show ?thesis"], ["proof (prove)\nusing this:\n  Label l = n \\<oplus> #:c\\<^sub>2' + 1\n  if (b) c\\<^sub>2' else c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>2' +\n                           1\n\ngoal (1 subgoal):\n 1. \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. if (b) c\\<^sub>2' else c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p a\n\ngoal (16 subgoals):\n 1. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. False)\\<^sub>\\<surd>))\n 2. \\<And>prog.\n       Label l = Entry \\<Longrightarrow>\n       Ex (Proc_CFG (prog;; c\\<^sub>2) (Label l)\n            (IEdge (\\<lambda>s. True)\\<^sub>\\<surd>))\n 3. Label l = Label 0 \\<Longrightarrow>\n    Ex (Proc_CFG (Skip;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 4. \\<And>V e.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l)\n            (IEdge \\<Up>\\<lambda>cf. update cf V e))\n 5. \\<And>V e.\n       Label l = Label 1 \\<Longrightarrow>\n       Ex (Proc_CFG (V:=e;; c\\<^sub>2) (Label l) (IEdge \\<Up>id))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n' \\<noteq> Exit; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l = n \\<Longrightarrow>\n        Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2) (Label l) et);\n        n \\<noteq> Entry; Label l = n\\<rbrakk>\n       \\<Longrightarrow> Ex (Proc_CFG (c\\<^sub>1;; c\\<^sub>2';; c\\<^sub>2)\n                              (Label l) et)\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l = Label 0 \\<Longrightarrow>\n       Ex (Proc_CFG (if (b) c\\<^sub>1 else c\\<^sub>2';; c\\<^sub>2) (Label l)\n            (IEdge\n              (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>))\n 10. \\<And>b c'.\n        Label l = Label 0 \\<Longrightarrow>\n        Ex (Proc_CFG (while (b) c';; c\\<^sub>2) (Label l)\n             (IEdge\n               (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>))\nA total of 16 subgoals...", "qed (auto intro:Proc_CFG.intros)"], ["proof (state)\nthis:\n  \\<exists>nx. prog;;\n     c\\<^sub>2 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p nx\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_edge_SeqFirst_target_Label:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; Label l' = n'\\<rbrakk> \\<Longrightarrow> prog;;c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     Label l' = n'\\<rbrakk>\n    \\<Longrightarrow> prog;;\n                      c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\n                                   l'", "proof(induct prog n et n' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>2';;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n                     l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n        Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n        if (b) c\\<^sub>1 else c\\<^sub>2';;\n        c\\<^sub>2 \\<turnstile> Label\n                                0 -IEdge\n                                    (\\<lambda>cf.\n  state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\nA total of 19 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2' n et n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l' = n' \\<Longrightarrow>\n  c\\<^sub>2';; c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  Label l' = n' \\<oplus> #:c\\<^sub>1\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>2';;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n                     l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n        Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n        if (b) c\\<^sub>1 else c\\<^sub>2';;\n        c\\<^sub>2 \\<turnstile> Label\n                                0 -IEdge\n                                    (\\<lambda>cf.\n  state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\nA total of 19 subgoals...", "from \\<open>Label l' = n' \\<oplus> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Label l' = n' \\<oplus> #:c\\<^sub>1", "have \"n' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  Label l' = n' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit", "by(cases n') auto"], ["proof (state)\nthis:\n  n' \\<noteq> Exit\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>2';;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n                     l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n        Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n        if (b) c\\<^sub>1 else c\\<^sub>2';;\n        c\\<^sub>2 \\<turnstile> Label\n                                0 -IEdge\n                                    (\\<lambda>cf.\n  state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\nA total of 19 subgoals...", "with Proc_CFG_SeqSecond"], ["proof (chain)\npicking this:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l' = n' \\<Longrightarrow>\n  c\\<^sub>2';; c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  Label l' = n' \\<oplus> #:c\\<^sub>1\n  n' \\<noteq> Exit", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l' = n' \\<Longrightarrow>\n  c\\<^sub>2';; c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  Label l' = n' \\<oplus> #:c\\<^sub>1\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;; c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\nl'", "by(fastforce intro:Proc_CFG_SeqFirst intro:Proc_CFG.Proc_CFG_SeqSecond)"], ["proof (state)\nthis:\n  c\\<^sub>1;; c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Label\n                                    l'\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l' = n' \\<Longrightarrow>\n         c\\<^sub>1;;\n         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; Label l' = n' \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n            l'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l' = n' \\<Longrightarrow>\n         c\\<^sub>1;;\n         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; Label l' = n' \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n            l'\nA total of 18 subgoals...", "case (Proc_CFG_CondThen c\\<^sub>1 n et n' b c\\<^sub>2')"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l' = n' \\<Longrightarrow>\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  Label l' = n' \\<oplus> 1\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l' = n' \\<Longrightarrow>\n         c\\<^sub>1;;\n         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; Label l' = n' \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n            l'\nA total of 18 subgoals...", "from \\<open>Label l' = n' \\<oplus> 1\\<close>"], ["proof (chain)\npicking this:\n  Label l' = n' \\<oplus> 1", "have \"n' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  Label l' = n' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit", "by(cases n') auto"], ["proof (state)\nthis:\n  n' \\<noteq> Exit\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l' = n' \\<Longrightarrow>\n         c\\<^sub>1;;\n         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; Label l' = n' \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label\n            l'\nA total of 18 subgoals...", "with Proc_CFG_CondThen"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l' = n' \\<Longrightarrow>\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  Label l' = n' \\<oplus> 1\n  n' \\<noteq> Exit", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  Label l' = n' \\<Longrightarrow>\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l'\n  n \\<noteq> Entry\n  Label l' = n' \\<oplus> 1\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1 else c\\<^sub>2';;\n    c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label l'", "by(fastforce intro:Proc_CFG_SeqFirst Proc_CFG.Proc_CFG_CondThen)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1 else c\\<^sub>2';;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p Label l'\n\ngoal (17 subgoals):\n 1. \\<And>prog.\n       Label l' = Exit \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>prog.\n       Label l' = Label 0 \\<Longrightarrow>\n       prog;;\n       c\\<^sub>2 \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 3. Label l' = Exit \\<Longrightarrow>\n    Skip;;\n    c\\<^sub>2 \\<turnstile> Label\n                            0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>V e.\n       Label l' = Label 1 \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   \\<Up>\\<lambda>cf.\n     update cf V e\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>V e.\n       Label l' = Exit \\<Longrightarrow>\n       V:=e;;\n       c\\<^sub>2 \\<turnstile> Label\n                               1 -IEdge\n                                   \\<Up>id\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        Label l' = n' \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n' \\<noteq> Exit; Label l' = n'\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        Label l' = Exit \\<Longrightarrow>\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n        n \\<noteq> Entry; Label l' = Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;; c\\<^sub>2';;\n                         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label\nl'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label 1 \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2'.\n       Label l' = Label (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       if (b) c\\<^sub>1 else c\\<^sub>2';;\n       c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label l'\n 10. \\<And>c\\<^sub>2' n et n' b c\\<^sub>1.\n        \\<lbrakk>c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         Label l' = n' \\<Longrightarrow>\n         c\\<^sub>2';;\n         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l';\n         n \\<noteq> Entry; Label l' = n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2';;\n                          c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                      1 -et\\<rightarrow>\\<^sub>p Label l'\nA total of 17 subgoals...", "qed (auto intro:Proc_CFG.intros)"], ["", "lemma PCFG_edge_SeqFirst_source_Label:\n  assumes \"prog,procs \\<turnstile> (p,Label l) -et\\<rightarrow> (p',n')\"\n  obtains nx where \"prog;;c\\<^sub>2,procs \\<turnstile> (p,Label l) -et\\<rightarrow> (p',nx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        prog;;\n        c\\<^sub>2,procs \\<turnstile> (p,\nLabel l) -et\\<rightarrow> (p', nx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', nx)", "from \\<open>prog,procs \\<turnstile> (p,Label l) -et\\<rightarrow> (p',n')\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', n')", "show \"\\<exists>nx. prog;;c\\<^sub>2,procs \\<turnstile> (p,Label l) -et\\<rightarrow> (p',nx)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', n')\n\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', nx)", "proof(induct \"(p,Label l)\" et \"(p',n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 3. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "case (Main et)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n  Main = p\n  Main = p'\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 3. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "from \\<open>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'", "obtain nx' where \"prog;;c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p nx'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx'.\n        prog;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -IEdge\n                                    et\\<rightarrow>\\<^sub>p nx' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:Proc_CFG_edge_SeqFirst_source_Label)"], ["proof (state)\nthis:\n  prog;; c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p nx'\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 3. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "with \\<open>Main = p\\<close> \\<open>Main = p'\\<close>"], ["proof (chain)\npicking this:\n  Main = p\n  Main = p'\n  prog;; c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p nx'", "show ?case"], ["proof (prove)\nusing this:\n  Main = p\n  Main = p'\n  prog;; c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', nx)", "by(fastforce dest:PCFG.Main)"], ["proof (state)\nthis:\n  \\<exists>nx. prog;;\n     c\\<^sub>2,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', nx)\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 2. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 2. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "case (Proc ins outs c et ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  p = p'\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 2. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "from \\<open>containsCall procs prog ps p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p", "have \"containsCall procs (prog;;c\\<^sub>2) ps p\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. containsCall procs (prog;; c\\<^sub>2) ps p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label l) -et\\<rightarrow> (p', nx)\n 2. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "with Proc"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p", "show ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', nx)", "by(fastforce dest:PCFG.Proc)"], ["proof (state)\nthis:\n  \\<exists>nx. prog;;\n     c\\<^sub>2,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', nx)\n\ngoal (4 subgoals):\n 1. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "case (MainCall es rets nx ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\n  (p', ins, outs, c) \\<in> set procs\n  Main = p\n  Entry = n'\n\ngoal (4 subgoals):\n 1. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx", "obtain lx where [simp]:\"nx = Label lx\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. (\\<And>lx. nx = Label lx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  nx = Label lx\n\ngoal (4 subgoals):\n 1. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "with \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\n  nx = Label lx", "have \"prog;;c\\<^sub>2 \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label lx\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\n  nx = Label lx\n\ngoal (1 subgoal):\n 1. prog;;\n    c\\<^sub>2 \\<turnstile> Label\n                            l -CEdge\n                                (p', es, rets)\\<rightarrow>\\<^sub>p Label lx", "by(auto intro:Proc_CFG_edge_SeqFirst_nodes_Label)"], ["proof (state)\nthis:\n  prog;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge\n                              (p', es, rets)\\<rightarrow>\\<^sub>p Label lx\n\ngoal (4 subgoals):\n 1. \\<And>es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Main = p; Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(Main,\n                                  n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                    interpret es\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "with MainCall"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\n  (p', ins, outs, c) \\<in> set procs\n  Main = p\n  Entry = n'\n  prog;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge\n                              (p', es, rets)\\<rightarrow>\\<^sub>p Label lx", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p nx\n  (p', ins, outs, c) \\<in> set procs\n  Main = p\n  Entry = n'\n  prog;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge\n                              (p', es, rets)\\<rightarrow>\\<^sub>p Label lx\n\ngoal (1 subgoal):\n 1. \\<exists>nxa. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label\n   l) -\\<lambda>s.\n          True:(Main,\n                nx)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                 es\\<rightarrow> (p', nxa)", "by(fastforce dest:PCFG.MainCall)"], ["proof (state)\nthis:\n  \\<exists>nxa. prog;;\n     c\\<^sub>2,procs \\<turnstile> (p, Label\n l) -\\<lambda>s.\n        True:(Main,\n              nx)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n               es\\<rightarrow> (p', nxa)\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "case (ProcCall ins outs c es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  Entry = n'\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "from \\<open>containsCall procs prog ps p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p", "have \"containsCall procs (prog;;c\\<^sub>2) ps p\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. containsCall procs (prog;; c\\<^sub>2) ps p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        Entry = n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -\\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n es'\\<rightarrow> (p', nx)\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "with ProcCall"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  Entry = n'\n  containsCall procs (prog;; c\\<^sub>2) ps p", "show ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  Entry = n'\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label\n   l) -\\<lambda>s.\n          True:(p, Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es'\\<rightarrow> (p', nx)", "by(fastforce intro:PCFG.ProcCall)"], ["proof (state)\nthis:\n  \\<exists>nx. prog;;\n     c\\<^sub>2,procs \\<turnstile> (p, Label\n l) -\\<lambda>s.\n        True:(p, Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                   es'\\<rightarrow> (p', nx)\n\ngoal (2 subgoals):\n 1. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "case (MainCallReturn px es rets)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p\n  Main = p'\n\ngoal (2 subgoals):\n 1. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "from \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>Main = p\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p", "obtain nx'' where \"prog;;c\\<^sub>2 \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx''\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p\n\ngoal (1 subgoal):\n 1. (\\<And>nx''.\n        prog;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (px, es,\n                                     rets)\\<rightarrow>\\<^sub>p nx'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:Proc_CFG_edge_SeqFirst_source_Label)"], ["proof (state)\nthis:\n  prog;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx''\n\ngoal (2 subgoals):\n 1. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n 2. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "with MainCallReturn"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p\n  Main = p'\n  prog;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx''", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p\n  Main = p'\n  prog;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx''\n\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label\n   l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "by(fastforce dest:PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  \\<exists>nx. prog;;\n     c\\<^sub>2,procs \\<turnstile> (p, Label\n l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "case (ProcCallReturn ins outs c px' es' rets' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (px', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  p = p'\n\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "from \\<open>containsCall procs prog ps p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p", "have \"containsCall procs (prog;;c\\<^sub>2) ps p\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. containsCall procs (prog;; c\\<^sub>2) ps p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nx. prog;;\n                            c\\<^sub>2,procs \\<turnstile> (p,\n                    Label\n                     l) -(\\<lambda>s.\n                             False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "with ProcCallReturn"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (px', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p", "show ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (px', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (1 subgoal):\n 1. \\<exists>nx. prog;;\n       c\\<^sub>2,procs \\<turnstile> (p, Label\n   l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)", "by(fastforce dest!:PCFG.ProcCallReturn)"], ["proof (state)\nthis:\n  \\<exists>nx. prog;;\n     c\\<^sub>2,procs \\<turnstile> (p, Label\n l) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p', nx)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nx. prog;;\n     c\\<^sub>2,procs \\<turnstile> (p, Label l) -et\\<rightarrow> (p', nx)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PCFG_edge_SeqFirst_target_Label:\n  \"prog,procs \\<turnstile> (p,n) -et\\<rightarrow> (p',Label l') \n  \\<Longrightarrow> prog;;c\\<^sub>2,procs \\<turnstile> (p,n) -et\\<rightarrow> (p',Label l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, n) -et\\<rightarrow> (p',\n               Label l') \\<Longrightarrow>\n    prog;;\n    c\\<^sub>2,procs \\<turnstile> (p, n) -et\\<rightarrow> (p', Label l')", "proof(induct \"(p,n)\" et \"(p',Label l')\" rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 3. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 4. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "case Main"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p Label l'\n  Main = p\n  Main = p'\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 3. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 4. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p Label l'\n  Main = p\n  Main = p'\n\ngoal (1 subgoal):\n 1. prog;;\n    c\\<^sub>2,procs \\<turnstile> (p, n) -et_\\<rightarrow> (p', Label l')", "by(fastforce dest:Proc_CFG_edge_SeqFirst_target_Label intro:PCFG.Main)"], ["proof (state)\nthis:\n  prog;;\n  c\\<^sub>2,procs \\<turnstile> (p, n) -et_\\<rightarrow> (p', Label l')\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 2. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 2. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "case (Proc ins outs c et ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  p = p'\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 2. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "from \\<open>containsCall procs prog ps p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p", "have \"containsCall procs (prog;;c\\<^sub>2) ps p\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. containsCall procs (prog;; c\\<^sub>2) ps p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -et\\<rightarrow> (p', Label l')\n 2. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 5. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "with Proc"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p", "show ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (1 subgoal):\n 1. prog;;\n    c\\<^sub>2,procs \\<turnstile> (p, n) -et\\<rightarrow> (p', Label l')", "by(fastforce dest:PCFG.Proc)"], ["proof (state)\nthis:\n  prog;; c\\<^sub>2,procs \\<turnstile> (p, n) -et\\<rightarrow> (p', Label l')\n\ngoal (4 subgoals):\n 1. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "case MainReturn"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l_ -CEdge (p, es_, rets_)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins_, outs_, c_) \\<in> set procs\n  Exit = n\n  Main = p'\n\ngoal (4 subgoals):\n 1. \\<And>l es rets ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; Exit = n; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (Main,\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets [:=]\n                           map cf outs)\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 3. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 4. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l_ -CEdge (p, es_, rets_)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins_, outs_, c_) \\<in> set procs\n  Exit = n\n  Main = p'\n\ngoal (1 subgoal):\n 1. prog;;\n    c\\<^sub>2,procs \\<turnstile> (p, n) -\\<lambda>cf.\n      snd cf =\n      (Main,\n       Label\n        l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets_ [:=]\n         map cf outs_)\\<rightarrow> (p', Label l')", "by(fastforce dest:Proc_CFG_edge_SeqFirst_target_Label \n               intro!:PCFG.MainReturn[simplified])"], ["proof (state)\nthis:\n  prog;;\n  c\\<^sub>2,procs \\<turnstile> (p, n) -\\<lambda>cf.\n    snd cf =\n    (Main,\n     Label\n      l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets_ [:=]\n       map cf outs_)\\<rightarrow> (p', Label l')\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "case (ProcReturn ins outs c lx es' rets' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  lx -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'\n  Exit = n\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "from \\<open>containsCall procs prog ps p'\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p'", "have \"containsCall procs (prog;;c\\<^sub>2) ps p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p'\n\ngoal (1 subgoal):\n 1. containsCall procs (prog;; c\\<^sub>2) ps p'", "by simp"], ["proof (state)\nthis:\n  containsCall procs (prog;; c\\<^sub>2) ps p'\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c l es' rets' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p, ins', outs', c') \\<in> set procs; containsCall procs prog ps p';\n        Exit = n\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -\\<lambda>cf.\n                        snd cf =\n                        (p',\n                         Label\n                          l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                           cf'. cf'(rets' [:=]\n                           map cf outs')\\<rightarrow> (p', Label l')\n 2. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 3. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "with ProcReturn"], ["proof (chain)\npicking this:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  lx -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'\n  Exit = n\n  containsCall procs (prog;; c\\<^sub>2) ps p'", "show ?case"], ["proof (prove)\nusing this:\n  (p', ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  lx -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p'\n  Exit = n\n  containsCall procs (prog;; c\\<^sub>2) ps p'\n\ngoal (1 subgoal):\n 1. prog;;\n    c\\<^sub>2,procs \\<turnstile> (p, n) -\\<lambda>cf.\n      snd cf =\n      (p',\n       Label\n        l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n         map cf outs')\\<rightarrow> (p', Label l')", "by(fastforce intro:PCFG.ProcReturn)"], ["proof (state)\nthis:\n  prog;;\n  c\\<^sub>2,procs \\<turnstile> (p, n) -\\<lambda>cf.\n    snd cf =\n    (p',\n     Label\n      l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n       map cf outs')\\<rightarrow> (p', Label l')\n\ngoal (2 subgoals):\n 1. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "case MainCallReturn"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p Label l'\n  Main = p\n  Main = p'\n\ngoal (2 subgoals):\n 1. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p; Main = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n 2. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p Label l'\n  Main = p\n  Main = p'\n\ngoal (1 subgoal):\n 1. prog;;\n    c\\<^sub>2,procs \\<turnstile> (p, n) -(\\<lambda>s.\n       False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "by(fastforce dest:Proc_CFG_edge_SeqFirst_target_Label intro:PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  prog;;\n  c\\<^sub>2,procs \\<turnstile> (p, n) -(\\<lambda>s.\n     False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "case (ProcCallReturn ins outs c px' es' rets' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (px', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  p = p'\n\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "from \\<open>containsCall procs prog ps p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p", "have \"containsCall procs (prog;;c\\<^sub>2) ps p\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. containsCall procs (prog;; c\\<^sub>2) ps p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (1 subgoal):\n 1. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; p = p'\\<rbrakk>\n       \\<Longrightarrow> prog;;\n                         c\\<^sub>2,procs \\<turnstile> (p,\n                 n) -(\\<lambda>s.\n                         False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "with ProcCallReturn"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (px', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p", "show ?case"], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (px', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  p = p'\n  containsCall procs (prog;; c\\<^sub>2) ps p\n\ngoal (1 subgoal):\n 1. prog;;\n    c\\<^sub>2,procs \\<turnstile> (p, n) -(\\<lambda>s.\n       False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')", "by(fastforce dest!:PCFG.ProcCallReturn)"], ["proof (state)\nthis:\n  prog;;\n  c\\<^sub>2,procs \\<turnstile> (p, n) -(\\<lambda>s.\n     False)\\<^sub>\\<surd>\\<rightarrow> (p', Label l')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_SeqFirst:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"Rep_wf_prog wfp' = (prog;;c\\<^sub>2,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (p,n) -as\\<rightarrow>* (p,Label l); \\<forall>a \\<in> set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (p,n) -as\\<rightarrow>* (p,Label l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p, n) as (p, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l)", "proof(induct \"(p,n)\" as \"(p,Label l)\" arbitrary:n rule:ProcCFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (p, Label l);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (p, Label l) [] (p, Label l)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "case empty_path"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp (p, Label l)\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (p, Label l);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (p, Label l) [] (p, Label l)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (p, Label l)\\<close> \n    \\<open>Rep_wf_prog wfp = (prog, procs)\\<close> \\<open>Rep_wf_prog wfp' = (prog;; c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (p, Label l)\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (prog;; c\\<^sub>2, procs)", "have \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (p, Label l)\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (p, Label l)\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (prog;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (p, Label l)", "apply(auto simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ab ba.\n       \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n        Rep_wf_prog wfp' = (prog;; c\\<^sub>2, procs);\n        prog,procs \\<turnstile> (p, Label\n                                     l) -aa\\<rightarrow> (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog;;\n                            c\\<^sub>2,procs \\<turnstile> (a,\n                    b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> Label l = b \\<or>\n                             p = ab \\<and> Label l = ba)\n 2. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n        Rep_wf_prog wfp' = (prog;; c\\<^sub>2, procs);\n        prog,procs \\<turnstile> (a, b) -aa\\<rightarrow> (p,\n                   Label l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog;;\n                            c\\<^sub>2,procs \\<turnstile> (a,\n                    b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> Label l = b \\<or>\n                             p = ab \\<and> Label l = ba)", "apply(erule PCFG_edge_SeqFirst_source_Label,fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n        Rep_wf_prog wfp' = (prog;; c\\<^sub>2, procs);\n        prog,procs \\<turnstile> (a, b) -aa\\<rightarrow> (p,\n                   Label l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog;;\n                            c\\<^sub>2,procs \\<turnstile> (a,\n                    b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> Label l = b \\<or>\n                             p = ab \\<and> Label l = ba)", "by(drule PCFG_edge_SeqFirst_target_Label,fastforce)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (p, Label l)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (p, Label l);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (p, Label l) [] (p, Label l)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "thus ?case"], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp' (p, Label l)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (p, Label l) [] (p, Label l)", "by(fastforce intro:ProcCFG.empty_path)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (p, Label l) [] (p, Label l)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "case (Cons_path n'' as a nx)"], ["proof (state)\nthis:\n  ProcCFG.path wfp n'' as (p, Label l)\n  \\<lbrakk>n'' = (p, ?n);\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (p, ?n) as (p, Label l)\n  valid_edge wfp a\n  sourcenode a = (p, nx)\n  targetnode a = n''\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "note IH = \\<open>\\<And>n. \\<lbrakk>n'' = (p, n); \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> wfp' \\<turnstile> (p, n) -as\\<rightarrow>* (p, Label l)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' = (p, ?n);\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (p, ?n) as (p, Label l)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>Rep_wf_prog wfp' = (prog;;c\\<^sub>2,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (prog;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\"\n    and \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (p, nx)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (p, nx)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs", "obtain nx' where \"n'' = (p,nx')\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (p, nx)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>nx'. n'' = (p, nx') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  n'' = (p, nx')\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "from IH[OF this \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close>]"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (p, nx') as (p, Label l)", "have path:\"wfp' \\<turnstile> (p, nx') -as\\<rightarrow>* (p, Label l)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (p, nx') as (p, Label l)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (p, nx') as (p, Label l)", "."], ["proof (state)\nthis:\n  ProcCFG.path wfp' (p, nx') as (p, Label l)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "have \"valid_edge wfp' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge wfp' a", "proof(cases nx')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1. nx' = Label x1 \\<Longrightarrow> valid_edge wfp' a\n 2. nx' = Entry \\<Longrightarrow> valid_edge wfp' a\n 3. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "case (Label lx)"], ["proof (state)\nthis:\n  nx' = Label lx\n\ngoal (3 subgoals):\n 1. \\<And>x1. nx' = Label x1 \\<Longrightarrow> valid_edge wfp' a\n 2. nx' = Entry \\<Longrightarrow> valid_edge wfp' a\n 3. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "with \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (p, nx)\\<close> \\<open>targetnode a = n''\\<close>\n      \\<open>n'' = (p,nx')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (p, nx)\n  targetnode a = n''\n  n'' = (p, nx')\n  nx' = Label lx", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (p, nx)\n  targetnode a = n''\n  n'' = (p, nx')\n  nx' = Label lx\n\ngoal (1 subgoal):\n 1. valid_edge wfp' a", "by(fastforce intro:PCFG_edge_SeqFirst_target_Label \n                   simp:intra_kind_def valid_edge_def)"], ["proof (state)\nthis:\n  valid_edge wfp' a\n\ngoal (2 subgoals):\n 1. nx' = Entry \\<Longrightarrow> valid_edge wfp' a\n 2. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. nx' = Entry \\<Longrightarrow> valid_edge wfp' a\n 2. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "case Entry"], ["proof (state)\nthis:\n  nx' = Entry\n\ngoal (2 subgoals):\n 1. nx' = Entry \\<Longrightarrow> valid_edge wfp' a\n 2. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "with \\<open>valid_edge wfp a\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' = (p,nx')\\<close>\n      \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  targetnode a = n''\n  n'' = (p, nx')\n  intra_kind (kind a)\n  nx' = Entry", "have False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  targetnode a = n''\n  n'' = (p, nx')\n  intra_kind (kind a)\n  nx' = Entry\n\ngoal (1 subgoal):\n 1. False", "by(auto elim:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. nx' = Entry \\<Longrightarrow> valid_edge wfp' a\n 2. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. valid_edge wfp' a", "by simp"], ["proof (state)\nthis:\n  valid_edge wfp' a\n\ngoal (1 subgoal):\n 1. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "case Exit"], ["proof (state)\nthis:\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "with path \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (p, nx') as (p, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  nx' = Exit", "have False"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (p, nx') as (p, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. False", "by(induct \"(p,nx')\" as \"(p,Label l)\" rule:ProcCFG.path.induct)\n    (auto elim!:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. nx' = Exit \\<Longrightarrow> valid_edge wfp' a", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. valid_edge wfp' a", "by simp"], ["proof (state)\nthis:\n  valid_edge wfp' a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_edge wfp' a\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p, Label l);\n        \\<And>n.\n           \\<lbrakk>n'' = (p, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (p, n) as (p, Label l);\n        valid_edge wfp a; sourcenode a = (p, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (p, n) (a # as) (p, Label l)", "with \\<open>sourcenode a = (p, nx)\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' = (p,nx')\\<close> path"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = n''\n  n'' = (p, nx')\n  ProcCFG.path wfp' (p, nx') as (p, Label l)\n  valid_edge wfp' a", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = n''\n  n'' = (p, nx')\n  ProcCFG.path wfp' (p, nx') as (p, Label l)\n  valid_edge wfp' a\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (p, nx) (a # as) (p, Label l)", "by(fastforce intro:ProcCFG.Cons_path)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (p, nx) (a # as) (p, Label l)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>From \\<open>prog\\<close> to \\<open>c\\<^sub>1;;prog\\<close>\\<close>"], ["", "lemma Proc_CFG_edge_SeqSecond_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1;;\n                      prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(induct rule:Proc_CFG.induct)(fastforce intro:Proc_CFG_SeqSecond Proc_CFG.intros)+"], ["", "lemma PCFG_Main_edge_SeqSecond_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> c\\<^sub>1;;prog,procs \\<turnstile> (Main,n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',n' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> (Main, n) -et\\<rightarrow> (p', n');\n     n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1;;\n                      prog,procs \\<turnstile> (Main,\n         n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n             n' \\<oplus> #:c\\<^sub>1)", "proof(induct \"(Main,n)\" et \"(p',n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)", "case Main"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind et_\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind et_\n  well_formed procs\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             n \\<oplus> #:c\\<^sub>1) -et_\\<rightarrow> (p',\n                                  n' \\<oplus> #:c\\<^sub>1)", "by(fastforce dest:Proc_CFG_edge_SeqSecond_source_not_Entry intro:PCFG.Main)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -et_\\<rightarrow> (p',\n                                n' \\<oplus> #:c\\<^sub>1)\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)", "case (MainCallReturn p es rets)"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)", "from \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "have \"c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(rule Proc_CFG_edge_SeqSecond_source_not_Entry)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)", "with MainCallReturn"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                 n' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (p',\n               n' \\<oplus> #:c\\<^sub>1)\n\ngoal (6 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -et\\<rightarrow> (p',\n                n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1;;\n                         prog,procs \\<turnstile> (Main,\n            n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1)", "qed (auto simp:intra_kind_def)"], ["", "lemma valid_node_Main_SeqSecond:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (c\\<^sub>1;;prog,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>Rep_wf_prog wfp' = (c\\<^sub>1;;prog,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (c\\<^sub>1;; prog, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n)", "obtain a where \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\"\n    and \"(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>prog,procs \\<turnstile> sourcenode\n    a -kind a\\<rightarrow> targetnode a;\n         (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "from this \\<open>n \\<noteq> Entry\\<close> wf"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs", "show ?thesis"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (Main nx nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'", "have \"c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n         (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_edge_SeqSecond_source_not_Entry)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "hence \"c\\<^sub>1;;prog,procs \\<turnstile> (Main,n \\<oplus> #:c\\<^sub>1) -kind a\\<rightarrow> (Main,nx' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             n \\<oplus> #:c\\<^sub>1) -kind\n                 a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -kind\n               a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -kind\n               a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "proof(cases \"nx = Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "case True"], ["proof (state)\nthis:\n  nx = Entry\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry", "have \"nx' = Exit \\<or> nx' = Label 0\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry\n\ngoal (1 subgoal):\n 1. nx' = Exit \\<or> nx' = Label 0", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "assume \"nx' = Exit\""], ["proof (state)\nthis:\n  nx' = Exit\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "assume \"nx' = Label 0\""], ["proof (state)\nthis:\n  nx' = Label 0\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "obtain l etx where \"c\\<^sub>1 \\<turnstile> Label l -IEdge etx\\<rightarrow>\\<^sub>p Exit\" and \"l \\<le> #:c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l etx.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n   l -IEdge etx\\<rightarrow>\\<^sub>p Exit;\n         l \\<le> #:c\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule Proc_CFG_Exit_edge)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -IEdge etx\\<rightarrow>\\<^sub>p Exit\n  l \\<le> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "hence \"c\\<^sub>1;;prog \\<turnstile> Label l -IEdge etx\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -IEdge etx\\<rightarrow>\\<^sub>p Exit\n  l \\<le> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> Label\n                       l -IEdge etx\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_SeqConnect)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l -IEdge etx\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>nx' = Label 0\\<close>"], ["proof (chain)\npicking this:\n  nx' = Label 0\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l -IEdge etx\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1", "have \"c\\<^sub>1;;prog,procs \\<turnstile> (Main,Label l) -etx\\<rightarrow> (Main,nx'\\<oplus>#:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  nx' = Label 0\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l -IEdge etx\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             Label\n                              l) -etx\\<rightarrow> (Main,\n              nx' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:PCFG.Main)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -etx\\<rightarrow> (Main,\n            nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -etx\\<rightarrow> (Main,\n            nx' \\<oplus> #:c\\<^sub>1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            l) -etx\\<rightarrow> (Main,\n            nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "case False"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry", "have \"c\\<^sub>1;;prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -IEdge\n          (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_edge_SeqSecond_source_not_Entry)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -IEdge\n        (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "hence \"c\\<^sub>1;;prog,procs \\<turnstile> (Main,nx \\<oplus> #:c\\<^sub>1) -kind a\\<rightarrow> (Main,nx' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -IEdge\n        (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             nx \\<oplus> #:c\\<^sub>1) -kind\n                  a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           nx \\<oplus> #:c\\<^sub>1) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           nx \\<oplus> #:c\\<^sub>1) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           nx \\<oplus> #:c\\<^sub>1) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (Proc p ins outs c nx n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close> \n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (MainCall l p es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  kind a\n  (p, Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> wf \\<open>(p, Entry) = targetnode a\\<close>[THEN sym]\n      \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym]\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l", "by fastforce"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"c\\<^sub>1;;prog \\<turnstile> Label l \\<oplus> #:c\\<^sub>1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> Label\n                       l \\<oplus> #:c\\<^sub>1 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by -(rule Proc_CFG_edge_SeqSecond_source_not_Entry,auto)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "have \"c\\<^sub>1;;prog,procs \\<turnstile> (Main,Label (l + #:c\\<^sub>1)) \n      -(\\<lambda>s. True):(Main,n' \\<oplus> #:c\\<^sub>1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es\\<rightarrow> (p,Entry)\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             Label\n                              (l +\n                               #:c\\<^sub>1)) -\\<lambda>s.\n           True:(Main,\n                 n' \\<oplus> #:c\\<^sub>1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map\ninterpret es\\<rightarrow> (p, Entry)", "by(fastforce intro:PCFG.MainCall)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            (l +\n                             #:c\\<^sub>1)) -\\<lambda>s.\n         True:(Main,\n               n' \\<oplus> #:c\\<^sub>1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                    interpret es\\<rightarrow> (p, Entry)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            (l +\n                             #:c\\<^sub>1)) -\\<lambda>s.\n         True:(Main,\n               n' \\<oplus> #:c\\<^sub>1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                    interpret es\\<rightarrow> (p, Entry)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (ProcCall p ins outs c l p' es' rets' l' ins' outs' c')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(p, Label l) = sourcenode a\\<close>[THEN sym]\n      \\<open>(p', Entry) = targetnode a\\<close>[THEN sym]  \\<open>well_formed procs\\<close>\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (MainReturn l p es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> wf \\<open>(p, Exit) = sourcenode a\\<close>[THEN sym]\n      \\<open>(Main, Label l') = targetnode a\\<close>[THEN sym]\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l'\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l'", "by fastforce"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"c\\<^sub>1;;prog \\<turnstile> Label l \\<oplus> #:c\\<^sub>1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> Label\n                       l \\<oplus> #:c\\<^sub>1 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1", "by -(rule Proc_CFG_edge_SeqSecond_source_not_Entry,auto)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1", "have \"c\\<^sub>1;;prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (Main,Label l' \\<oplus> #:c\\<^sub>1))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label (l' + #:c\\<^sub>1))\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c\\<^sub>1;;\n  prog \\<turnstile> Label\n                     l \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n    snd cf =\n    (Main,\n     Label\n      l' \\<oplus> #:c\\<^sub>1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                            cf'. cf'(rets [:=]\n                            map cf\n                             outs)\\<rightarrow> (Main,\n           Label (l' + #:c\\<^sub>1))", "by(fastforce intro:PCFG.MainReturn)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l' \\<oplus> #:c\\<^sub>1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                          cf'. cf'(rets [:=]\n                          map cf\n                           outs)\\<rightarrow> (Main,\n         Label (l' + #:c\\<^sub>1))\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l' \\<oplus> #:c\\<^sub>1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                          cf'. cf'(rets [:=]\n                          map cf\n                           outs)\\<rightarrow> (Main,\n         Label (l' + #:c\\<^sub>1))\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (ProcReturn p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(p', Exit) = sourcenode a\\<close>[THEN sym] \n      \\<open>(p, Label l') = targetnode a\\<close>[THEN sym] \\<open>well_formed procs\\<close>\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (MainCallReturn nx p es rets nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"c\\<^sub>1;;prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_edge_SeqSecond_source_not_Entry)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "hence \"c\\<^sub>1;;prog,procs \\<turnstile> (Main,n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                    False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                 nx' \\<oplus> #:c\\<^sub>1)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n               nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n               nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"nx \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry", "have \"c\\<^sub>1;;prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_edge_SeqSecond_source_not_Entry)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "hence \"c\\<^sub>1;;prog,procs \\<turnstile> (Main,nx \\<oplus> #:c\\<^sub>1) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             nx \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                     False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                  nx' \\<oplus> #:c\\<^sub>1)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           nx \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           nx \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                nx' \\<oplus> #:c\\<^sub>1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           nx \\<oplus> #:c\\<^sub>1) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                nx' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "case (ProcCallReturn p ins outs c nx p' es' rets' n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_Main_SeqSecond:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"Rep_wf_prog wfp' = (c\\<^sub>1;;prog,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> #:c\\<^sub>1) -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* (p',n' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, n) as (p', n');\n     \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                       (as \\<oplus>s #:c\\<^sub>1)\n                       (p', n' \\<oplus> #:c\\<^sub>1)", "proof(induct \"(Main,n)\" as \"(p',n')\" arbitrary:n rule:ProcCFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1)\n                       ([] \\<oplus>s #:c\\<^sub>1)\n                       (p', n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "case empty_path"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp (Main, n')\n  Main = p'\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  n' \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1)\n                       ([] \\<oplus>s #:c\\<^sub>1)\n                       (p', n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main, n')\\<close>\n    \\<open>n' \\<noteq> Entry\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (c\\<^sub>1;;prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (c\\<^sub>1;; prog, procs)", "have \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (c\\<^sub>1;; prog, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:valid_node_Main_SeqSecond)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1)\n                       ([] \\<oplus>s #:c\\<^sub>1)\n                       (p', n' \\<oplus> #:c\\<^sub>1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "with \\<open>Main = p'\\<close>"], ["proof (chain)\npicking this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1)", "show ?case"], ["proof (prove)\nusing this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1)\n     ([] \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:ProcCFG.empty_path simp:label_incrs_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1)\n   ([] \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "case (Cons_path n'' as a n)"], ["proof (state)\nthis:\n  ProcCFG.path wfp n'' as (p', n')\n  \\<lbrakk>n'' = (Main, ?n); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?n \\<oplus> #:c\\<^sub>1)\n                     (as \\<oplus>s #:c\\<^sub>1)\n                     (p', n' \\<oplus> #:c\\<^sub>1)\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "note IH = \\<open>\\<And>n.  \\<lbrakk>n'' = (Main, n); \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk> \n    \\<Longrightarrow> wfp' \\<turnstile> (Main, n \\<oplus> #:c\\<^sub>1) -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* (p', n' \\<oplus> #:c\\<^sub>1)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' = (Main, ?n); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?n \\<oplus> #:c\\<^sub>1)\n                     (as \\<oplus>s #:c\\<^sub>1)\n                     (p', n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>Rep_wf_prog wfp' = (c\\<^sub>1;;prog,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (c\\<^sub>1;; prog, procs)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\"\n    and \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs", "obtain nx'' where \"n'' = (Main,nx'')\" and \"nx'' \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>nx''.\n        \\<lbrakk>n'' = (Main, nx''); nx'' \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  n'' = (Main, nx'')\n  nx'' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "from IH[OF \\<open>n'' = (Main,nx'')\\<close> \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close> \\<open>nx'' \\<noteq> Entry\\<close>]"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)", "have path:\"wfp' \\<turnstile> (Main, nx'' \\<oplus> #:c\\<^sub>1) -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* (p', n' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n     (as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)", "."], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>n'' = (Main,nx'')\\<close> \\<open>n \\<noteq> Entry\\<close> \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs", "have \"c\\<^sub>1;; prog,procs \\<turnstile> (Main, n \\<oplus> #:c\\<^sub>1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    prog,procs \\<turnstile> (Main,\n                             n \\<oplus> #:c\\<^sub>1) -kind\n                 a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:PCFG_Main_edge_SeqSecond_source_not_Entry simp:valid_edge_def)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1)\n                              (as \\<oplus>s #:c\\<^sub>1)\n                              (p', n' \\<oplus> #:c\\<^sub>1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "with path \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' = (Main,nx'')\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1)", "show ?case"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  c\\<^sub>1;;\n  prog,procs \\<turnstile> (Main,\n                           n \\<oplus> #:c\\<^sub>1) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n     (a # as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n                 (as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1);\n        sourcenode a = (Main, n); targetnode a = n''; n'' = (Main, nx'');\n        c\\<^sub>1;;\n        prog,procs \\<turnstile> (Main,\n                                 n \\<oplus> #:c\\<^sub>1) -kind\n                     a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1);\n        a = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (a # as \\<oplus>s #:c\\<^sub>1)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "apply(clarsimp simp:label_incrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1)\n                 (map (\\<lambda>((p, n), et, p', n').\n                          ((p, n \\<oplus> #:c\\<^sub>1), et, p',\n                           n' \\<oplus> #:c\\<^sub>1))\n                   as)\n                 (p', n' \\<oplus> #:c\\<^sub>1);\n        n'' = (Main, nx'');\n        c\\<^sub>1;;\n        prog,procs \\<turnstile> (Main,\n                                 n \\<oplus> #:c\\<^sub>1) -ba\\<rightarrow> (Main,\n                                     nx'' \\<oplus> #:c\\<^sub>1);\n        a = ((Main, n), ba, Main, nx'')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n                          (((Main, n \\<oplus> #:c\\<^sub>1), ba, Main,\n                            nx'' \\<oplus> #:c\\<^sub>1) #\n                           map (\\<lambda>((p, n), et, p', n').\n                                   ((p, n \\<oplus> #:c\\<^sub>1), et, p',\n                                    n' \\<oplus> #:c\\<^sub>1))\n                            as)\n                          (p', n' \\<oplus> #:c\\<^sub>1)", "by(auto intro:ProcCFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1)\n   (a # as \\<oplus>s #:c\\<^sub>1) (p', n' \\<oplus> #:c\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>From \\<open>prog\\<close> to \\<open>if (b) prog else c\\<^sub>2\\<close>\\<close>"], ["", "lemma Proc_CFG_edge_CondTrue_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> if (b) prog else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> if (b) prog\n                      else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "by(induct rule:Proc_CFG.induct)(fastforce intro:Proc_CFG_CondThen Proc_CFG.intros)+"], ["", "lemma PCFG_Main_edge_CondTrue_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,n \\<oplus> 1) -et\\<rightarrow> (p',n' \\<oplus> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> (Main, n) -et\\<rightarrow> (p', n');\n     n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n    \\<Longrightarrow> if (b) prog\n                      else c\\<^sub>2,procs \\<turnstile> (Main,\n                   n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)", "proof(induct \"(Main,n)\" et \"(p',n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 1)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 1)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 1)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 1)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "case Main"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind et_\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 1)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 1)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 1)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 1)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind et_\n  well_formed procs\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n n \\<oplus> 1) -et_\\<rightarrow> (p', n' \\<oplus> 1)", "by(fastforce dest:Proc_CFG_edge_CondTrue_source_not_Entry intro:PCFG.Main)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -et_\\<rightarrow> (p',\n                                n' \\<oplus> 1)\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "case (MainCallReturn p es rets)"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "from \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "by(rule Proc_CFG_edge_CondTrue_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "with MainCallReturn"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n n \\<oplus> 1) -(\\<lambda>s.\n                    False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "by(fastforce intro:PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)\n\ngoal (6 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -et\\<rightarrow> (p', n' \\<oplus> 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 1)\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) prog\n                         else c\\<^sub>2,procs \\<turnstile> (Main,\n                      n \\<oplus> 1) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 1)", "qed (auto simp:intra_kind_def)"], ["", "lemma valid_node_Main_CondTrue:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n \\<oplus> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n)", "obtain a where \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\"\n    and \"(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>prog,procs \\<turnstile> sourcenode\n    a -kind a\\<rightarrow> targetnode a;\n         (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from this \\<open>n \\<noteq> Entry\\<close> wf"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs", "show ?thesis"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (Main nx nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n         (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1", "by(fastforce intro:Proc_CFG_edge_CondTrue_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "hence \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,n \\<oplus> 1) -kind a\\<rightarrow> (Main,nx' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n n \\<oplus> 1) -kind a\\<rightarrow> (Main, nx' \\<oplus> 1)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -kind\n               a\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -kind\n               a\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "proof(cases \"nx = Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case True"], ["proof (state)\nthis:\n  nx = Entry\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry", "have \"nx' = Exit \\<or> nx' = Label 0\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry\n\ngoal (1 subgoal):\n 1. nx' = Exit \\<or> nx' = Label 0", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "assume \"nx' = Exit\""], ["proof (state)\nthis:\n  nx' = Exit\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "assume \"nx' = Label 0\""], ["proof (state)\nthis:\n  nx' = Label 0\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> Label 0 \n            -IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> Label\n                                 0 -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1", "by(rule Proc_CFG_CondTrue)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>nx' = Label 0\\<close>"], ["proof (chain)\npicking this:\n  nx' = Label 0\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1", "have \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,Label 0) \n            -(\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  nx' = Label 0\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n Label\n  0) -(\\<lambda>cf.\n          state_check cf b\n           (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)", "by(fastforce intro:PCFG.Main)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case False"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -IEdge\n          (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1", "by(fastforce intro:Proc_CFG_edge_CondTrue_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -IEdge\n        (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "hence \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,nx \\<oplus> 1) -kind a\\<rightarrow> \n          (Main,nx' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -IEdge\n        (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n nx \\<oplus> 1) -kind a\\<rightarrow> (Main, nx' \\<oplus> 1)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 1) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 1) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 1) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (Proc p ins outs c nx n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (MainCall l p es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  kind a\n  (p, Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p, Entry) = targetnode a\\<close>[THEN sym] \n      \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym] wf\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l", "by fastforce"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> Label l \\<oplus> 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> Label\n                                 l \\<oplus> 1 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "by -(rule Proc_CFG_edge_CondTrue_source_not_Entry,auto)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "have \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,Label (l + 1)) \n      -(\\<lambda>s. True):(Main,n' \\<oplus> 1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es\\<rightarrow> (p,Entry)\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n Label\n  (l +\n   1)) -\\<lambda>s.\n           True:(Main,\n                 n' \\<oplus> 1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                            interpret es\\<rightarrow> (p, Entry)", "by(fastforce intro:PCFG.MainCall)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n(l +\n 1)) -\\<lambda>s.\n         True:(Main,\n               n' \\<oplus> 1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es\\<rightarrow> (p, Entry)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?case"], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n(l +\n 1)) -\\<lambda>s.\n         True:(Main,\n               n' \\<oplus> 1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                          es\\<rightarrow> (p, Entry)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (ProcCall p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  (p, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(p, Label l) = sourcenode a\\<close>[THEN sym] \n      \\<open>(p', Entry) = targetnode a\\<close>[THEN sym] \\<open>well_formed procs\\<close> \n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (MainReturn l p es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p, Exit) = sourcenode a\\<close>[THEN sym] \n      \\<open>(Main, Label l') = targetnode a\\<close>[THEN sym] wf\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l'\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l'", "by fastforce"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> Label l \\<oplus> 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> Label\n                                 l \\<oplus> 1 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 1", "by -(rule Proc_CFG_edge_CondTrue_source_not_Entry,auto)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 1\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 1", "have \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (Main,Label l' \\<oplus> 1))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label (l' + 1))\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (p,\n Exit) -\\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l' \\<oplus> 1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=]\n                         map cf outs)\\<rightarrow> (Main, Label (l' + 1))", "by(fastforce intro:PCFG.MainReturn)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n            snd cf =\n            (Main,\n             Label\n              l' \\<oplus> 1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                          cf'. cf'(rets [:=]\n                          map cf outs)\\<rightarrow> (Main, Label (l' + 1))\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?case"], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n            snd cf =\n            (Main,\n             Label\n              l' \\<oplus> 1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                          cf'. cf'(rets [:=]\n                          map cf outs)\\<rightarrow> (Main, Label (l' + 1))\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (ProcReturn p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(p', Exit) = sourcenode a\\<close>[THEN sym] \n      \\<open>(p, Label l') = targetnode a\\<close>[THEN sym] \\<open>well_formed procs\\<close>\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (MainCallReturn nx p es rets nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1", "by(fastforce intro:Proc_CFG_edge_CondTrue_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "hence \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,n \\<oplus> 1) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> \n        (Main,nx' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n n \\<oplus> 1) -(\\<lambda>s.\n                    False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"nx \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry", "have \"if (b) prog else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1", "by(fastforce intro:Proc_CFG_edge_CondTrue_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "hence \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main,nx \\<oplus> 1) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  if (b) prog\n  else c\\<^sub>2 \\<turnstile> nx \\<oplus> 1 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n nx \\<oplus> 1) -(\\<lambda>s.\n                     False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                  nx' \\<oplus> 1)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 1) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 1) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 1) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "case (ProcCallReturn p ins outs c nx p' es' rets' n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_Main_CondTrue:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> 1) -as \\<oplus>s 1\\<rightarrow>* (p',n' \\<oplus> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, n) as (p', n');\n     \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                       (as \\<oplus>s 1) (p', n' \\<oplus> 1)", "proof(induct \"(Main,n)\" as \"(p',n')\" arbitrary:n rule:ProcCFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> 1)\n                       ([] \\<oplus>s 1) (p', n' \\<oplus> 1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "case empty_path"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp (Main, n')\n  Main = p'\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  n' \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> 1)\n                       ([] \\<oplus>s 1) (p', n' \\<oplus> 1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main, n')\\<close>\n    \\<open>n' \\<noteq> Entry\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2,procs)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2, procs)", "have \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n' \\<oplus> 1)", "by(fastforce intro:valid_node_Main_CondTrue)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> 1)\n                       ([] \\<oplus>s 1) (p', n' \\<oplus> 1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "with \\<open>Main = p'\\<close>"], ["proof (chain)\npicking this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> 1)", "show ?case"], ["proof (prove)\nusing this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n' \\<oplus> 1) ([] \\<oplus>s 1)\n     (p', n' \\<oplus> 1)", "by(fastforce intro:ProcCFG.empty_path simp:label_incrs_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n' \\<oplus> 1) ([] \\<oplus>s 1)\n   (p', n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "case (Cons_path n'' as a n)"], ["proof (state)\nthis:\n  ProcCFG.path wfp n'' as (p', n')\n  \\<lbrakk>n'' = (Main, ?n); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?n \\<oplus> 1) (as \\<oplus>s 1)\n                     (p', n' \\<oplus> 1)\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "note IH = \\<open>\\<And>n.  \\<lbrakk>n'' = (Main, n); \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk> \n    \\<Longrightarrow> wfp' \\<turnstile> (Main, n \\<oplus> 1) -as \\<oplus>s 1\\<rightarrow>* (p', n' \\<oplus> 1)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' = (Main, ?n); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?n \\<oplus> 1) (as \\<oplus>s 1)\n                     (p', n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) prog else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\"\n    and \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs", "obtain nx'' where \"n'' = (Main,nx'')\" and \"nx'' \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>nx''.\n        \\<lbrakk>n'' = (Main, nx''); nx'' \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  n'' = (Main, nx'')\n  nx'' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "from IH[OF \\<open>n'' = (Main,nx'')\\<close> \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close> \\<open>nx'' \\<noteq> Entry\\<close>]"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 1) (as \\<oplus>s 1)\n   (p', n' \\<oplus> 1)", "have path:\"wfp' \\<turnstile> (Main, nx'' \\<oplus> 1) -as \\<oplus>s 1\\<rightarrow>* (p', n' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 1) (as \\<oplus>s 1)\n   (p', n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, nx'' \\<oplus> 1) (as \\<oplus>s 1)\n     (p', n' \\<oplus> 1)", "."], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 1) (as \\<oplus>s 1)\n   (p', n' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>n'' = (Main,nx'')\\<close> \\<open>n \\<noteq> Entry\\<close> \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs", "have \"if (b) prog else c\\<^sub>2,procs \\<turnstile> (Main, n \\<oplus> 1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. if (b) prog\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n n \\<oplus> 1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> 1)", "by(fastforce intro:PCFG_Main_edge_CondTrue_source_not_Entry simp:valid_edge_def)"], ["proof (state)\nthis:\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                              (as \\<oplus>s 1) (p', n' \\<oplus> 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "with path \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' = (Main,nx'')\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 1) (as \\<oplus>s 1)\n   (p', n' \\<oplus> 1)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> 1)", "show ?case"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 1) (as \\<oplus>s 1)\n   (p', n' \\<oplus> 1)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  if (b) prog\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     n \\<oplus> 1) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n \\<oplus> 1) (a # as \\<oplus>s 1)\n     (p', n' \\<oplus> 1)", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba c d.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> 1) (as \\<oplus>s 1)\n                 (p', n' \\<oplus> 1);\n        sourcenode a = (Main, n); targetnode a = n''; n'' = (Main, nx'');\n        if (b) prog\n        else c\\<^sub>2,procs \\<turnstile> (Main,\n     n \\<oplus> 1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> 1);\n        a = (aa, ba, c, d)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (a # as \\<oplus>s 1) (p', n' \\<oplus> 1)", "apply(clarsimp simp:label_incrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> 1)\n                 (map (\\<lambda>((p, n), et, p', n').\n                          ((p, n \\<oplus> 1), et, p', n' \\<oplus> 1))\n                   as)\n                 (p', n' \\<oplus> 1);\n        n'' = (Main, nx'');\n        if (b) prog\n        else c\\<^sub>2,procs \\<turnstile> (Main,\n     n \\<oplus> 1) -ba\\<rightarrow> (Main, nx'' \\<oplus> 1);\n        a = ((Main, n), ba, Main, nx'')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 1)\n                          (((Main, n \\<oplus> 1), ba, Main,\n                            nx'' \\<oplus> 1) #\n                           map (\\<lambda>((p, n), et, p', n').\n                                   ((p, n \\<oplus> 1), et, p',\n                                    n' \\<oplus> 1))\n                            as)\n                          (p', n' \\<oplus> 1)", "by(auto intro:ProcCFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n \\<oplus> 1) (a # as \\<oplus>s 1)\n   (p', n' \\<oplus> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>From \\<open>prog\\<close> to \\<open>if (b) c\\<^sub>1 else prog\\<close>\\<close>"], ["", "lemma Proc_CFG_edge_CondFalse_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \n  \\<Longrightarrow> if (b) c\\<^sub>1 else prog \\<turnstile> n \\<oplus> (#:c\\<^sub>1 + 1) -et\\<rightarrow>\\<^sub>p n' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> if (b) c\\<^sub>1\n                      else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                  1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1", "by(induct rule:Proc_CFG.induct)(fastforce intro:Proc_CFG_CondElse Proc_CFG.intros)+"], ["", "lemma PCFG_Main_edge_CondFalse_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,n \\<oplus> (#:c\\<^sub>1 + 1)) -et\\<rightarrow> (p',n' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> (Main, n) -et\\<rightarrow> (p', n');\n     n \\<noteq> Entry; intra_kind et; well_formed procs\\<rbrakk>\n    \\<Longrightarrow> if (b) c\\<^sub>1\n                      else prog,procs \\<turnstile> (Main,\n              n \\<oplus> #:c\\<^sub>1 +\n                         1) -et\\<rightarrow> (p',\n        n' \\<oplus> #:c\\<^sub>1 + 1)", "proof(induct \"(Main,n)\" et \"(p',n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (Main,\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets [:=]\n   map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (p',\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets' [:=]\n   map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)", "case Main"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind et_\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (Main,\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets [:=]\n   map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (p',\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets' [:=]\n   map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind et_\n  well_formed procs\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  n \\<oplus> #:c\\<^sub>1 +\n       1) -et_\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce dest:Proc_CFG_edge_CondFalse_source_not_Entry intro:PCFG.Main)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -et_\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (Main,\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets [:=]\n   map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (p',\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets' [:=]\n   map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (Main,\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets [:=]\n   map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (p',\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets' [:=]\n   map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)", "case (MainCallReturn p es rets)"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (Main,\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets [:=]\n   map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (p',\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets' [:=]\n   map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> n \\<oplus> (#:c\\<^sub>1 + 1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1", "by(rule Proc_CFG_edge_CondFalse_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                                    1 -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (Main,\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets [:=]\n   map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (p',\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets' [:=]\n   map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)", "with MainCallReturn"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                                    1 -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                                    1 -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  n \\<oplus> #:c\\<^sub>1 +\n       1) -(\\<lambda>s.\n               False)\\<^sub>\\<surd>\\<rightarrow> (p',\n            n' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -(\\<lambda>s.\n             False)\\<^sub>\\<surd>\\<rightarrow> (p',\n          n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (6 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -et\\<rightarrow> (p',\n           n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>s.\n                                   True:(Main,\n   Label\n    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n     es'\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (Main,\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets [:=]\n   map cf outs)\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -\\<lambda>cf.\n                                   snd cf =\n                                   (p',\n                                    Label\n                                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf\n   cf'. cf'(rets' [:=]\n   map cf outs')\\<rightarrow> (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> if (b) c\\<^sub>1\n                         else prog,procs \\<turnstile> (Main,\n                 n \\<oplus> #:c\\<^sub>1 +\n                            1) -(\\<lambda>s.\n                                    False)\\<^sub>\\<surd>\\<rightarrow> (p',\n                                 n' \\<oplus> #:c\\<^sub>1 + 1)", "qed (auto simp:intra_kind_def)"], ["", "lemma valid_node_Main_CondFalse:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') \n  (Main, n \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n)", "obtain a where \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\"\n    and \"(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>prog,procs \\<turnstile> sourcenode\n    a -kind a\\<rightarrow> targetnode a;\n         (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from this \\<open>n \\<noteq> Entry\\<close> wf"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs", "show ?thesis"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (Main nx nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> n \\<oplus> (#:c\\<^sub>1 + 1) -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n1 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1", "by(fastforce intro:Proc_CFG_edge_CondFalse_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                                    1 -IEdge\n  (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "hence \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,n \\<oplus> (#:c\\<^sub>1 + 1)) -kind a\\<rightarrow> \n        (Main,nx' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                                    1 -IEdge\n  (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  n \\<oplus> #:c\\<^sub>1 +\n       1) -kind a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1 + 1)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -kind a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -kind a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "proof(cases \"nx = Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case True"], ["proof (state)\nthis:\n  nx = Entry\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry", "have \"nx' = Exit \\<or> nx' = Label 0\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry\n\ngoal (1 subgoal):\n 1. nx' = Exit \\<or> nx' = Label 0", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "assume \"nx' = Exit\""], ["proof (state)\nthis:\n  nx' = Exit\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "assume \"nx' = Label 0\""], ["proof (state)\nthis:\n  nx' = Label 0\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> Label 0 \n            -IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label (#:c\\<^sub>1 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> Label\n                            0 -IEdge\n                                (\\<lambda>cf.\n                                    state_check cf b\n                                     (Some\n false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label (#:c\\<^sub>1 + 1)", "by(rule Proc_CFG_CondFalse)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          0 -IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some\n                                     false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label\n     (#:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>nx' = Label 0\\<close>"], ["proof (chain)\npicking this:\n  nx' = Label 0\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          0 -IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some\n                                     false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label\n     (#:c\\<^sub>1 + 1)", "have \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,Label 0) \n            -(\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  nx' = Label 0\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          0 -IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some\n                                     false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label\n     (#:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  Label\n                                   0) -(\\<lambda>cf.\n     state_check cf b\n      (Some\n        false))\\<^sub>\\<surd>\\<rightarrow> (Main,\n      nx' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:PCFG.Main)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                Label\n                                 0) -(\\<lambda>cf.\n   state_check cf b\n    (Some\n      false))\\<^sub>\\<surd>\\<rightarrow> (Main,\n    nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                Label\n                                 0) -(\\<lambda>cf.\n   state_check cf b\n    (Some\n      false))\\<^sub>\\<surd>\\<rightarrow> (Main,\n    nx' \\<oplus> #:c\\<^sub>1 + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                Label\n                                 0) -(\\<lambda>cf.\n   state_check cf b\n    (Some\n      false))\\<^sub>\\<surd>\\<rightarrow> (Main,\n    nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case False"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> nx \\<oplus> (#:c\\<^sub>1 + 1) -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 +\n 1 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1", "by(fastforce intro:Proc_CFG_edge_CondFalse_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 +\n                                     1 -IEdge\n   (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "hence \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,nx \\<oplus> (#:c\\<^sub>1 + 1)) -kind a\\<rightarrow> \n          (Main,nx' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 +\n                                     1 -IEdge\n   (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  nx \\<oplus> #:c\\<^sub>1 +\n        1) -kind a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1 + 1)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                nx \\<oplus> #:c\\<^sub>1 +\n      1) -kind a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                nx \\<oplus> #:c\\<^sub>1 +\n      1) -kind a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1 + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                nx \\<oplus> #:c\\<^sub>1 +\n      1) -kind a\\<rightarrow> (Main, nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (Proc p ins outs c nx n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (MainCall l p es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  kind a\n  (p, Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p, Entry) = targetnode a\\<close>[THEN sym]\n      \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym] wf\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l", "by fastforce"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> Label l \\<oplus> (#:c\\<^sub>1 + 1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n      n' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> Label\n                            l \\<oplus> #:c\\<^sub>1 +\n 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1", "by -(rule Proc_CFG_edge_CondFalse_source_not_Entry,auto)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1", "have \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,Label (l + (#:c\\<^sub>1 + 1))) \n      -(\\<lambda>s. True):(Main,n' \\<oplus> (#:c\\<^sub>1 + 1))\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es\\<rightarrow> (p,Entry)\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  Label\n                                   (l +\n                                    (#:c\\<^sub>1 +\n                                     1))) -\\<lambda>s.\n        True:(Main,\n              n' \\<oplus> #:c\\<^sub>1 +\n                          1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                         es\\<rightarrow> (p, Entry)", "by(fastforce intro:PCFG.MainCall)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                Label\n                                 (l +\n                                  (#:c\\<^sub>1 +\n                                   1))) -\\<lambda>s.\n      True:(Main,\n            n' \\<oplus> #:c\\<^sub>1 +\n                        1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                       es\\<rightarrow> (p, Entry)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                Label\n                                 (l +\n                                  (#:c\\<^sub>1 +\n                                   1))) -\\<lambda>s.\n      True:(Main,\n            n' \\<oplus> #:c\\<^sub>1 +\n                        1)\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                       es\\<rightarrow> (p, Entry)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (ProcCall p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  (p, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(p, Label l) = sourcenode a\\<close>[THEN sym]\n      \\<open>(p', Entry) = targetnode a\\<close>[THEN sym]  \\<open>well_formed procs\\<close>\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (MainReturn l p es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p, Exit) = sourcenode a\\<close>[THEN sym]\n      \\<open>(Main, Label l') = targetnode a\\<close>[THEN sym] wf\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l'\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l'", "by fastforce"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> Label l \\<oplus> (#:c\\<^sub>1 + 1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n      Label l' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> Label\n                            l \\<oplus> #:c\\<^sub>1 +\n 1 -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1 + 1", "by -(rule Proc_CFG_edge_CondFalse_source_not_Entry,auto)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1 + 1", "have \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (p,Exit) \n      -(\\<lambda>cf. snd cf = (Main,Label l' \\<oplus> (#:c\\<^sub>1 + 1)))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label (l' + (#:c\\<^sub>1 + 1)))\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n         snd cf =\n         (Main,\n          Label\n           l' \\<oplus> #:c\\<^sub>1 +\n                       1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                       cf'(rets [:=]\n                       map cf\n                        outs)\\<rightarrow> (Main,\n      Label (l' + (#:c\\<^sub>1 + 1)))", "by(fastforce intro:PCFG.MainReturn)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n       snd cf =\n       (Main,\n        Label\n         l' \\<oplus> #:c\\<^sub>1 +\n                     1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                     cf'(rets [:=]\n                     map cf\n                      outs)\\<rightarrow> (Main,\n    Label (l' + (#:c\\<^sub>1 + 1)))\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n       snd cf =\n       (Main,\n        Label\n         l' \\<oplus> #:c\\<^sub>1 +\n                     1)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                     cf'(rets [:=]\n                     map cf\n                      outs)\\<rightarrow> (Main,\n    Label (l' + (#:c\\<^sub>1 + 1)))\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (ProcReturn p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(p', Exit) = sourcenode a\\<close>[THEN sym] \n      \\<open>(p, Label l') = targetnode a\\<close>[THEN sym] \\<open>well_formed procs\\<close>\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (MainCallReturn nx p es rets nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> n \\<oplus> (#:c\\<^sub>1 + 1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n        nx' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1", "by(fastforce intro:Proc_CFG_edge_CondFalse_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                                    1 -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "hence \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,n \\<oplus> (#:c\\<^sub>1 + 1)) \n        -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n                                    1 -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  n \\<oplus> #:c\\<^sub>1 +\n       1) -(\\<lambda>s.\n               False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n            nx' \\<oplus> #:c\\<^sub>1 + 1)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -(\\<lambda>s.\n             False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n          nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -(\\<lambda>s.\n             False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n          nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"nx \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry", "have \"if (b) c\\<^sub>1 else prog \\<turnstile> nx \\<oplus> (#:c\\<^sub>1 + 1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n        nx' \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 +\n 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1", "by(fastforce intro:Proc_CFG_edge_CondFalse_source_not_Entry)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "hence \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main,nx \\<oplus> (#:c\\<^sub>1 + 1)) \n        -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else prog \\<turnstile> nx \\<oplus> #:c\\<^sub>1 +\n                                     1 -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  nx \\<oplus> #:c\\<^sub>1 +\n        1) -(\\<lambda>s.\n                False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n             nx' \\<oplus> #:c\\<^sub>1 + 1)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                nx \\<oplus> #:c\\<^sub>1 +\n      1) -(\\<lambda>s.\n              False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n           nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                nx \\<oplus> #:c\\<^sub>1 +\n      1) -(\\<lambda>s.\n              False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n           nx' \\<oplus> #:c\\<^sub>1 + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                nx \\<oplus> #:c\\<^sub>1 +\n      1) -(\\<lambda>s.\n              False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n           nx' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "case (ProcCallReturn p ins outs c nx p' es' rets' n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_Main_CondFalse:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> (#:c\\<^sub>1 + 1)) -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* (p',n' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, n) as (p', n');\n     \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                       (as \\<oplus>s #:c\\<^sub>1 + 1)\n                       (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "proof(induct \"(Main,n)\" as \"(p',n')\" arbitrary:n rule:ProcCFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)\n                       ([] \\<oplus>s #:c\\<^sub>1 + 1)\n                       (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "case empty_path"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp (Main, n')\n  Main = p'\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  n' \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)\n                       ([] \\<oplus>s #:c\\<^sub>1 + 1)\n                       (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main, n')\\<close>\n    \\<open>n' \\<noteq> Entry\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog, procs)", "have \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:valid_node_Main_CondFalse)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)\n                       ([] \\<oplus>s #:c\\<^sub>1 + 1)\n                       (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "with \\<open>Main = p'\\<close>"], ["proof (chain)\npicking this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)", "show ?case"], ["proof (prove)\nusing this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)\n     ([] \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:ProcCFG.empty_path simp:label_incrs_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n' \\<oplus> #:c\\<^sub>1 + 1)\n   ([] \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "case (Cons_path n'' as a n)"], ["proof (state)\nthis:\n  ProcCFG.path wfp n'' as (p', n')\n  \\<lbrakk>n'' = (Main, ?n); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?n \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?n \\<oplus> #:c\\<^sub>1 + 1)\n                     (as \\<oplus>s #:c\\<^sub>1 + 1)\n                     (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "note IH = \\<open>\\<And>n. \\<And>n.  \\<lbrakk>n'' = (Main, n); \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> wfp' \\<turnstile> (Main, n \\<oplus> (#:c\\<^sub>1 + 1)) -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* (p', n' \\<oplus> (#:c\\<^sub>1 + 1))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' = (Main, ?na); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?na \\<noteq> Entry\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?na \\<oplus> #:c\\<^sub>1 + 1)\n                     (as \\<oplus>s #:c\\<^sub>1 + 1)\n                     (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (if (b) c\\<^sub>1 else prog, procs)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\"\n    and \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs", "obtain nx'' where \"n'' = (Main,nx'')\" and \"nx'' \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>nx''.\n        \\<lbrakk>n'' = (Main, nx''); nx'' \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  n'' = (Main, nx'')\n  nx'' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "from IH[OF \\<open>n'' = (Main,nx'')\\<close> \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close> \\<open>nx'' \\<noteq> Entry\\<close>]"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "have path:\"wfp' \\<turnstile> (Main, nx'' \\<oplus> (#:c\\<^sub>1 + 1)) -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* \n    (p', n' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n     (as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "."], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>n'' = (Main,nx'')\\<close> \\<open>n \\<noteq> Entry\\<close> \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs", "have \"if (b) c\\<^sub>1 else prog,procs \\<turnstile> (Main, n \\<oplus> (#:c\\<^sub>1 + 1)) -kind a\\<rightarrow> \n    (Main, nx'' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else prog,procs \\<turnstile> (Main,\n                                  n \\<oplus> #:c\\<^sub>1 +\n       1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)", "by(fastforce intro:PCFG_Main_edge_CondFalse_source_not_Entry simp:valid_edge_def)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            n \\<noteq> Entry\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp'\n                              (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                              (as \\<oplus>s #:c\\<^sub>1 + 1)\n                              (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "with path \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' = (Main,nx'')\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)", "show ?case"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  if (b) c\\<^sub>1\n  else prog,procs \\<turnstile> (Main,\n                                n \\<oplus> #:c\\<^sub>1 +\n     1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n     (a # as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba c d.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n                 (as \\<oplus>s #:c\\<^sub>1 + 1)\n                 (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        sourcenode a = (Main, n); targetnode a = n''; n'' = (Main, nx'');\n        if (b) c\\<^sub>1\n        else prog,procs \\<turnstile> (Main,\nn \\<oplus> #:c\\<^sub>1 +\n           1) -kind a\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1);\n        a = (aa, ba, c, d)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (a # as \\<oplus>s #:c\\<^sub>1 + 1)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "apply(clarsimp simp:label_incrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1)\n                 (map (\\<lambda>((p, n), et, p', n').\n                          ((p, n \\<oplus> #:c\\<^sub>1 + 1), et, p',\n                           n' \\<oplus> #:c\\<^sub>1 + 1))\n                   as)\n                 (p', n' \\<oplus> #:c\\<^sub>1 + 1);\n        n'' = (Main, nx'');\n        if (b) c\\<^sub>1\n        else prog,procs \\<turnstile> (Main,\nn \\<oplus> #:c\\<^sub>1 +\n           1) -ba\\<rightarrow> (Main, nx'' \\<oplus> #:c\\<^sub>1 + 1);\n        a = ((Main, n), ba, Main, nx'')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp'\n                          (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n                          (((Main, n \\<oplus> #:c\\<^sub>1 + 1), ba, Main,\n                            nx'' \\<oplus> #:c\\<^sub>1 + 1) #\n                           map (\\<lambda>((p, n), et, p', n').\n                                   ((p, n \\<oplus> #:c\\<^sub>1 + 1), et, p',\n                                    n' \\<oplus> #:c\\<^sub>1 + 1))\n                            as)\n                          (p', n' \\<oplus> #:c\\<^sub>1 + 1)", "by(auto intro:ProcCFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n \\<oplus> #:c\\<^sub>1 + 1)\n   (a # as \\<oplus>s #:c\\<^sub>1 + 1) (p', n' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>From \\<open>prog\\<close> to \\<open>while (b) prog\\<close>\\<close>"], ["", "lemma Proc_CFG_edge_WhileBody_source_not_Entry:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk> \n  \\<Longrightarrow> while (b) prog \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> while (b) prog \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "by(induct rule:Proc_CFG.induct)(fastforce intro:Proc_CFG_WhileBody Proc_CFG.intros)+"], ["", "lemma PCFG_Main_edge_WhileBody_source_not_Entry:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (p',n'); n \\<noteq> Entry; n' \\<noteq> Exit; intra_kind et; \n  well_formed procs\\<rbrakk> \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,n \\<oplus> 2) -et\\<rightarrow> (p',n' \\<oplus> 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> (Main, n) -et\\<rightarrow> (p', n');\n     n \\<noteq> Entry; n' \\<noteq> Exit; intra_kind et;\n     well_formed procs\\<rbrakk>\n    \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                   n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)", "proof(induct \"(Main,n)\" et \"(p',n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 2)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 2)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 2)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 2)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "case Main"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  intra_kind et_\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit; intra_kind et;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 2. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 3. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 2)\n 4. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 2)\n 5. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 2)\n 6. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 2)\n 7. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)\n 8. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  intra_kind et_\n  well_formed procs\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n n \\<oplus> 2) -et_\\<rightarrow> (p', n' \\<oplus> 2)", "by(fastforce dest:Proc_CFG_edge_WhileBody_source_not_Entry intro:PCFG.Main)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -et_\\<rightarrow> (p',\n                                n' \\<oplus> 2)\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 2)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 2)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 2)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 2)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 2)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 2)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 2)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 2)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "case (MainCallReturn p es rets)"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 2)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 2)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 2)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 2)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "from \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close> \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit", "have \"while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "by(rule Proc_CFG_edge_WhileBody_source_not_Entry)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (7 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 2)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 2)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 2)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 2)\n 6. \\<And>p es rets.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)\n 7. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "with MainCallReturn"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  Main = p'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  well_formed procs\n  while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n n \\<oplus> 2) -(\\<lambda>s.\n                    False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "by(fastforce intro:PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)\n\ngoal (6 subgoals):\n 1. \\<And>ins outs c et ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind et; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -et\\<rightarrow> (p', n' \\<oplus> 2)\n 2. \\<And>l es rets n'a ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (p', ins, outs, c) \\<in> set procs; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        n'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es\\<rightarrow> (p', n' \\<oplus> 2)\n 3. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; Label l = n; Entry = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   Label\n                    l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                     es');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>s.\n  True:(Main,\n        Label\n         l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n          es'\\<rightarrow> (p', n' \\<oplus> 2)\n 4. \\<And>l es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (Main, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins, outs, c) \\<in> set procs; Exit = n; Main = p';\n        Label l' = n'; n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets [:=] map cf outs));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', n' \\<oplus> 2)\n 5. \\<And>ins outs c l es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p', ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (Main, es',\n                             rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p'; Exit = n; Label l' = n';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p',\n              Label\n               l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                   cf'(rets' [:=] map cf outs'));\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n        map cf outs')\\<rightarrow> (p', n' \\<oplus> 2)\n 6. \\<And>ins outs c p'a es' rets' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; Main = p'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> while (b) prog,procs \\<turnstile> (Main,\n                      n \\<oplus> 2) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', n' \\<oplus> 2)", "qed (auto simp:intra_kind_def)"], ["", "lemma valid_node_Main_WhileBody:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\"\n  and \"n \\<noteq> Entry\" and \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (while (b) prog,procs)\"\n  shows \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n \\<oplus> 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n    \\<open>Rep_wf_prog wfp' = (while (b) prog,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (while (b) prog, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main,n)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n)", "obtain a where \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\"\n    and \"(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>prog,procs \\<turnstile> sourcenode\n    a -kind a\\<rightarrow> targetnode a;\n         (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from this \\<open>n \\<noteq> Entry\\<close> wf"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs", "show ?thesis"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (Main nx nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 7. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 8. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof(cases \"nx' = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case True"], ["proof (state)\nthis:\n  nx' = Exit\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx' = Exit", "have \"while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge (kind a)\\<rightarrow>\\<^sub>p Label 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge\n         (kind a)\\<rightarrow>\\<^sub>p Label 0", "by(fastforce intro:Proc_CFG_WhileBodyExit)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p Label 0\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "hence \"while (b) prog,procs \\<turnstile> (Main,n \\<oplus> 2) -kind a\\<rightarrow> (Main,Label 0)\""], ["proof (prove)\nusing this:\n  while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p Label 0\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n n \\<oplus> 2) -kind a\\<rightarrow> (Main, Label 0)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -kind\n               a\\<rightarrow> (Main, Label 0)\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -kind\n               a\\<rightarrow> (Main, Label 0)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case False"], ["proof (state)\nthis:\n  nx' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx' \\<noteq> Exit", "have \"while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge\n         (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2", "by(fastforce intro:Proc_CFG_edge_WhileBody_source_not_Entry)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "hence \"while (b) prog,procs \\<turnstile> (Main,n \\<oplus> 2) -kind a\\<rightarrow> (Main,nx' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  while (b) prog \\<turnstile> n \\<oplus> 2 -IEdge\n       (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n n \\<oplus> 2) -kind a\\<rightarrow> (Main, nx' \\<oplus> 2)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -kind\n               a\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -kind\n               a\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof(cases \"nx = Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case True"], ["proof (state)\nthis:\n  nx = Entry\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry", "have \"nx' = Exit \\<or> nx' = Label 0\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx = Entry\n\ngoal (1 subgoal):\n 1. nx' = Exit \\<or> nx' = Label 0", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (2 subgoals):\n 1. nx = Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nx' = Exit \\<or> nx' = Label 0\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "assume \"nx' = Exit\""], ["proof (state)\nthis:\n  nx' = Exit\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "assume \"nx' = Label 0\""], ["proof (state)\nthis:\n  nx' = Label 0\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "have \"while (b) prog \\<turnstile> Label 0 \n            -IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> Label\n                                 0 -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 2", "by(rule Proc_CFG_WhileTrue)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 2\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "hence \"while (b) prog,procs \\<turnstile> (Main,Label 0) \n            -(\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main,Label 2)\""], ["proof (prove)\nusing this:\n  while (b) prog \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n Label\n  0) -(\\<lambda>cf.\n          state_check cf b\n           (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 2)", "by(fastforce intro:PCFG.Main)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 2)\n\ngoal (1 subgoal):\n 1. nx' = Label 0 \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]\n            \\<open>nx' = Label 0\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Label 0\n  while (b) prog,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Label 0\n  while (b) prog,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case False"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof(cases \"nx' = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case True"], ["proof (state)\nthis:\n  nx' = Exit\n\ngoal (2 subgoals):\n 1. nx' = Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  nx' = Exit\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case False"], ["proof (state)\nthis:\n  nx' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close> \\<open>nx \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n  nx' \\<noteq> Exit", "have \"while (b) prog \\<turnstile> nx \\<oplus> 2 -IEdge (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n  nx' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> nx \\<oplus> 2 -IEdge\n          (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2", "by(fastforce intro:Proc_CFG_edge_WhileBody_source_not_Entry)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> nx \\<oplus> 2 -IEdge\n        (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "hence \"while (b) prog,procs \\<turnstile> (Main,nx \\<oplus> 2)  -kind a\\<rightarrow> \n            (Main,nx' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  while (b) prog \\<turnstile> nx \\<oplus> 2 -IEdge\n        (kind a)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n nx \\<oplus> 2) -kind a\\<rightarrow> (Main, nx' \\<oplus> 2)", "by(rule PCFG.Main)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 2) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  while (b) prog,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 2) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  while (b) prog,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 2) -kind\n                a\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (Proc p ins outs c nx n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close> \n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c na n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 7. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (MainCall l p es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  kind a\n  (p, Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p, Entry) = targetnode a\\<close>[THEN sym]\n      \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym] wf\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  targetnode a = (p, Entry)\n  sourcenode a = (Main, Label l)\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l", "by fastforce"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"n' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. n' \\<noteq> Exit", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  n' \\<noteq> Exit\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit", "have \"while (b) prog \\<turnstile> Label l \\<oplus> 2 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n      n' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> Label\n                                 l \\<oplus> 2 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "by -(rule Proc_CFG_edge_WhileBody_source_not_Entry,auto)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> Label\n                               l \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  while (b) prog \\<turnstile> Label\n                               l \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "have \"while (b) prog,procs \\<turnstile> (Main,Label l \\<oplus> 2) \n      -(\\<lambda>s. True):(Main,n' \\<oplus> 2)\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es\\<rightarrow> (p,Entry)\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  while (b) prog \\<turnstile> Label\n                               l \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n Label\n  l \\<oplus> 2) -\\<lambda>s.\n                    True:(Main,\n                          n' \\<oplus> 2)\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es\\<rightarrow> (p, Entry)", "by(fastforce intro:PCFG.MainCall)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     Label\nl \\<oplus> 2) -\\<lambda>s.\n                  True:(Main,\n                        n' \\<oplus> 2)\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                   interpret es\\<rightarrow> (p, Entry)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 6. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     Label\nl \\<oplus> 2) -\\<lambda>s.\n                  True:(Main,\n                        n' \\<oplus> 2)\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                   interpret es\\<rightarrow> (p, Entry)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (ProcCall p ins outs c l p' es' rets' l' ins' outs' c')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(p, Label l) = sourcenode a\\<close>[THEN sym]\n      \\<open>(p', Entry) = targetnode a\\<close>[THEN sym]  \\<open>well_formed procs\\<close>\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, Label l)\n  targetnode a = (p', Entry)\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 5. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (MainReturn l p es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p, Exit) = sourcenode a\\<close>[THEN sym]\n      \\<open>(Main, Label l') = targetnode a\\<close>[THEN sym] wf\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have [simp]:\"n = Label l'\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  sourcenode a = (p, Exit)\n  targetnode a = (Main, Label l')\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l'", "by fastforce"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"while (b) prog \\<turnstile> Label l \\<oplus> 2 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n      Label l' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> Label\n                                 l \\<oplus> 2 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 2", "by -(rule Proc_CFG_edge_WhileBody_source_not_Entry,auto)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> Label\n                               l \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 2\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  while (b) prog \\<turnstile> Label\n                               l \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 2", "have \"while (b) prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (Main,Label l' \\<oplus> 2))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label l' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  while (b) prog \\<turnstile> Label\n                               l \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p Label l' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (p,\n Exit) -\\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l' \\<oplus> 2)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=]\n                         map cf\n                          outs)\\<rightarrow> (Main, Label l' \\<oplus> 2)", "by(fastforce intro:PCFG.MainReturn)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n            snd cf =\n            (Main,\n             Label\n              l' \\<oplus> 2)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                          cf'. cf'(rets [:=]\n                          map cf\n                           outs)\\<rightarrow> (Main, Label l' \\<oplus> 2)\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 4. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  while (b) prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n            snd cf =\n            (Main,\n             Label\n              l' \\<oplus> 2)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                          cf'. cf'(rets [:=]\n                          map cf\n                           outs)\\<rightarrow> (Main, Label l' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (ProcReturn p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(p', Exit) = sourcenode a\\<close>[THEN sym] \n      \\<open>(p, Label l') = targetnode a\\<close>[THEN sym] \\<open>well_formed procs\\<close>\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p', Exit)\n  targetnode a = (p, Label l')\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 3. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (MainCallReturn nx p es rets nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, nx') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (2 subgoals):\n 1. \\<And>na p es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(Main,n) = sourcenode a \\<or> (Main,n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "assume \"(Main,n) = sourcenode a\""], ["proof (state)\nthis:\n  (Main, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a", "have [simp]:\"nx = n\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  (Main, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. nx = n", "by simp"], ["proof (state)\nthis:\n  nx = n\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"nx' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. nx' \\<noteq> Exit", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  nx' \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>n \\<noteq> Entry\\<close> \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx' \\<noteq> Exit", "have \"while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n        nx' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  n \\<noteq> Entry\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2", "by(fastforce intro:Proc_CFG_edge_WhileBody_source_not_Entry)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "hence \"while (b) prog,procs \\<turnstile> (Main,n \\<oplus> 2) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  while (b) prog \\<turnstile> n \\<oplus> 2 -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n n \\<oplus> 2) -(\\<lambda>s.\n                    False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 2)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (2 subgoals):\n 1. (Main, n) = sourcenode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n 2. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -(\\<lambda>s.\n                  False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "assume \"(Main, n) = targetnode a\""], ["proof (state)\nthis:\n  (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"nx \\<noteq> Entry\" and \"nx' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry &&& nx' \\<noteq> Exit", "by(auto dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n  nx' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n  nx' \\<noteq> Exit", "have \"while (b) prog \\<turnstile> nx \\<oplus> 2 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p \n        nx' \\<oplus> 2\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n  nx' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. while (b) prog \\<turnstile> nx \\<oplus> 2 -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2", "by(fastforce intro:Proc_CFG_edge_WhileBody_source_not_Entry)"], ["proof (state)\nthis:\n  while (b) prog \\<turnstile> nx \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "hence \"while (b) prog,procs \\<turnstile> (Main,nx \\<oplus> 2) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,nx' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  while (b) prog \\<turnstile> nx \\<oplus> 2 -CEdge\n        (p, es, rets)\\<rightarrow>\\<^sub>p nx' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n nx \\<oplus> 2) -(\\<lambda>s.\n                     False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                  nx' \\<oplus> 2)", "by -(rule PCFG.MainCallReturn)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 2) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. (Main, n) = targetnode a \\<Longrightarrow>\n    ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "with \\<open>(Main, n) = targetnode a\\<close> \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  while (b) prog,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 2) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, n) = targetnode a\n  targetnode a = (Main, nx')\n  while (b) prog,procs \\<turnstile> (Main,\n                                     nx \\<oplus> 2) -(\\<lambda>s.\n                   False)\\<^sub>\\<surd>\\<rightarrow> (Main, nx' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by(simp add:ProcCFG.valid_node_def)(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "case (ProcCallReturn p ins outs c nx p' es' rets' n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (p, n') = targetnode a\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n  n \\<noteq> Entry\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "from \\<open>(p, nx) = sourcenode a\\<close>[THEN sym] \\<open>(p, n') = targetnode a\\<close>[THEN sym]\n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>\n      \\<open>(Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = (p, nx)\n  targetnode a = (p, n')\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        (Main, n) = sourcenode a \\<or> (Main, n) = targetnode a;\n        n \\<noteq> Entry; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)", "by simp"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_Main_WhileBody:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" \n  and \"Rep_wf_prog wfp' = (while (b) prog,procs)\"\n  shows \"\\<lbrakk>wfp \\<turnstile> (Main,n) -as\\<rightarrow>* (p',n'); \\<forall>a \\<in> set as. intra_kind (kind a); \n    n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow> wfp' \\<turnstile> (Main,n \\<oplus> 2) -as \\<oplus>s 2\\<rightarrow>* (p',n' \\<oplus> 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, n) as (p', n');\n     \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n     n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                       (as \\<oplus>s 2) (p', n' \\<oplus> 2)", "proof(induct \"(Main,n)\" as \"(p',n')\" arbitrary:n rule:ProcCFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry;\n     n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> 2)\n                       ([] \\<oplus>s 2) (p', n' \\<oplus> 2)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "case empty_path"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp (Main, n')\n  Main = p'\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n  n' \\<noteq> Entry\n  n' \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry;\n     n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> 2)\n                       ([] \\<oplus>s 2) (p', n' \\<oplus> 2)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp) (Main, n')\\<close>\n    \\<open>n' \\<noteq> Entry\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>\n    \\<open>Rep_wf_prog wfp' = (while (b) prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (while (b) prog, procs)", "have \"CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (Main, n')\n  n' \\<noteq> Entry\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (while (b) prog, procs)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp' (Main, n' \\<oplus> 2)", "by(fastforce intro:valid_node_Main_WhileBody)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> 2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp (Main, n'); Main = p';\n     \\<forall>a\\<in>set []. intra_kind (kind a); n' \\<noteq> Entry;\n     n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp' (Main, n' \\<oplus> 2)\n                       ([] \\<oplus>s 2) (p', n' \\<oplus> 2)\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "with \\<open>Main = p'\\<close>"], ["proof (chain)\npicking this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> 2)", "show ?case"], ["proof (prove)\nusing this:\n  Main = p'\n  ProcCFG.valid_node wfp' (Main, n' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n' \\<oplus> 2) ([] \\<oplus>s 2)\n     (p', n' \\<oplus> 2)", "by(fastforce intro:ProcCFG.empty_path simp:label_incrs_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n' \\<oplus> 2) ([] \\<oplus>s 2)\n   (p', n' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "case (Cons_path n'' as a n)"], ["proof (state)\nthis:\n  ProcCFG.path wfp n'' as (p', n')\n  \\<lbrakk>n'' = (Main, ?n); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?n \\<oplus> 2) (as \\<oplus>s 2)\n                     (p', n' \\<oplus> 2)\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "note IH = \\<open>\\<And>n.  \\<lbrakk>n'' = (Main, n); \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry; \n    n' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow> wfp' \\<turnstile> (Main, n \\<oplus> 2) -as \\<oplus>s 2\\<rightarrow>* (p', n' \\<oplus> 2)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' = (Main, ?n); \\<forall>a\\<in>set as. intra_kind (kind a);\n   ?n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp' (Main, ?n \\<oplus> 2) (as \\<oplus>s 2)\n                     (p', n' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "note [simp] = \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n     \\<open>Rep_wf_prog wfp' = (while (b) prog,procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n  Rep_wf_prog wfp' = (while (b) prog, procs)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\"\n    and \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "from \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs", "obtain nx'' where \"n'' = (Main,nx'')\" and \"nx'' \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  intra_kind (kind a)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>nx''.\n        \\<lbrakk>n'' = (Main, nx''); nx'' \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  n'' = (Main, nx'')\n  nx'' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "from IH[OF \\<open>n'' = (Main,nx'')\\<close> \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close> \n    \\<open>nx'' \\<noteq> Entry\\<close> \\<open>n' \\<noteq> Exit\\<close>]"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)", "have path:\"wfp' \\<turnstile> (Main, nx'' \\<oplus> 2) -as \\<oplus>s 2\\<rightarrow>* (p', n' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n     (p', n' \\<oplus> 2)", "."], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "with \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  n' \\<noteq> Exit\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)", "have \"nx'' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  n' \\<noteq> Exit\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. nx'' \\<noteq> Exit", "by(fastforce dest:ProcCFGExit.path_Exit_source)"], ["proof (state)\nthis:\n  nx'' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "with \\<open>valid_edge wfp a\\<close> \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close>\n    \\<open>n'' = (Main,nx'')\\<close> \\<open>n \\<noteq> Entry\\<close> \\<open>intra_kind (kind a)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs\n  nx'' \\<noteq> Exit", "have \"while (b) prog,procs \\<turnstile> (Main, n \\<oplus> 2) -kind a\\<rightarrow> (Main, nx'' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  n \\<noteq> Entry\n  intra_kind (kind a)\n  well_formed procs\n  nx'' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. while (b) prog,procs \\<turnstile> (Main,\n n \\<oplus> 2) -kind a\\<rightarrow> (Main, nx'' \\<oplus> 2)", "by(fastforce intro:PCFG_Main_edge_WhileBody_source_not_Entry simp:valid_edge_def)"], ["proof (state)\nthis:\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp n'' as (p', n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a); n \\<noteq> Entry;\n            n' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                              (as \\<oplus>s 2) (p', n' \\<oplus> 2);\n        valid_edge wfp a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a); n \\<noteq> Entry;\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "with path \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' = (Main,nx'')\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> 2)", "show ?case"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)\n  sourcenode a = (Main, n)\n  targetnode a = n''\n  n'' = (Main, nx'')\n  while (b) prog,procs \\<turnstile> (Main,\n                                     n \\<oplus> 2) -kind\n               a\\<rightarrow> (Main, nx'' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, n \\<oplus> 2) (a # as \\<oplus>s 2)\n     (p', n' \\<oplus> 2)", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba c d.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> 2) (as \\<oplus>s 2)\n                 (p', n' \\<oplus> 2);\n        sourcenode a = (Main, n); targetnode a = n''; n'' = (Main, nx'');\n        while (b) prog,procs \\<turnstile> (Main,\n     n \\<oplus> 2) -kind a\\<rightarrow> (Main, nx'' \\<oplus> 2);\n        a = (aa, ba, c, d)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (a # as \\<oplus>s 2) (p', n' \\<oplus> 2)", "apply(clarsimp simp:label_incrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>ProcCFG.path wfp' (Main, nx'' \\<oplus> 2)\n                 (map (\\<lambda>((p, n), et, p', n').\n                          ((p, n \\<oplus> 2), et, p', n' \\<oplus> 2))\n                   as)\n                 (p', n' \\<oplus> 2);\n        n'' = (Main, nx'');\n        while (b) prog,procs \\<turnstile> (Main,\n     n \\<oplus> 2) -ba\\<rightarrow> (Main, nx'' \\<oplus> 2);\n        a = ((Main, n), ba, Main, nx'')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp' (Main, n \\<oplus> 2)\n                          (((Main, n \\<oplus> 2), ba, Main,\n                            nx'' \\<oplus> 2) #\n                           map (\\<lambda>((p, n), et, p', n').\n                                   ((p, n \\<oplus> 2), et, p',\n                                    n' \\<oplus> 2))\n                            as)\n                          (p', n' \\<oplus> 2)", "by(auto intro:ProcCFG.Cons_path simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, n \\<oplus> 2) (a # as \\<oplus>s 2)\n   (p', n' \\<oplus> 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Existence of intraprodecural paths\\<close>"], ["", "lemma Label_Proc_CFG_Entry_Exit_path_Main:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"l < #:prog\"\n  obtains as as' where \"wfp \\<turnstile> (Main,Label l) -as\\<rightarrow>* (Main,Exit)\"\n  and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n  and \"wfp \\<turnstile> (Main,Entry) -as'\\<rightarrow>* (Main,Label l)\"\n  and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (Main, Label l) as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (Main, Entry) as' (Main, Label l);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>l < #:prog\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  l < #:prog\n  Rep_wf_prog wfp = (prog, procs)", "show \"\\<exists>as as'. wfp \\<turnstile> (Main, Label l) -as\\<rightarrow>* (Main, Exit) \\<and>\n    (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n    wfp \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l) \\<and> (\\<forall>a\\<in>set as'. intra_kind (kind a))\""], ["proof (prove)\nusing this:\n  l < #:prog\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof(induct prog arbitrary:l wfp)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l wfp.\n       \\<lbrakk>l < #:Skip; Rep_wf_prog wfp = (Skip, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 6. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case Skip"], ["proof (state)\nthis:\n  l < #:Skip\n  Rep_wf_prog wfp = (Skip, procs)\n\ngoal (6 subgoals):\n 1. \\<And>l wfp.\n       \\<lbrakk>l < #:Skip; Rep_wf_prog wfp = (Skip, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 6. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note [simp] = \\<open>Rep_wf_prog wfp = (Skip, procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (Skip, procs)\n\ngoal (6 subgoals):\n 1. \\<And>l wfp.\n       \\<lbrakk>l < #:Skip; Rep_wf_prog wfp = (Skip, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 6. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>l < #:Skip\\<close>"], ["proof (chain)\npicking this:\n  l < #:Skip", "have [simp]:\"l = 0\""], ["proof (prove)\nusing this:\n  l < #:Skip\n\ngoal (1 subgoal):\n 1. l = 0", "by simp"], ["proof (state)\nthis:\n  l = 0\n\ngoal (6 subgoals):\n 1. \\<And>l wfp.\n       \\<lbrakk>l < #:Skip; Rep_wf_prog wfp = (Skip, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 6. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Entry) -[((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))]\\<rightarrow>* \n      (Main,Label 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n     (Main, Label 0)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_Entry\n                   simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (6 subgoals):\n 1. \\<And>l wfp.\n       \\<lbrakk>l < #:Skip; Rep_wf_prog wfp = (Skip, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 6. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (6 subgoals):\n 1. \\<And>l wfp.\n       \\<lbrakk>l < #:Skip; Rep_wf_prog wfp = (Skip, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 6. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Label l) -[((Main,Label l),\\<Up>id,(Main,Exit))]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l)\n     [((Main, Label l), \\<Up>id, Main, Exit)] (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_Skip simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l) [((Main, Label l), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (6 subgoals):\n 1. \\<And>l wfp.\n       \\<lbrakk>l < #:Skip; Rep_wf_prog wfp = (Skip, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 6. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n  ProcCFG.path wfp (Main, Label l) [((Main, Label l), \\<Up>id, Main, Exit)]\n   (Main, Exit)", "show ?case"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n  ProcCFG.path wfp (Main, Label l) [((Main, Label l), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case (LAss V e)"], ["proof (state)\nthis:\n  l < #:V:=e\n  Rep_wf_prog wfp = (V:=e, procs)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note [simp] = \\<open>Rep_wf_prog wfp = (V:=e, procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (V:=e, procs)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>l < #:V:=e\\<close>"], ["proof (chain)\npicking this:\n  l < #:V:=e", "have \"l = 0 \\<or> l = 1\""], ["proof (prove)\nusing this:\n  l < #:V:=e\n\ngoal (1 subgoal):\n 1. l = 0 \\<or> l = 1", "by auto"], ["proof (state)\nthis:\n  l = 0 \\<or> l = 1\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 l wfp.\n       \\<lbrakk>l < #:x1:=x2; Rep_wf_prog wfp = (x1:=x2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 5. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "thus ?case"], ["proof (prove)\nusing this:\n  l = 0 \\<or> l = 1\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "assume [simp]:\"l = 0\""], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Entry) -[((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))]\\<rightarrow>*\n        (Main,Label 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n     (Main, Label 0)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_Entry\n                    simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Label 0) \n        -((Main,Label 0),\\<Up>(\\<lambda>cf. update cf V e),(Main,Label 1))#\n        [((Main,Label 1),\\<Up>id,(Main,Exit))]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label 0)\n     [((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1),\n      ((Main, Label 1), \\<Up>id, Main, Exit)]\n     (Main, Exit)", "by(fastforce intro:ProcCFG.Cons_path ProcCFG.path.intros Main Proc_CFG_LAss \n          Proc_CFG_LAssSkip simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "assume [simp]:\"l = 1\""], ["proof (state)\nthis:\n  l = 1\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Entry) -((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))#\n        [((Main,Label 0),\\<Up>(\\<lambda>cf. update cf V e),(Main,Label 1))]\\<rightarrow>* (Main,Label 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n      ((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1)]\n     (Main, Label 1)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_LAss ProcCFG.Cons_path \n          Main Proc_CFG_Entry simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1)]\n   (Main, Label 1)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1)]\n   (Main, Label 1)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Label 1) -[((Main,Label 1),\\<Up>id,(Main,Exit))]\\<rightarrow>* \n        (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label 1)\n     [((Main, Label 1), \\<Up>id, Main, Exit)] (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros  Main Proc_CFG_LAssSkip\n        simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. l = 1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1)]\n   (Main, Label 1)\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), \\<Up>\\<lambda>cf. update cf V e, Main, Label 1)]\n   (Main, Label 1)\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case (Seq c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c\\<^sub>1; Rep_wf_prog ?wfp = (c\\<^sub>1, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n  \\<lbrakk>?l < #:c\\<^sub>2; Rep_wf_prog ?wfp = (c\\<^sub>2, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n  l < #:c\\<^sub>1;; c\\<^sub>2\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note IH1 = \\<open>\\<And>l wfp. \\<lbrakk>l < #:c\\<^sub>1; Rep_wf_prog wfp = (c\\<^sub>1, procs)\\<rbrakk> \\<Longrightarrow>\n      \\<exists>as as'. wfp \\<turnstile> (Main, Label l) -as\\<rightarrow>* (Main, Exit) \\<and> \n      (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n      wfp \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l) \\<and> (\\<forall>a\\<in>set as'. intra_kind (kind a))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c\\<^sub>1; Rep_wf_prog ?wfp = (c\\<^sub>1, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note IH2 = \\<open>\\<And>l wfp. \\<lbrakk>l < #:c\\<^sub>2; Rep_wf_prog wfp = (c\\<^sub>2, procs)\\<rbrakk> \\<Longrightarrow>\n      \\<exists>as as'. wfp \\<turnstile> (Main, Label l) -as\\<rightarrow>* (Main, Exit) \\<and> \n      (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n      wfp \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l) \\<and> (\\<forall>a\\<in>set as'. intra_kind (kind a))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c\\<^sub>2; Rep_wf_prog ?wfp = (c\\<^sub>2, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note [simp] = \\<open>Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:prog1;; prog2;\n        Rep_wf_prog wfp = (prog1;; prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 4. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof(cases \"l < #:c\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case True"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)", "obtain wfp' where [simp]:\"Rep_wf_prog wfp' = (c\\<^sub>1, procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_Seq1)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp' = (c\\<^sub>1, procs)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH1[OF True this]"], ["proof (chain)\npicking this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain as as' \n        where path1:\"wfp' \\<turnstile> (Main, Label l) -as\\<rightarrow>* (Main, Exit)\"\n        and intra1:\"\\<forall>a\\<in>set as. intra_kind (kind a)\"\n        and path2:\"wfp' \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l)\"\n        and intra2:\"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp' (Main, Label l) as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp' (Main, Entry) as' (Main, Label l);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "by(fastforce elim:ProcCFG.path.cases)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "then"], ["proof (chain)\npicking this:\n  as \\<noteq> []", "obtain ax asx where [simp]:\"as = asx@[ax]\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax.\n        as = asx @ [ax] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases as rule:rev_cases) fastforce+"], ["proof (state)\nthis:\n  as = asx @ [ax]\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with path1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)\n  as = asx @ [ax]", "have \"wfp' \\<turnstile> (Main, Label l) -asx\\<rightarrow>* sourcenode ax\"\n        and \"valid_edge wfp' ax\" and \"targetnode ax = (Main, Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)\n  as = asx @ [ax]\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp' (Main, Label l) asx (sourcenode ax) &&&\n    valid_edge wfp' ax &&& targetnode ax = (Main, Exit)", "by(auto elim:ProcCFG.path_split_snoc)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, Label l) asx (sourcenode ax)\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>valid_edge wfp' ax\\<close> \\<open>targetnode ax = (Main, Exit)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)", "obtain nx where \"sourcenode ax = (Main,nx)\""], ["proof (prove)\nusing this:\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        sourcenode ax = (Main, nx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  sourcenode ax = (Main, nx)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp' \\<turnstile> (Main, Label l) -asx\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l) asx (sourcenode ax)\n  sourcenode ax = (Main, nx)", "have \"nx \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l) asx (sourcenode ax)\n  sourcenode ax = (Main, nx)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry", "by fastforce"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>valid_edge wfp' ax\\<close> \\<open>sourcenode ax = (Main,nx)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp' ax\n  sourcenode ax = (Main, nx)", "have \"nx \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  valid_edge wfp' ax\n  sourcenode ax = (Main, nx)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Exit", "by(fastforce intro:ProcCFGExit.Exit_source)"], ["proof (state)\nthis:\n  nx \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  nx \\<noteq> Entry\n  nx \\<noteq> Exit", "obtain lx where [simp]:\"nx = Label lx\""], ["proof (prove)\nusing this:\n  nx \\<noteq> Entry\n  nx \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>lx. nx = Label lx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases nx) auto"], ["proof (state)\nthis:\n  nx = Label lx\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp' \\<turnstile> (Main, Label l) -asx\\<rightarrow>* sourcenode ax\\<close> \n        \\<open>sourcenode ax = (Main,nx)\\<close> intra1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l) asx (sourcenode ax)\n  sourcenode ax = (Main, nx)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  nx = Label lx", "have path3:\"wfp \\<turnstile> (Main, Label l) -asx\\<rightarrow>* (Main, Label lx)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l) asx (sourcenode ax)\n  sourcenode ax = (Main, nx)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  nx = Label lx\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l) asx (Main, Label lx)", "by -(rule path_SeqFirst,auto)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l) asx (Main, Label lx)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>valid_edge wfp' ax\\<close> \\<open>targetnode ax = (Main, Exit)\\<close>\n        \\<open>sourcenode ax = (Main,nx)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)\n  sourcenode ax = (Main, nx)\n  well_formed procs", "obtain etx where \"c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\nusing this:\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)\n  sourcenode ax = (Main, nx)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>etx.\n        c\\<^sub>1 \\<turnstile> Label\n                                lx -etx\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit", "obtain et where [simp]:\"etx = IEdge et\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. (\\<And>et. etx = IEdge et \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases etx)(auto dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  etx = IEdge et\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\n  etx = IEdge et", "have \"intra_kind et\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\n  etx = IEdge et\n\ngoal (1 subgoal):\n 1. intra_kind et", "by(fastforce intro:Proc_CFG_IEdge_intra_kind)"], ["proof (state)\nthis:\n  intra_kind et\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\\<close> path3"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\n  ProcCFG.path wfp (Main, Label l) asx (Main, Label lx)", "have path4:\"wfp \\<turnstile> (Main, Label l) -asx@\n        [((Main, Label lx),et,(Main,Label 0 \\<oplus> #:c\\<^sub>1))] \\<rightarrow>* (Main,Label 0 \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label lx -etx\\<rightarrow>\\<^sub>p Exit\n  ProcCFG.path wfp (Main, Label l) asx (Main, Label lx)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l)\n     (asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)])\n     (Main, Label 0 \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:ProcCFG.path_Append ProcCFG.path.intros Proc_CFG_SeqConnect\n          Main simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l)\n   (asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)])\n   (Main, Label 0 \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)", "obtain wfp'' where [simp]:\"Rep_wf_prog wfp'' = (c\\<^sub>2, procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp''.\n        Rep_wf_prog wfp'' = (c\\<^sub>2, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_Seq2)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp'' = (c\\<^sub>2, procs)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH2[OF _ this,of \"0\"]"], ["proof (chain)\npicking this:\n  0 < #:c\\<^sub>2 \\<Longrightarrow>\n  \\<exists>as as'.\n     ProcCFG.path wfp'' (Main, Label 0) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp'' (Main, Entry) as' (Main, Label 0) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain asx' \n        where \"wfp'' \\<turnstile> (Main, Label 0) -asx'\\<rightarrow>* (Main, Exit)\"\n        and \"\\<forall>a\\<in>set asx'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  0 < #:c\\<^sub>2 \\<Longrightarrow>\n  \\<exists>as as'.\n     ProcCFG.path wfp'' (Main, Label 0) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp'' (Main, Entry) as' (Main, Label 0) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) asx' (Main, Exit);\n         \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp'' (Main, Label 0) asx' (Main, Exit)\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with path4 intra1 \\<open>intra_kind et\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l)\n   (asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)])\n   (Main, Label 0 \\<oplus> #:c\\<^sub>1)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  intra_kind et\n  ProcCFG.path wfp'' (Main, Label 0) asx' (Main, Exit)\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)", "have \"wfp \\<turnstile> (Main, Label l) \n        -(asx@[((Main, Label lx),et,(Main,Label 0 \\<oplus> #:c\\<^sub>1))])@(asx' \\<oplus>s #:c\\<^sub>1)\\<rightarrow>*\n        (Main, Exit \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l)\n   (asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)])\n   (Main, Label 0 \\<oplus> #:c\\<^sub>1)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  intra_kind et\n  ProcCFG.path wfp'' (Main, Label 0) asx' (Main, Exit)\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l)\n     ((asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)]) @\n      (asx' \\<oplus>s #:c\\<^sub>1))\n     (Main, Exit \\<oplus> #:c\\<^sub>1)", "by -(erule ProcCFG.path_Append,rule path_Main_SeqSecond,auto)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Exit \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Exit \\<oplus> #:c\\<^sub>1)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from intra1 \\<open>intra_kind et\\<close> \\<open>\\<forall>a\\<in>set asx'. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  intra_kind et\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)", "have \"\\<forall>a \\<in> set ((asx@[((Main, Label lx),et,(Main,Label #:c\\<^sub>1))])@(asx' \\<oplus>s #:c\\<^sub>1)).\n        intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  intra_kind et\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ((asx @\n                         [((Main, Label lx), et, Main,\n                           Label #:c\\<^sub>1)]) @\n                        (asx' \\<oplus>s #:c\\<^sub>1)).\n       intra_kind (kind a)", "by(auto simp:label_incrs_def)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ((asx @\n                       [((Main, Label lx), et, Main, Label #:c\\<^sub>1)]) @\n                      (asx' \\<oplus>s #:c\\<^sub>1)).\n     intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ((asx @\n                       [((Main, Label lx), et, Main, Label #:c\\<^sub>1)]) @\n                      (asx' \\<oplus>s #:c\\<^sub>1)).\n     intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path2 intra2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)", "have \"wfp \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry) as' (Main, Label l)", "by -(rule path_SeqFirst,auto)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l)\n\ngoal (2 subgoals):\n 1. l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Exit \\<oplus> #:c\\<^sub>1)\n  \\<forall>a\\<in>set ((asx @\n                       [((Main, Label lx), et, Main, Label #:c\\<^sub>1)]) @\n                      (asx' \\<oplus>s #:c\\<^sub>1)).\n     intra_kind (kind a)\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Exit \\<oplus> #:c\\<^sub>1)\n  \\<forall>a\\<in>set ((asx @\n                       [((Main, Label lx), et, Main, Label #:c\\<^sub>1)]) @\n                      (asx' \\<oplus>s #:c\\<^sub>1)).\n     intra_kind (kind a)\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using \\<open>\\<forall>a\\<in>set as'. intra_kind (kind a)\\<close>"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx @ [((Main, Label lx), et, Main, Label 0 \\<oplus> #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Exit \\<oplus> #:c\\<^sub>1)\n  \\<forall>a\\<in>set ((asx @\n                       [((Main, Label lx), et, Main, Label #:c\\<^sub>1)]) @\n                      (asx' \\<oplus>s #:c\\<^sub>1)).\n     intra_kind (kind a)\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case False"], ["proof (state)\nthis:\n  \\<not> l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"#:c\\<^sub>1 \\<le> l\""], ["proof (prove)\nusing this:\n  \\<not> l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 \\<le> l", "by simp"], ["proof (state)\nthis:\n  #:c\\<^sub>1 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "then"], ["proof (chain)\npicking this:\n  #:c\\<^sub>1 \\<le> l", "obtain l' where [simp]:\"l = l' + #:c\\<^sub>1\" and \"l' = l - #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  #:c\\<^sub>1 \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l = l' + #:c\\<^sub>1; l' = l - #:c\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  l = l' + #:c\\<^sub>1\n  l' = l - #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>l < #:c\\<^sub>1;; c\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  l < #:c\\<^sub>1;; c\\<^sub>2", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  l < #:c\\<^sub>1;; c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)", "obtain wfp' where [simp]:\"Rep_wf_prog wfp' = (c\\<^sub>2, procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_Seq2)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp' = (c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH2[OF \\<open>l' < #:c\\<^sub>2\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain as as' \n        where path1:\"wfp' \\<turnstile> (Main, Label l') -as\\<rightarrow>* (Main, Exit)\"\n        and intra1:\"\\<forall>a\\<in>set as. intra_kind (kind a)\"\n        and path2:\"wfp' \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l')\"\n        and intra2:\"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp' (Main, Label l') as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp' (Main, Entry) as' (Main, Label l');\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path1 intra1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"wfp \\<turnstile> (Main, Label l' \\<oplus> #:c\\<^sub>1) -as \\<oplus>s #:c\\<^sub>1\\<rightarrow>* (Main, Exit \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l' \\<oplus> #:c\\<^sub>1)\n     (as \\<oplus>s #:c\\<^sub>1) (Main, Exit \\<oplus> #:c\\<^sub>1)", "by -(rule path_Main_SeqSecond,auto)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (Main, Exit \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (Main, Exit \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')", "have \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> []", "by(fastforce elim:ProcCFG.path.cases)"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with path2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n  as' \\<noteq> []", "obtain ax' asx' where [simp]:\"as' = ax'#asx'\"\n        and \"sourcenode ax' = (Main, Entry)\" and \"valid_edge wfp' ax'\" \n        and \"wfp' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main, Label l')\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ax' asx'.\n        \\<lbrakk>as' = ax' # asx'; sourcenode ax' = (Main, Entry);\n         valid_edge wfp' ax';\n         ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule ProcCFG.path_split_Cons,fastforce+)"], ["proof (state)\nthis:\n  as' = ax' # asx'\n  sourcenode ax' = (Main, Entry)\n  valid_edge wfp' ax'\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>wfp' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main, Label l')\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')", "have \"targetnode ax' \\<noteq> (Main,Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n\ngoal (1 subgoal):\n 1. targetnode ax' \\<noteq> (Main, Exit)", "by fastforce"], ["proof (state)\nthis:\n  targetnode ax' \\<noteq> (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>valid_edge wfp' ax'\\<close> \\<open>sourcenode ax' = (Main, Entry)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp' ax'\n  sourcenode ax' = (Main, Entry)\n  well_formed procs\n  targetnode ax' \\<noteq> (Main, Exit)", "have \"targetnode ax' = (Main,Label 0)\""], ["proof (prove)\nusing this:\n  valid_edge wfp' ax'\n  sourcenode ax' = (Main, Entry)\n  well_formed procs\n  targetnode ax' \\<noteq> (Main, Exit)\n\ngoal (1 subgoal):\n 1. targetnode ax' = (Main, Label 0)", "by(fastforce elim:PCFG.cases dest:Proc_CFG_EntryD simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode ax' = (Main, Label 0)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main, Label l')\\<close> intra2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)", "have path3:\"wfp \\<turnstile> (Main,Label 0 \\<oplus> #:c\\<^sub>1) -asx' \\<oplus>s #:c\\<^sub>1\\<rightarrow>* \n        (Main, Label l' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label 0 \\<oplus> #:c\\<^sub>1)\n     (asx' \\<oplus>s #:c\\<^sub>1) (Main, Label l' \\<oplus> #:c\\<^sub>1)", "by -(rule path_Main_SeqSecond,auto)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 0 \\<oplus> #:c\\<^sub>1)\n   (asx' \\<oplus>s #:c\\<^sub>1) (Main, Label l' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)", "obtain wfp'' where [simp]:\"Rep_wf_prog wfp'' = (c\\<^sub>1, procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp''.\n        Rep_wf_prog wfp'' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_Seq1)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp'' = (c\\<^sub>1, procs)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH1[OF _ this,of \"0\"]"], ["proof (chain)\npicking this:\n  0 < #:c\\<^sub>1 \\<Longrightarrow>\n  \\<exists>as as'.\n     ProcCFG.path wfp'' (Main, Label 0) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp'' (Main, Entry) as' (Main, Label 0) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain xs \n        where \"wfp'' \\<turnstile> (Main, Label 0) -xs\\<rightarrow>* (Main, Exit)\"\n        and \"\\<forall>a\\<in>set xs. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  0 < #:c\\<^sub>1 \\<Longrightarrow>\n  \\<exists>as as'.\n     ProcCFG.path wfp'' (Main, Label 0) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp'' (Main, Entry) as' (Main, Label 0) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) xs (Main, Exit);\n         \\<forall>a\\<in>set xs. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp'' (Main, Label 0) xs (Main, Exit)\n  \\<forall>a\\<in>set xs. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>wfp'' \\<turnstile> (Main, Label 0) -xs\\<rightarrow>* (Main, Exit)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp'' (Main, Label 0) xs (Main, Exit)", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp'' (Main, Label 0) xs (Main, Exit)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by(fastforce elim:ProcCFG.path.cases)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain x xs' where [simp]:\"xs = xs'@[x]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>xs' x. xs = xs' @ [x] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs rule:rev_cases) fastforce+"], ["proof (state)\nthis:\n  xs = xs' @ [x]\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp'' \\<turnstile> (Main, Label 0) -xs\\<rightarrow>* (Main, Exit)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp'' (Main, Label 0) xs (Main, Exit)\n  xs = xs' @ [x]", "have \"wfp'' \\<turnstile> (Main, Label 0) -xs'\\<rightarrow>* sourcenode x\"\n        and \"valid_edge wfp'' x\" and \"targetnode x = (Main, Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp'' (Main, Label 0) xs (Main, Exit)\n  xs = xs' @ [x]\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp'' (Main, Label 0) xs' (sourcenode x) &&&\n    valid_edge wfp'' x &&& targetnode x = (Main, Exit)", "by(auto elim:ProcCFG.path_split_snoc)"], ["proof (state)\nthis:\n  ProcCFG.path wfp'' (Main, Label 0) xs' (sourcenode x)\n  valid_edge wfp'' x\n  targetnode x = (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>valid_edge wfp'' x\\<close> \\<open>targetnode x = (Main, Exit)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp'' x\n  targetnode x = (Main, Exit)", "obtain nx where \"sourcenode x = (Main,nx)\""], ["proof (prove)\nusing this:\n  valid_edge wfp'' x\n  targetnode x = (Main, Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        sourcenode x = (Main, nx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  sourcenode x = (Main, nx)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp'' \\<turnstile> (Main, Label 0) -xs'\\<rightarrow>* sourcenode x\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp'' (Main, Label 0) xs' (sourcenode x)\n  sourcenode x = (Main, nx)", "have \"nx \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp'' (Main, Label 0) xs' (sourcenode x)\n  sourcenode x = (Main, nx)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Entry", "by fastforce"], ["proof (state)\nthis:\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>valid_edge wfp'' x\\<close> \\<open>sourcenode x = (Main,nx)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp'' x\n  sourcenode x = (Main, nx)", "have \"nx \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  valid_edge wfp'' x\n  sourcenode x = (Main, nx)\n\ngoal (1 subgoal):\n 1. nx \\<noteq> Exit", "by(fastforce intro:ProcCFGExit.Exit_source)"], ["proof (state)\nthis:\n  nx \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>nx \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  nx \\<noteq> Entry\n  nx \\<noteq> Exit", "obtain lx where [simp]:\"nx = Label lx\""], ["proof (prove)\nusing this:\n  nx \\<noteq> Entry\n  nx \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>lx. nx = Label lx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases nx) auto"], ["proof (state)\nthis:\n  nx = Label lx\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>wfp'' \\<turnstile> (Main, Label 0) -xs'\\<rightarrow>* sourcenode x\\<close> \n        \\<open>sourcenode x = (Main,nx)\\<close> \\<open>\\<forall>a\\<in>set xs. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp'' (Main, Label 0) xs' (sourcenode x)\n  sourcenode x = (Main, nx)\n  \\<forall>a\\<in>set xs. intra_kind (kind a)", "have \"wfp \\<turnstile> (Main, Entry) \n        -((Main, Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main, Label 0))#xs'\\<rightarrow>* sourcenode x\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp'' (Main, Label 0) xs' (sourcenode x)\n  sourcenode x = (Main, nx)\n  \\<forall>a\\<in>set xs. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      xs')\n     (sourcenode x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) xs' (Main, Label lx);\n     sourcenode x = (Main, Label lx);\n     intra_kind (kind x) \\<and>\n     (\\<forall>a\\<in>set xs'. intra_kind (kind a))\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (Main, Entry)\n                       (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                         Main, Label 0) #\n                        xs')\n                       (Main, Label lx)", "apply(rule path_SeqFirst[OF \\<open>Rep_wf_prog wfp'' = (c\\<^sub>1, procs)\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) xs' (Main, Label lx);\n     sourcenode x = (Main, Label lx);\n     intra_kind (kind x) \\<and>\n     (\\<forall>a\\<in>set xs'. intra_kind (kind a))\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog wfp = (c\\<^sub>1;; ?c\\<^sub>29, procs)\n 2. \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) xs' (Main, Label lx);\n     sourcenode x = (Main, Label lx);\n     intra_kind (kind x) \\<and>\n     (\\<forall>a\\<in>set xs'. intra_kind (kind a))\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp'' (Main, Entry)\n                       (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                         Main, Label 0) #\n                        xs')\n                       (Main, Label lx)\n 3. \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) xs' (Main, Label lx);\n     sourcenode x = (Main, Label lx);\n     intra_kind (kind x) \\<and>\n     (\\<forall>a\\<in>set xs'. intra_kind (kind a))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set\n(((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) # xs').\n                         intra_kind (kind a)", "apply(auto intro!:ProcCFG.Cons_path)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) xs' (Main, Label lx);\n     sourcenode x = (Main, Label lx); intra_kind (kind x);\n     \\<forall>a\\<in>set xs'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp''\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0)\n 2. \\<lbrakk>ProcCFG.path wfp'' (Main, Label 0) xs' (Main, Label lx);\n     sourcenode x = (Main, Label lx); intra_kind (kind x);\n     \\<forall>a\\<in>set xs'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> intra_kind (\\<lambda>s. True)\\<^sub>\\<surd>", "by(auto intro:Main Proc_CFG_Entry simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) # xs')\n   (sourcenode x)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>valid_edge wfp'' x\\<close> \\<open>targetnode x = (Main, Exit)\\<close> path3\n        \\<open>sourcenode x = (Main,nx)\\<close> \\<open>nx \\<noteq> Entry\\<close> \\<open>sourcenode x = (Main,nx)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp'' x\n  targetnode x = (Main, Exit)\n  ProcCFG.path wfp (Main, Label 0 \\<oplus> #:c\\<^sub>1)\n   (asx' \\<oplus>s #:c\\<^sub>1) (Main, Label l' \\<oplus> #:c\\<^sub>1)\n  sourcenode x = (Main, nx)\n  nx \\<noteq> Entry\n  sourcenode x = (Main, nx)\n  well_formed procs\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) # xs')\n   (sourcenode x)", "have \"wfp \\<turnstile> (Main, Entry) -((((Main, Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main, Label 0))#xs')@\n        [(sourcenode x,kind x,(Main,Label #:c\\<^sub>1))])@(asx' \\<oplus>s #:c\\<^sub>1)\\<rightarrow>* \n        (Main, Label l' \\<oplus> #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  valid_edge wfp'' x\n  targetnode x = (Main, Exit)\n  ProcCFG.path wfp (Main, Label 0 \\<oplus> #:c\\<^sub>1)\n   (asx' \\<oplus>s #:c\\<^sub>1) (Main, Label l' \\<oplus> #:c\\<^sub>1)\n  sourcenode x = (Main, nx)\n  nx \\<noteq> Entry\n  sourcenode x = (Main, nx)\n  well_formed procs\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) # xs')\n   (sourcenode x)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     (((((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n        xs') @\n       [(sourcenode x, kind x, Main, Label #:c\\<^sub>1)]) @\n      (asx' \\<oplus>s #:c\\<^sub>1))\n     (Main, Label l' \\<oplus> #:c\\<^sub>1)", "by(fastforce intro:ProcCFG.path_Append ProcCFG.path.intros Main \n          Proc_CFG_SeqConnect elim!:PCFG.cases dest:Proc_CFG_Call_Labels\n          simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   (((((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      xs') @\n     [(sourcenode x, kind x, Main, Label #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Label l' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> l < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (Main, Exit \\<oplus> #:c\\<^sub>1)\n  ProcCFG.path wfp (Main, Entry)\n   (((((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      xs') @\n     [(sourcenode x, kind x, Main, Label #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Label l' \\<oplus> #:c\\<^sub>1)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (Main, Exit \\<oplus> #:c\\<^sub>1)\n  ProcCFG.path wfp (Main, Entry)\n   (((((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      xs') @\n     [(sourcenode x, kind x, Main, Label #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Label l' \\<oplus> #:c\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using intra1 intra2 \\<open>\\<forall>a\\<in>set xs. intra_kind (kind a)\\<close>"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> #:c\\<^sub>1)\n   (as \\<oplus>s #:c\\<^sub>1) (Main, Exit \\<oplus> #:c\\<^sub>1)\n  ProcCFG.path wfp (Main, Entry)\n   (((((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      xs') @\n     [(sourcenode x, kind x, Main, Label #:c\\<^sub>1)]) @\n    (asx' \\<oplus>s #:c\\<^sub>1))\n   (Main, Label l' \\<oplus> #:c\\<^sub>1)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  \\<forall>a\\<in>set xs. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:label_incrs_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case (Cond b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c\\<^sub>1; Rep_wf_prog ?wfp = (c\\<^sub>1, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n  \\<lbrakk>?l < #:c\\<^sub>2; Rep_wf_prog ?wfp = (c\\<^sub>2, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n  l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note IH1 = \\<open>\\<And>l wfp. \\<lbrakk>l < #:c\\<^sub>1; Rep_wf_prog wfp = (c\\<^sub>1, procs)\\<rbrakk> \\<Longrightarrow>\n      \\<exists>as as'. wfp \\<turnstile> (Main, Label l) -as\\<rightarrow>* (Main, Exit) \\<and> \n      (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n      wfp \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l) \\<and> (\\<forall>a\\<in>set as'. intra_kind (kind a))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c\\<^sub>1; Rep_wf_prog ?wfp = (c\\<^sub>1, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note IH2 = \\<open>\\<And>l wfp. \\<lbrakk>l < #:c\\<^sub>2; Rep_wf_prog wfp = (c\\<^sub>2, procs)\\<rbrakk> \\<Longrightarrow>\n      \\<exists>as as'. wfp \\<turnstile> (Main, Label l) -as\\<rightarrow>* (Main, Exit) \\<and> \n      (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n      wfp \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l) \\<and> (\\<forall>a\\<in>set as'. intra_kind (kind a))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c\\<^sub>2; Rep_wf_prog ?wfp = (c\\<^sub>2, procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note [simp] = \\<open>Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2 l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog1;\n                    Rep_wf_prog wfp = (prog1, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        \\<And>l wfp.\n           \\<lbrakk>l < #:prog2; Rep_wf_prog wfp = (prog2, procs)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>as as'.\n                                ProcCFG.path wfp (Main, Label l) as\n                                 (Main, Exit) \\<and>\n                                (\\<forall>a\\<in>set as.\n                                    intra_kind (kind a)) \\<and>\n                                ProcCFG.path wfp (Main, Entry) as'\n                                 (Main, Label l) \\<and>\n                                (\\<forall>a\\<in>set as'.\n                                    intra_kind (kind a));\n        l < #:if (x1) prog1 else prog2;\n        Rep_wf_prog wfp = (if (x1) prog1 else prog2, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 3. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof(cases \"l = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case True"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)", "obtain wfp' where [simp]:\"Rep_wf_prog wfp' = (c\\<^sub>1, procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_CondTrue)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp' = (c\\<^sub>1, procs)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH1[OF _ this,of 0]"], ["proof (chain)\npicking this:\n  0 < #:c\\<^sub>1 \\<Longrightarrow>\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label 0) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label 0) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain as \n        where path:\"wfp' \\<turnstile> (Main, Label 0) -as\\<rightarrow>* (Main, Exit)\"\n        and intra:\"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  0 < #:c\\<^sub>1 \\<Longrightarrow>\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label 0) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label 0) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, Label 0) as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"if (b) c\\<^sub>1 else c\\<^sub>2,procs \\<turnstile> (Main,Label 0)\n        -(\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main,Label 0 \\<oplus> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n Label\n  0) -(\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0 \\<oplus> 1)", "by(fastforce intro:Main Proc_CFG_CondTrue)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0 \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with path intra"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label 0) as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  if (b) c\\<^sub>1\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0 \\<oplus> 1)", "have \"wfp \\<turnstile> (Main,Label 0)\n        -[((Main,Label 0),(\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>,(Main,Label 0 \\<oplus> 1))]@\n        (as \\<oplus>s 1)\\<rightarrow>* (Main,Exit \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label 0) as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  if (b) c\\<^sub>1\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Label\n0) -(\\<lambda>cf.\n        state_check cf b\n         (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0 \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label 0)\n     ([((Main, Label 0),\n        (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n        Label 0 \\<oplus> 1)] @\n      (as \\<oplus>s 1))\n     (Main, Exit \\<oplus> 1)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (Main, Label 0)\n                       ([((Main, Label 0),\n                          (\\<lambda>cf.\n                              state_check cf b (Some true))\\<^sub>\\<surd>,\n                          Main, Label 0 \\<oplus> 1)] @\n                        (as \\<oplus>s 1))\n                       (Main, Exit \\<oplus> 1)", "apply(rule ProcCFG.path_Append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (Main, Label 0)\n                       [((Main, Label 0),\n                         (\\<lambda>cf.\n                             state_check cf b (Some true))\\<^sub>\\<surd>,\n                         Main, Label 0 \\<oplus> 1)]\n                       ?n''3\n 2. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp ?n''3 (as \\<oplus>s 1)\n                       (Main, Exit \\<oplus> 1)", "apply(rule ProcCFG.path.intros)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_node wfp ?n''3\n 2. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1)\n 3. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      (Main, Label 0)\n 4. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      ?n''3\n 5. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp ?n''3 (as \\<oplus>s 1)\n                       (Main, Exit \\<oplus> 1)", "prefer 5"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp ?n''3 (as \\<oplus>s 1)\n                       (Main, Exit \\<oplus> 1)\n 2. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_node wfp ?n''3\n 3. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1)\n 4. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      (Main, Label 0)\n 5. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      ?n''3", "apply(rule path_Main_CondTrue)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog ?wfp13 = (?prog13, ?procs13)\n 2. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog wfp =\n                      (if (?b13) ?prog13 else ?c\\<^sub>213, ?procs13)\n 3. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path ?wfp13 (Main, ?n13) as (Main, Exit)\n 4. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set as. intra_kind (kind a)\n 5. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ?n13 \\<noteq> Entry\n 6. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_node wfp (Main, ?n13 \\<oplus> 1)\n 7. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1)\n 8. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      (Main, Label 0)\n 9. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some\n              true))\\<^sub>\\<surd>\\<rightarrow> (Main,\n           Label 0 \\<oplus> 1)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      (Main, ?n13 \\<oplus> 1)", "apply(auto intro:ProcCFG.path.intros simp:valid_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp' (Main, Label 0) as (Main, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     if (b) c\\<^sub>1\n     else c\\<^sub>2,procs \\<turnstile> (Main,\n  Label\n   0) -(\\<lambda>cf.\n           state_check cf b\n            (Some true))\\<^sub>\\<surd>\\<rightarrow> (Main, Label 1)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_node wfp (Main, Label 1)", "by(fastforce simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 0)\n   ([((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n      Label 0 \\<oplus> 1)] @\n    (as \\<oplus>s 1))\n   (Main, Exit \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 0)\n   ([((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n      Label 0 \\<oplus> 1)] @\n    (as \\<oplus>s 1))\n   (Main, Exit \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"if (b) c\\<^sub>1 else c\\<^sub>2,procs \\<turnstile> (Main,Entry) -(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow> \n        (Main,Label 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2,procs \\<turnstile> (Main,\n Entry) -(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0)", "by(fastforce intro:Main Proc_CFG_Entry)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Entry) -(\\<lambda>s.\n           True)\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"wfp \\<turnstile> (Main,Entry) -[((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))]\\<rightarrow>* \n        (Main,Label 0)\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2,procs \\<turnstile> (Main,\n                                     Entry) -(\\<lambda>s.\n           True)\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n     (Main, Label 0)", "by(fastforce intro:ProcCFG.path.intros \n                    simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label 0)\n   ([((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n      Label 0 \\<oplus> 1)] @\n    (as \\<oplus>s 1))\n   (Main, Exit \\<oplus> 1)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label 0)\n   ([((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n      Label 0 \\<oplus> 1)] @\n    (as \\<oplus>s 1))\n   (Main, Exit \\<oplus> 1)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using \\<open>l = 0\\<close> \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close>"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label 0)\n   ([((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n      Label 0 \\<oplus> 1)] @\n    (as \\<oplus>s 1))\n   (Main, Exit \\<oplus> 1)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n  l = 0\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:label_incrs_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case False"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"0 < l\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < l", "by simp"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "then"], ["proof (chain)\npicking this:\n  0 < l", "obtain l' where [simp]:\"l = l' + 1\" and \"l' = l - 1\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l = l' + 1; l' = l - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  l = l' + 1\n  l' = l - 1\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof(cases \"l' < #:c\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case True"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>1\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)", "obtain wfp' where [simp]:\"Rep_wf_prog wfp' = (c\\<^sub>1, procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_CondTrue)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp' = (c\\<^sub>1, procs)\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH1[OF True this]"], ["proof (chain)\npicking this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain as as' \n          where path1:\"wfp' \\<turnstile> (Main, Label l') -as\\<rightarrow>* (Main, Exit)\"\n          and intra1:\"\\<forall>a\\<in>set as. intra_kind (kind a)\"\n          and path2:\"wfp' \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l')\"\n          and intra2:\"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp' (Main, Label l') as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp' (Main, Entry) as' (Main, Label l');\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path1 intra1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"wfp \\<turnstile> (Main, Label l' \\<oplus> 1) -as \\<oplus>s 1\\<rightarrow>* (Main, Exit \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l' \\<oplus> 1) (as \\<oplus>s 1)\n     (Main, Exit \\<oplus> 1)", "by -(rule path_Main_CondTrue,auto)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 1) (as \\<oplus>s 1)\n   (Main, Exit \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 1) (as \\<oplus>s 1)\n   (Main, Exit \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')", "obtain ax' asx' where [simp]:\"as' = ax'#asx'\"\n          and \"sourcenode ax' = (Main,Entry)\" and \"valid_edge wfp' ax'\"\n          and \"wfp' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main, Label l')\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n\ngoal (1 subgoal):\n 1. (\\<And>ax' asx'.\n        \\<lbrakk>as' = ax' # asx'; sourcenode ax' = (Main, Entry);\n         valid_edge wfp' ax';\n         ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule ProcCFG.path.cases,fastforce+)"], ["proof (state)\nthis:\n  as' = ax' # asx'\n  sourcenode ax' = (Main, Entry)\n  valid_edge wfp' ax'\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  as' = ax' # asx'\n  sourcenode ax' = (Main, Entry)\n  valid_edge wfp' ax'\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')", "have \"targetnode ax' = (Main,Label 0)\""], ["proof (prove)\nusing this:\n  well_formed procs\n  as' = ax' # asx'\n  sourcenode ax' = (Main, Entry)\n  valid_edge wfp' ax'\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n\ngoal (1 subgoal):\n 1. targetnode ax' = (Main, Label 0)", "by(fastforce elim:PCFG.cases dest:Proc_CFG_EntryD Proc_CFG_Call_Labels \n                      simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode ax' = (Main, Label 0)\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main, Label l')\\<close> intra2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)", "have \"wfp \\<turnstile> (Main,Entry) -((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))#\n          ((Main,Label 0),(\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>,(Main,Label 0 \\<oplus> 1))#\n          (asx' \\<oplus>s 1)\\<rightarrow>* (Main,Label l' \\<oplus> 1)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      ((Main, Label 0),\n       (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n       Label 0 \\<oplus> 1) #\n      (asx' \\<oplus>s 1))\n     (Main, Label l' \\<oplus> 1)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (Main, Entry)\n                       (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                         Main, Label 0) #\n                        ((Main, Label 0),\n                         (\\<lambda>cf.\n                             state_check cf b (Some true))\\<^sub>\\<surd>,\n                         Main, Label 0 \\<oplus> 1) #\n                        (asx' \\<oplus>s 1))\n                       (Main, Label l' \\<oplus> 1)", "apply(rule ProcCFG.path.intros)+"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp ?n''8 (asx' \\<oplus>s 1)\n                       (Main, Label l' \\<oplus> 1)\n 2. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1)\n 3. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      ?n''3\n 4. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      ?n''8\n 5. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0)\n 6. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0) =\n                      (Main, Entry)\n 7. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0) =\n                      ?n''3", "apply(rule path_Main_CondTrue)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog ?wfp13 = (?prog13, ?procs13)\n 2. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog wfp =\n                      (if (?b13) ?prog13 else ?c\\<^sub>213, ?procs13)\n 3. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path ?wfp13 (Main, ?n13) asx' (Main, Label l')\n 4. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set asx'. intra_kind (kind a)\n 5. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ?n13 \\<noteq> Entry\n 6. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1)\n 7. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      ?n''3\n 8. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some true))\\<^sub>\\<surd>,\n                        Main, Label 0 \\<oplus> 1) =\n                      (Main, ?n13 \\<oplus> 1)\n 9. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0)\n 10. \\<lbrakk>ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n      \\<forall>a\\<in>set as'. intra_kind (kind a);\n      targetnode ax' = (Main, Label 0)\\<rbrakk>\n     \\<Longrightarrow> sourcenode\n                        ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                         Main, Label 0) =\n                       (Main, Entry)\nA total of 11 subgoals...", "by(auto intro:Main Proc_CFG_Entry Proc_CFG_CondTrue simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 0 \\<oplus> 1) #\n    (asx' \\<oplus>s 1))\n   (Main, Label l' \\<oplus> 1)\n\ngoal (2 subgoals):\n 1. l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 1) (as \\<oplus>s 1)\n   (Main, Exit \\<oplus> 1)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 0 \\<oplus> 1) #\n    (asx' \\<oplus>s 1))\n   (Main, Label l' \\<oplus> 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 1) (as \\<oplus>s 1)\n   (Main, Exit \\<oplus> 1)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 0 \\<oplus> 1) #\n    (asx' \\<oplus>s 1))\n   (Main, Label l' \\<oplus> 1)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using intra1 intra2"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 1) (as \\<oplus>s 1)\n   (Main, Exit \\<oplus> 1)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 0 \\<oplus> 1) #\n    (asx' \\<oplus>s 1))\n   (Main, Label l' \\<oplus> 1)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:label_incrs_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case False"], ["proof (state)\nthis:\n  \\<not> l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"#:c\\<^sub>1 \\<le> l'\""], ["proof (prove)\nusing this:\n  \\<not> l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 \\<le> l'", "by simp"], ["proof (state)\nthis:\n  #:c\\<^sub>1 \\<le> l'\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "then"], ["proof (chain)\npicking this:\n  #:c\\<^sub>1 \\<le> l'", "obtain l'' where [simp]:\"l' = l'' + #:c\\<^sub>1\" and \"l'' = l' - #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  #:c\\<^sub>1 \\<le> l'\n\ngoal (1 subgoal):\n 1. (\\<And>l''.\n        \\<lbrakk>l' = l'' + #:c\\<^sub>1; l'' = l' - #:c\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  l' = l'' + #:c\\<^sub>1\n  l'' = l' - #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from  \\<open>l < #:(if (b) c\\<^sub>1 else c\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  l < #:if (b) c\\<^sub>1 else c\\<^sub>2", "have \"l'' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l'' < #:c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l'' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)", "obtain wfp'' where [simp]:\"Rep_wf_prog wfp'' = (c\\<^sub>2, procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp''.\n        Rep_wf_prog wfp'' = (c\\<^sub>2, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_CondFalse)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp'' = (c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH2[OF \\<open>l'' < #:c\\<^sub>2\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>as as'.\n     ProcCFG.path wfp'' (Main, Label l'') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp'' (Main, Entry) as' (Main, Label l'') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain as as' \n          where path1:\"wfp'' \\<turnstile> (Main, Label l'') -as\\<rightarrow>* (Main, Exit)\"\n          and intra1:\"\\<forall>a\\<in>set as. intra_kind (kind a)\"\n          and path2:\"wfp'' \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l'')\"\n          and intra2:\"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>as as'.\n     ProcCFG.path wfp'' (Main, Label l'') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp'' (Main, Entry) as' (Main, Label l'') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp'' (Main, Label l'') as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp'' (Main, Entry) as' (Main, Label l'');\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp'' (Main, Label l'') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp'' (Main, Entry) as' (Main, Label l'')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path1 intra1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp'' (Main, Label l'') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"wfp \\<turnstile> (Main, Label l'' \\<oplus> (#:c\\<^sub>1 + 1)) -as \\<oplus>s (#:c\\<^sub>1 + 1)\\<rightarrow>* \n          (Main, Exit \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp'' (Main, Label l'') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n     (as \\<oplus>s #:c\\<^sub>1 + 1) (Main, Exit \\<oplus> #:c\\<^sub>1 + 1)", "by -(rule path_Main_CondFalse,auto simp:add.assoc)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (Main, Exit \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (Main, Exit \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp'' (Main, Entry) as' (Main, Label l'')", "obtain ax' asx' where [simp]:\"as' = ax'#asx'\"\n          and \"sourcenode ax' = (Main,Entry)\" and \"valid_edge wfp'' ax'\"\n          and \"wfp'' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main, Label l'')\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp'' (Main, Entry) as' (Main, Label l'')\n\ngoal (1 subgoal):\n 1. (\\<And>ax' asx'.\n        \\<lbrakk>as' = ax' # asx'; sourcenode ax' = (Main, Entry);\n         valid_edge wfp'' ax';\n         ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule ProcCFG.path.cases,fastforce+)"], ["proof (state)\nthis:\n  as' = ax' # asx'\n  sourcenode ax' = (Main, Entry)\n  valid_edge wfp'' ax'\n  ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'')\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  as' = ax' # asx'\n  sourcenode ax' = (Main, Entry)\n  valid_edge wfp'' ax'\n  ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'')", "have \"targetnode ax' = (Main,Label 0)\""], ["proof (prove)\nusing this:\n  well_formed procs\n  as' = ax' # asx'\n  sourcenode ax' = (Main, Entry)\n  valid_edge wfp'' ax'\n  ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'')\n\ngoal (1 subgoal):\n 1. targetnode ax' = (Main, Label 0)", "by(fastforce elim:PCFG.cases dest:Proc_CFG_EntryD Proc_CFG_Call_Labels \n                      simp:valid_edge_def)"], ["proof (state)\nthis:\n  targetnode ax' = (Main, Label 0)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp'' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main, Label l'')\\<close> intra2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)", "have \"wfp \\<turnstile> (Main,Entry) -((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))#\n          ((Main,Label 0),(\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>,\n          (Main,Label (#:c\\<^sub>1 + 1)))#(asx' \\<oplus>s (#:c\\<^sub>1 + 1))\\<rightarrow>* \n          (Main,Label l'' \\<oplus> (#:c\\<^sub>1 + 1))\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      ((Main, Label 0),\n       (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n       Label (#:c\\<^sub>1 + 1)) #\n      (asx' \\<oplus>s #:c\\<^sub>1 + 1))\n     (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (Main, Entry)\n                       (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                         Main, Label 0) #\n                        ((Main, Label 0),\n                         (\\<lambda>cf.\n                             state_check cf b (Some false))\\<^sub>\\<surd>,\n                         Main, Label (#:c\\<^sub>1 + 1)) #\n                        (asx' \\<oplus>s #:c\\<^sub>1 + 1))\n                       (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)", "apply(rule ProcCFG.path.intros)+"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp ?n''8\n                       (asx' \\<oplus>s #:c\\<^sub>1 + 1)\n                       (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n 2. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some false))\\<^sub>\\<surd>,\n                        Main, Label (#:c\\<^sub>1 + 1))\n 3. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some false))\\<^sub>\\<surd>,\n                        Main, Label (#:c\\<^sub>1 + 1)) =\n                      ?n''3\n 4. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some false))\\<^sub>\\<surd>,\n                        Main, Label (#:c\\<^sub>1 + 1)) =\n                      ?n''8\n 5. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0)\n 6. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0) =\n                      (Main, Entry)\n 7. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0) =\n                      ?n''3", "apply(rule path_Main_CondFalse)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog ?wfp13 = (?prog13, ?procs13)\n 2. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog wfp =\n                      (if (?b13) c\\<^sub>1 else ?prog13, ?procs13)\n 3. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path ?wfp13 (Main, ?n13) asx'\n                       (Main, Label l'')\n 4. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set asx'. intra_kind (kind a)\n 5. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> ?n13 \\<noteq> Entry\n 6. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some false))\\<^sub>\\<surd>,\n                        Main, Label (#:c\\<^sub>1 + 1))\n 7. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> sourcenode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some false))\\<^sub>\\<surd>,\n                        Main, Label (#:c\\<^sub>1 + 1)) =\n                      ?n''3\n 8. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> targetnode\n                       ((Main, Label 0),\n                        (\\<lambda>cf.\n                            state_check cf b (Some false))\\<^sub>\\<surd>,\n                        Main, Label (#:c\\<^sub>1 + 1)) =\n                      (Main, ?n13 \\<oplus> #:c\\<^sub>1 + 1)\n 9. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     targetnode ax' = (Main, Label 0)\\<rbrakk>\n    \\<Longrightarrow> valid_edge wfp\n                       ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                        Main, Label 0)\n 10. \\<lbrakk>ProcCFG.path wfp'' (targetnode ax') asx' (Main, Label l'');\n      \\<forall>a\\<in>set as'. intra_kind (kind a);\n      targetnode ax' = (Main, Label 0)\\<rbrakk>\n     \\<Longrightarrow> sourcenode\n                        ((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>,\n                         Main, Label 0) =\n                       (Main, Entry)\nA total of 11 subgoals...", "by(auto intro:Main Proc_CFG_Entry Proc_CFG_CondFalse simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label (#:c\\<^sub>1 + 1)) #\n    (asx' \\<oplus>s #:c\\<^sub>1 + 1))\n   (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<not> l' < #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (Main, Exit \\<oplus> #:c\\<^sub>1 + 1)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label (#:c\\<^sub>1 + 1)) #\n    (asx' \\<oplus>s #:c\\<^sub>1 + 1))\n   (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (Main, Exit \\<oplus> #:c\\<^sub>1 + 1)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label (#:c\\<^sub>1 + 1)) #\n    (asx' \\<oplus>s #:c\\<^sub>1 + 1))\n   (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using intra1 intra2"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n   (as \\<oplus>s #:c\\<^sub>1 + 1) (Main, Exit \\<oplus> #:c\\<^sub>1 + 1)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label (#:c\\<^sub>1 + 1)) #\n    (asx' \\<oplus>s #:c\\<^sub>1 + 1))\n   (Main, Label l'' \\<oplus> #:c\\<^sub>1 + 1)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:label_incrs_def intra_kind_def add.assoc)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case (While b c')"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c'; Rep_wf_prog ?wfp = (c', procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n  l < #:while (b) c'\n  Rep_wf_prog wfp = (while (b) c', procs)\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note IH = \\<open>\\<And>l wfp. \\<lbrakk>l < #:c'; Rep_wf_prog wfp = (c', procs)\\<rbrakk> \\<Longrightarrow>\n      \\<exists>as as'. wfp \\<turnstile> (Main, Label l) -as\\<rightarrow>* (Main, Exit) \\<and>\n      (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n      wfp \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l) \\<and> (\\<forall>a\\<in>set as'. intra_kind (kind a))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?l < #:c'; Rep_wf_prog ?wfp = (c', procs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.path ?wfp (Main, Label ?l) as\n                        (Main, Exit) \\<and>\n                       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                       ProcCFG.path ?wfp (Main, Entry) as'\n                        (Main, Label ?l) \\<and>\n                       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note [simp] = \\<open>Rep_wf_prog wfp = (while (b) c', procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (while (b) c', procs)\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog l wfp.\n       \\<lbrakk>\\<And>l wfp.\n                   \\<lbrakk>l < #:prog;\n                    Rep_wf_prog wfp = (prog, procs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n  (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n  ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n  (\\<forall>a\\<in>set as'. intra_kind (kind a));\n        l < #:while (x1) prog;\n        Rep_wf_prog wfp = (while (x1) prog, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof(cases \"l = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case True"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"wfp \\<turnstile> (Main,Label l) - \n        ((Main,Label 0),(\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>,(Main,Label 1))#\n        [((Main,Label 1),\\<Up>id,(Main,Exit))]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\nusing this:\n  l = 0\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l)\n     [((Main, Label 0),\n       (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n       Label 1),\n      ((Main, Label 1), \\<Up>id, Main, Exit)]\n     (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_WhileFalseSkip \n          Proc_CFG_WhileFalse simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l)\n   [((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l)\n   [((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"while (b) c' \\<turnstile> Entry -IEdge (\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while (b) c' \\<turnstile> Entry -IEdge\n(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 0", "by(rule Proc_CFG_Entry)"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> Entry -IEdge\n                                    (\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>l = 0\\<close>"], ["proof (chain)\npicking this:\n  l = 0\n  while (b) c' \\<turnstile> Entry -IEdge\n                                    (\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 0", "have \"wfp \\<turnstile> (Main,Entry) \n        -[((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))]\\<rightarrow>* (Main,Label l)\""], ["proof (prove)\nusing this:\n  l = 0\n  while (b) c' \\<turnstile> Entry -IEdge\n                                    (\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 0\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n     (Main, Label l)", "by(fastforce intro:ProcCFG.path.intros Main \n                     simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label l)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l)\n   [((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label l)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l)\n   [((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label l)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case False"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"1 \\<le> l\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> l", "by simp"], ["proof (state)\nthis:\n  1 \\<le> l\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof(cases \"l < 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case True"], ["proof (state)\nthis:\n  l < 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  1 \\<le> l\n  l < 2", "have [simp]:\"l = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> l\n  l < 2\n\ngoal (1 subgoal):\n 1. l = 1", "by simp"], ["proof (state)\nthis:\n  l = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Label l) -[((Main,Label 1),\\<Up>id,(Main,Exit))]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l)\n     [((Main, Label 1), \\<Up>id, Main, Exit)] (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_WhileFalseSkip \n                      simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"while (b) c' \\<turnstile> Label 0 -IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p \n          Label 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while (b) c' \\<turnstile> Label\n                               0 -IEdge\n                                   (\\<lambda>cf.\n state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1", "by(rule Proc_CFG_WhileFalse)"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> Label\n                             0 -IEdge\n                                 (\\<lambda>cf.\n                                     state_check cf b\n(Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"wfp \\<turnstile> (Main,Entry) -((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))#\n          [((Main,Label 0),(\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>,(Main,Label 1))]\\<rightarrow>*\n          (Main,Label l)\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> Label\n                             0 -IEdge\n                                 (\\<lambda>cf.\n                                     state_check cf b\n(Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n      ((Main, Label 0),\n       (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n       Label 1)]\n     (Main, Label l)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_Entry \n                       simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1)]\n   (Main, Label l)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> l; l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1)]\n   (Main, Label l)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1)]\n   (Main, Label l)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case False"], ["proof (state)\nthis:\n  \\<not> l < 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  1 \\<le> l\n  \\<not> l < 2", "have \"2 \\<le> l\""], ["proof (prove)\nusing this:\n  1 \\<le> l\n  \\<not> l < 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> l", "by simp"], ["proof (state)\nthis:\n  2 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "then"], ["proof (chain)\npicking this:\n  2 \\<le> l", "obtain l' where [simp]:\"l = l' + 2\" and \"l' = l - 2\""], ["proof (prove)\nusing this:\n  2 \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l = l' + 2; l' = l - 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp del:add_2_eq_Suc')"], ["proof (state)\nthis:\n  l = l' + 2\n  l' = l - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>l < #:while (b) c'\\<close>"], ["proof (chain)\npicking this:\n  l < #:while (b) c'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  l < #:while (b) c'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by simp"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (while (b) c', procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (while (b) c', procs)", "obtain wfp' where [simp]:\"Rep_wf_prog wfp' = (c', procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (while (b) c', procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c', procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_WhileBody)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp' = (c', procs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from IH[OF \\<open>l' < #:c'\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))", "obtain as as' \n          where path1:\"wfp' \\<turnstile> (Main, Label l') -as\\<rightarrow>* (Main, Exit)\"\n          and intra1:\"\\<forall>a\\<in>set as. intra_kind (kind a)\"\n          and path2:\"wfp' \\<turnstile> (Main, Entry) -as'\\<rightarrow>* (Main, Label l')\"\n          and intra2:\"\\<forall>a\\<in>set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>as as'.\n     ProcCFG.path wfp' (Main, Label l') as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp' (Main, Entry) as' (Main, Label l') \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp' (Main, Label l') as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp' (Main, Entry) as' (Main, Label l');\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "by(fastforce elim:ProcCFG.path.cases)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with path1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  as \\<noteq> []", "obtain ax asx where [simp]:\"as = asx@[ax]\"\n          and \"wfp' \\<turnstile> (Main, Label l') -asx\\<rightarrow>* sourcenode ax\"\n          and \"valid_edge wfp' ax\" and \"targetnode ax = (Main, Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l') as (Main, Exit)\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax.\n        \\<lbrakk>as = asx @ [ax];\n         ProcCFG.path wfp' (Main, Label l') asx (sourcenode ax);\n         valid_edge wfp' ax; targetnode ax = (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule ProcCFG.path_split_snoc,fastforce+)"], ["proof (state)\nthis:\n  as = asx @ [ax]\n  ProcCFG.path wfp' (Main, Label l') asx (sourcenode ax)\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  as = asx @ [ax]\n  ProcCFG.path wfp' (Main, Label l') asx (sourcenode ax)\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)", "obtain lx etx where \"sourcenode ax = (Main,Label lx)\"\n          and \"intra_kind (kind ax)\""], ["proof (prove)\nusing this:\n  well_formed procs\n  as = asx @ [ax]\n  ProcCFG.path wfp' (Main, Label l') asx (sourcenode ax)\n  valid_edge wfp' ax\n  targetnode ax = (Main, Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>lx.\n        \\<lbrakk>sourcenode ax = (Main, Label lx);\n         intra_kind (kind ax)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto elim!:PCFG.cases dest:Proc_CFG_Call_Labels simp:valid_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>lx.\n                   \\<lbrakk>n = Label lx; intra_kind (kind ax)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        well_formed procs; ProcCFG.path wfp' (Main, Label l') asx (Main, n);\n        targetnode ax = (Main, Exit); sourcenode ax = (Main, n);\n        c' \\<turnstile> n -IEdge\n                            (kind ax)\\<rightarrow>\\<^sub>p Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n)(auto dest:Proc_CFG_IEdge_intra_kind)"], ["proof (state)\nthis:\n  sourcenode ax = (Main, Label lx)\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp' \\<turnstile> (Main, Label l') -asx\\<rightarrow>* sourcenode ax\\<close> intra1"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Label l') asx (sourcenode ax)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  sourcenode ax = (Main, Label lx)\n  intra_kind (kind ax)", "have \"wfp \\<turnstile> (Main, Label l' \\<oplus> 2) -asx \\<oplus>s 2\\<rightarrow>* (Main,Label lx \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Label l') asx (sourcenode ax)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  sourcenode ax = (Main, Label lx)\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l' \\<oplus> 2) (asx \\<oplus>s 2)\n     (Main, Label lx \\<oplus> 2)", "by -(rule path_Main_WhileBody,auto)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 2) (asx \\<oplus>s 2)\n   (Main, Label lx \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>valid_edge wfp' ax\\<close> \\<open>sourcenode ax = (Main,Label lx)\\<close>\n          \\<open>targetnode ax = (Main, Exit)\\<close> \\<open>intra_kind (kind ax)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp' ax\n  sourcenode ax = (Main, Label lx)\n  targetnode ax = (Main, Exit)\n  intra_kind (kind ax)\n  well_formed procs", "have \"while (b) c',procs \\<turnstile> (Main,Label lx \\<oplus> 2) -kind ax\\<rightarrow> \n          (Main,Label 0)\""], ["proof (prove)\nusing this:\n  valid_edge wfp' ax\n  sourcenode ax = (Main, Label lx)\n  targetnode ax = (Main, Exit)\n  intra_kind (kind ax)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. while (b) c',procs \\<turnstile> (Main,\n                                     Label\nlx \\<oplus> 2) -kind ax\\<rightarrow> (Main, Label 0)", "by(fastforce intro!:Main Proc_CFG_WhileBodyExit elim!:PCFG.cases \n                        dest:Proc_CFG_Call_Labels simp:valid_edge_def)"], ["proof (state)\nthis:\n  while (b) c',procs \\<turnstile> (Main,\n                                   Label\n                                    lx \\<oplus> 2) -kind\n               ax\\<rightarrow> (Main, Label 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"wfp \\<turnstile> (Main,Label lx \\<oplus> 2) \n          -((Main,Label lx \\<oplus> 2),kind ax,(Main,Label 0))#\n          ((Main,Label 0),(\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>,(Main,Label 1))#\n          [((Main,Label 1),\\<Up>id,(Main,Exit))]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\nusing this:\n  while (b) c',procs \\<turnstile> (Main,\n                                   Label\n                                    lx \\<oplus> 2) -kind\n               ax\\<rightarrow> (Main, Label 0)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label lx \\<oplus> 2)\n     [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n      ((Main, Label 0),\n       (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n       Label 1),\n      ((Main, Label 1), \\<Up>id, Main, Exit)]\n     (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_WhileFalse \n            Proc_CFG_WhileFalseSkip simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label lx \\<oplus> 2)\n   [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp \\<turnstile> (Main, Label l' \\<oplus> 2) -asx \\<oplus>s 2\\<rightarrow>* (Main,Label lx \\<oplus> 2)\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 2) (asx \\<oplus>s 2)\n   (Main, Label lx \\<oplus> 2)\n  ProcCFG.path wfp (Main, Label lx \\<oplus> 2)\n   [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)", "have \"wfp \\<turnstile> (Main, Label l) -(asx \\<oplus>s 2)@\n          (((Main,Label lx \\<oplus> 2),kind ax,(Main,Label 0))#\n          ((Main,Label 0),(\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>,(Main,Label 1))#\n          [((Main,Label 1),\\<Up>id,(Main,Exit))])\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l' \\<oplus> 2) (asx \\<oplus>s 2)\n   (Main, Label lx \\<oplus> 2)\n  ProcCFG.path wfp (Main, Label lx \\<oplus> 2)\n   [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n     Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label l)\n     ((asx \\<oplus>s 2) @\n      [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n       ((Main, Label 0),\n        (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n        Label 1),\n       ((Main, Label 1), \\<Up>id, Main, Exit)])\n     (Main, Exit)", "by(fastforce intro:ProcCFG.path_Append)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx \\<oplus>s 2) @\n    [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n     ((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n      Label 1),\n     ((Main, Label 1), \\<Up>id, Main, Exit)])\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx \\<oplus>s 2) @\n    [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n     ((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n      Label 1),\n     ((Main, Label 1), \\<Up>id, Main, Exit)])\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from path2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')", "have \"as' \\<noteq> []\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> []", "by(fastforce elim:ProcCFG.path.cases)"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with path2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n  as' \\<noteq> []", "obtain ax' asx' where [simp]:\"as' = ax'#asx'\"\n          and \"wfp' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main,Label l')\"\n          and \"valid_edge wfp' ax'\" and \"sourcenode ax' = (Main, Entry)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l')\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ax' asx'.\n        \\<lbrakk>as' = ax' # asx';\n         ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l');\n         valid_edge wfp' ax'; sourcenode ax' = (Main, Entry)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule ProcCFG.path_split_Cons,fastforce+)"], ["proof (state)\nthis:\n  as' = ax' # asx'\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  valid_edge wfp' ax'\n  sourcenode ax' = (Main, Entry)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  as' = ax' # asx'\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  valid_edge wfp' ax'\n  sourcenode ax' = (Main, Entry)", "have \"targetnode ax' = (Main,Label 0)\" and \"intra_kind (kind ax')\""], ["proof (prove)\nusing this:\n  well_formed procs\n  as' = ax' # asx'\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  valid_edge wfp' ax'\n  sourcenode ax' = (Main, Entry)\n\ngoal (1 subgoal):\n 1. targetnode ax' = (Main, Label 0) &&& intra_kind (kind ax')", "by(fastforce elim!:PCFG.cases dest:Proc_CFG_Call_Labels \n            Proc_CFG_EntryD simp:intra_kind_def valid_edge_def)+"], ["proof (state)\nthis:\n  targetnode ax' = (Main, Label 0)\n  intra_kind (kind ax')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>wfp' \\<turnstile> targetnode ax' -asx'\\<rightarrow>* (Main,Label l')\\<close> intra2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)\n  intra_kind (kind ax')", "have \"wfp \\<turnstile> (Main, Label 0 \\<oplus> 2) -asx' \\<oplus>s 2\\<rightarrow>* (Main,Label l' \\<oplus> 2)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp' (targetnode ax') asx' (Main, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  targetnode ax' = (Main, Label 0)\n  intra_kind (kind ax')\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label 0 \\<oplus> 2) (asx' \\<oplus>s 2)\n     (Main, Label l' \\<oplus> 2)", "by -(rule path_Main_WhileBody,auto simp del:add_2_eq_Suc')"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 0 \\<oplus> 2) (asx' \\<oplus>s 2)\n   (Main, Label l' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"wfp \\<turnstile> (Main,Entry) -((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))#\n          ((Main,Label 0),(\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>,(Main,Label 2))#\n          (asx' \\<oplus>s 2)\\<rightarrow>* (Main,Label l)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label 0 \\<oplus> 2) (asx' \\<oplus>s 2)\n   (Main, Label l' \\<oplus> 2)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n      ((Main, Label 0),\n       (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n       Label 2) #\n      (asx' \\<oplus>s 2))\n     (Main, Label l)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_WhileTrue \n            Proc_CFG_Entry simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 2) #\n    (asx' \\<oplus>s 2))\n   (Main, Label l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> l; \\<not> l < 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as as'.\n                         ProcCFG.path wfp (Main, Label l) as\n                          (Main, Exit) \\<and>\n                         (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n                         ProcCFG.path wfp (Main, Entry) as'\n                          (Main, Label l) \\<and>\n                         (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx \\<oplus>s 2) @\n    [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n     ((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n      Label 1),\n     ((Main, Label 1), \\<Up>id, Main, Exit)])\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 2) #\n    (asx' \\<oplus>s 2))\n   (Main, Label l)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx \\<oplus>s 2) @\n    [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n     ((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n      Label 1),\n     ((Main, Label 1), \\<Up>id, Main, Exit)])\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 2) #\n    (asx' \\<oplus>s 2))\n   (Main, Label l)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using \\<open>intra_kind (kind ax)\\<close> intra1 intra2"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label l)\n   ((asx \\<oplus>s 2) @\n    [((Main, Label lx \\<oplus> 2), kind ax, Main, Label 0),\n     ((Main, Label 0),\n      (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>, Main,\n      Label 1),\n     ((Main, Label 1), \\<Up>id, Main, Exit)])\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   (((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0) #\n    ((Main, Label 0),\n     (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>, Main,\n     Label 2) #\n    (asx' \\<oplus>s 2))\n   (Main, Label l)\n  intra_kind (kind ax)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:label_incrs_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case (Call p es rets)"], ["proof (state)\nthis:\n  l < #:Call p es rets\n  Rep_wf_prog wfp = (Call p es rets, procs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "note Rep [simp] = \\<open>Rep_wf_prog wfp = (Call p es rets, procs)\\<close>"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (Call p es rets, procs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have cC:\"containsCall procs (Call p es rets) [] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. containsCall procs (Call p es rets) [] p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (Call p es rets) [] p\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 l wfp.\n       \\<lbrakk>l < #:Call x1 x2 x3;\n        Rep_wf_prog wfp = (Call x1 x2 x3, procs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.path wfp (Main, Label l) as\n                             (Main, Exit) \\<and>\n                            (\\<forall>a\\<in>set as.\n                                intra_kind (kind a)) \\<and>\n                            ProcCFG.path wfp (Main, Entry) as'\n                             (Main, Label l) \\<and>\n                            (\\<forall>a\\<in>set as'. intra_kind (kind a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "proof(cases \"l = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case True"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Label 0) -((Main,Label 0),(\\<lambda>s. False)\\<^sub>\\<surd>,(Main,Label 1))#\n        [((Main,Label 1),\\<Up>id,(Main,Exit))]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label 0)\n     [((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1),\n      ((Main, Label 1), \\<Up>id, Main, Exit)]\n     (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_CallSkip MainCallReturn\n          Proc_CFG_Call simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"Call p es rets,procs \\<turnstile> (Main,Entry) -(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow> (Main,Label 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Call p es\n     rets,procs \\<turnstile> (Main,\n                              Entry) -(\\<lambda>s.\n    True)\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0)", "by(fastforce intro:Main Proc_CFG_Entry)"], ["proof (state)\nthis:\n  Call p es\n   rets,procs \\<turnstile> (Main,\n                            Entry) -(\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"wfp \\<turnstile> (Main,Entry) -[((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))]\\<rightarrow>*\n        (Main,Label 0)\""], ["proof (prove)\nusing this:\n  Call p es\n   rets,procs \\<turnstile> (Main,\n                            Entry) -(\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow> (Main, Label 0)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n     (Main, Label 0)", "by(fastforce intro:ProcCFG.path.intros \n          simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))\n 2. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using \\<open>l = 0\\<close>"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label 0)\n   [((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1),\n    ((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0)]\n   (Main, Label 0)\n  l = 0\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "case False"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "with \\<open>l < #:Call p es rets\\<close>"], ["proof (chain)\npicking this:\n  l < #:Call p es rets\n  l \\<noteq> 0", "have \"l = 1\""], ["proof (prove)\nusing this:\n  l < #:Call p es rets\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l = 1", "by simp"], ["proof (state)\nthis:\n  l = 1\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"wfp \\<turnstile> (Main,Label 1) -[((Main,Label 1),\\<Up>id,(Main,Exit))]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label 1)\n     [((Main, Label 1), \\<Up>id, Main, Exit)] (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_CallSkip\n                    simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "have \"Call p es rets,procs \\<turnstile> (Main,Label 0) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,Label 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Call p es\n     rets,procs \\<turnstile> (Main,\n                              Label\n                               0) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (Main, Label 1)", "by(fastforce intro:MainCallReturn Proc_CFG_Call)"], ["proof (state)\nthis:\n  Call p es\n   rets,procs \\<turnstile> (Main,\n                            Label\n                             0) -(\\<lambda>s.\n                                     False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                  Label 1)\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "hence \"wfp \\<turnstile> (Main,Entry) -((Main,Entry),(\\<lambda>s. True)\\<^sub>\\<surd>,(Main,Label 0))#\n        [((Main,Label 0),(\\<lambda>s. False)\\<^sub>\\<surd>,(Main,Label 1))]\\<rightarrow>* (Main,Label 1)\""], ["proof (prove)\nusing this:\n  Call p es\n   rets,procs \\<turnstile> (Main,\n                            Label\n                             0) -(\\<lambda>s.\n                                     False)\\<^sub>\\<surd>\\<rightarrow> (Main,\n                                  Label 1)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n      ((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1)]\n     (Main, Label 1)", "by(fastforce intro:ProcCFG.path.intros Main Proc_CFG_Entry \n                    simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1)]\n   (Main, Label 1)\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1)]\n   (Main, Label 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1)]\n   (Main, Label 1)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "using \\<open>l = 1\\<close>"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label 1) [((Main, Label 1), \\<Up>id, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. True)\\<^sub>\\<surd>, Main, Label 0),\n    ((Main, Label 0), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Label 1)]\n   (Main, Label 1)\n  l = 1\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (Main, Label l) as (Main, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (Main, Entry) as' (Main, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lifting from edges in procedure Main to arbitrary procedures\\<close>"], ["", "lemma lift_edge_Main_Main:\n  \"\\<lbrakk>c,procs \\<turnstile> (Main, n) -et\\<rightarrow> (Main, n'); (p,ins,outs,c) \\<in> set procs;\n  containsCall procs prog ps p; well_formed procs\\<rbrakk> \n  \\<Longrightarrow> prog,procs \\<turnstile> (p, n) -et\\<rightarrow> (p, n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c,procs \\<turnstile> (Main, n) -et\\<rightarrow> (Main, n');\n     (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n     well_formed procs\\<rbrakk>\n    \\<Longrightarrow> prog,procs \\<turnstile> (p,\n         n) -et\\<rightarrow> (p, n')", "proof(induct \"(Main,n)\" et \"(Main,n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         n'a)\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es\\<rightarrow> (p, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es'\\<rightarrow> (p, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=] map cf outsa)\\<rightarrow> (p, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets' [:=] map cf outs')\\<rightarrow> (p, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')", "case Main"], ["proof (state)\nthis:\n  c \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         n'a)\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es\\<rightarrow> (p, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es'\\<rightarrow> (p, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=] map cf outsa)\\<rightarrow> (p, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets' [:=] map cf outs')\\<rightarrow> (p, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')", "thus ?case"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge et_\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, n) -et_\\<rightarrow> (p, n')", "by(fastforce intro:Proc)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, n) -et_\\<rightarrow> (p, n')\n\ngoal (7 subgoals):\n 1. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 2. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         n'a)\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es\\<rightarrow> (p, n')\n 3. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es'\\<rightarrow> (p, n')\n 4. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=] map cf outsa)\\<rightarrow> (p, n')\n 5. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets' [:=] map cf outs')\\<rightarrow> (p, n')\n 6. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')\n 7. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 2. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         n'a)\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es\\<rightarrow> (p, n')\n 3. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es'\\<rightarrow> (p, n')\n 4. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=] map cf outsa)\\<rightarrow> (p, n')\n 5. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets' [:=] map cf outs')\\<rightarrow> (p, n')\n 6. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')\n 7. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')", "case MainCallReturn"], ["proof (state)\nthis:\n  c \\<turnstile> n -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 2. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         n'a)\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es\\<rightarrow> (p, n')\n 3. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es'\\<rightarrow> (p, n')\n 4. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=] map cf outsa)\\<rightarrow> (p, n')\n 5. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets' [:=] map cf outs')\\<rightarrow> (p, n')\n 6. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')\n 7. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')", "thus ?case"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, n) -(\\<lambda>s.\n  False)\\<^sub>\\<surd>\\<rightarrow> (p, n')", "by(fastforce intro:ProcCallReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, n) -(\\<lambda>s.\nFalse)\\<^sub>\\<surd>\\<rightarrow> (p, n')\n\ngoal (6 subgoals):\n 1. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -et\\<rightarrow> (p, n')\n 2. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         n'a)\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es\\<rightarrow> (p, n')\n 3. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Label l = n; Entry = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>s.\n                   True:(Main,\n                         Label\n                          l')\\<hookrightarrow>\\<^bsub>Main\\<^esub>map\n                             interpret es'\\<rightarrow> (p, n')\n 4. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets [:=] map cf outsa)\\<rightarrow> (p, n')\n 5. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs;\n        containsCall procs c psa Main; Exit = n; Label l' = n';\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -\\<lambda>cf.\n                   snd cf =\n                   (Main,\n                    Label\n                     l')\\<hookleftarrow>\\<^bsub>Main\\<^esub>\\<lambda>cf cf'.\n                         cf'(rets' [:=] map cf outs')\\<rightarrow> (p, n')\n 6. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> prog,procs \\<turnstile> (p,\n            n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p, n')", "qed auto"], ["", "lemma lift_edge_Main_Proc:\n  \"\\<lbrakk>c,procs \\<turnstile> (Main, n) -et\\<rightarrow> (q, n'); q \\<noteq> Main; (p,ins,outs,c) \\<in> set procs;\n  containsCall procs prog ps p; well_formed procs\\<rbrakk> \n  \\<Longrightarrow> \\<exists>et'. prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (q, n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c,procs \\<turnstile> (Main, n) -et\\<rightarrow> (q, n');\n     q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n     containsCall procs prog ps p; well_formed procs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>et'.\n                         prog,procs \\<turnstile> (p,\n            n) -et'\\<rightarrow> (q, n')", "proof(induct \"(Main,n)\" et \"(q,n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (q, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Main = q;\n        Label l' = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')", "case (MainCall l esx retsx n'x insx outsx cx)"], ["proof (state)\nthis:\n  c \\<turnstile> Label l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p n'x\n  (q, insx, outsx, cx) \\<in> set procs\n  Label l = n\n  Entry = n'\n  q \\<noteq> Main\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (q, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Main = q;\n        Label l' = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')", "from \\<open>c \\<turnstile> Label l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p n'x\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p n'x", "obtain l' where [simp]:\"n'x = Label l'\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p n'x\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n'x = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  n'x = Label l'\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (q, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Main = q;\n        Label l' = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')", "with MainCall"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p n'x\n  (q, insx, outsx, cx) \\<in> set procs\n  Label l = n\n  Entry = n'\n  q \\<noteq> Main\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n  n'x = Label l'", "have \"prog,procs \\<turnstile> (p, n) \n    -(\\<lambda>s. True):(p,n'x)\\<hookrightarrow>\\<^bsub>q\\<^esub>map (\\<lambda>e cf. interpret e cf) esx\\<rightarrow> (q, n')\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p n'x\n  (q, insx, outsx, cx) \\<in> set procs\n  Label l = n\n  Entry = n'\n  q \\<noteq> Main\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n  n'x = Label l'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, n) -\\<lambda>s.\n True:(p, n'x)\\<hookrightarrow>\\<^bsub>q\\<^esub>map interpret\n           esx\\<rightarrow> (q, n')", "by(fastforce intro:ProcCall)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, n) -\\<lambda>s.\n                                     True:(p,\n     n'x)\\<hookrightarrow>\\<^bsub>q\\<^esub>map interpret\n      esx\\<rightarrow> (q, n')\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es, rets)\\<rightarrow>\\<^sub>p n'a;\n        (q, insa, outsa, ca) \\<in> set procs; Label l = n; Entry = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Main = q;\n        Label l' = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')", "thus ?case"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (p, n) -\\<lambda>s.\n                                     True:(p,\n     n'x)\\<hookrightarrow>\\<^bsub>q\\<^esub>map interpret\n      esx\\<rightarrow> (q, n')\n\ngoal (1 subgoal):\n 1. \\<exists>et'. prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (q, n')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>et'. prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (q, n')\n\ngoal (7 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 3. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 4. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (Main, insa, outsa, ca) \\<in> set procs; Exit = n; Main = q;\n        Label l' = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 5. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 6. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')\n 7. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa Main; Main = q; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (p,\n               n) -et'\\<rightarrow> (q, n')", "qed auto"], ["", "lemma lift_edge_Proc_Main:\n  \"\\<lbrakk>c,procs \\<turnstile> (q, n) -et\\<rightarrow> (Main, n'); q \\<noteq> Main; (p,ins,outs,c) \\<in> set procs;\n  containsCall procs prog ps p; well_formed procs\\<rbrakk> \n  \\<Longrightarrow> \\<exists>et'. prog,procs \\<turnstile> (q, n) -et'\\<rightarrow> (p, n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c,procs \\<turnstile> (q, n) -et\\<rightarrow> (Main, n');\n     q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n     containsCall procs prog ps p; well_formed procs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>et'.\n                         prog,procs \\<turnstile> (q,\n            n) -et'\\<rightarrow> (p, n')", "proof(induct \"(q,n)\" et \"(Main,n')\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Main = q; Label l = n;\n        Entry = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (q, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')", "case (MainReturn l esx retsx l' insx outsx cx)"], ["proof (state)\nthis:\n  c \\<turnstile> Label\n                  l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (q, insx, outsx, cx) \\<in> set procs\n  Exit = n\n  Label l' = n'\n  q \\<noteq> Main\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Main = q; Label l = n;\n        Entry = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (q, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')", "note [simp] = \\<open>Exit = n\\<close>[THEN sym] \\<open>Label l' = n'\\<close>[THEN sym]"], ["proof (state)\nthis:\n  n = Exit\n  n' = Label l'\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Main = q; Label l = n;\n        Entry = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (q, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')", "from MainReturn"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (q, insx, outsx, cx) \\<in> set procs\n  Exit = n\n  Label l' = n'\n  q \\<noteq> Main\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs", "have \"prog,procs \\<turnstile> (q,Exit) -(\\<lambda>cf. snd cf = (p,Label l'))\\<hookleftarrow>\\<^bsub>q\\<^esub>\n    (\\<lambda>cf cf'. cf'(retsx [:=] map cf outsx))\\<rightarrow> (p,Label l')\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (q, esx, retsx)\\<rightarrow>\\<^sub>p Label l'\n  (q, insx, outsx, cx) \\<in> set procs\n  Exit = n\n  Label l' = n'\n  q \\<noteq> Main\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (q, Exit) -\\<lambda>cf.\n    snd cf =\n    (p, Label\n         l')\\<hookleftarrow>\\<^bsub>q\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n          map cf outsx)\\<rightarrow> (p, Label l')", "by(fastforce intro!:ProcReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (q, Exit) -\\<lambda>cf.\n  snd cf =\n  (p, Label\n       l')\\<hookleftarrow>\\<^bsub>q\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n        map cf outsx)\\<rightarrow> (p, Label l')\n\ngoal (8 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Main = q; Label l = n;\n        Entry = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 5. \\<And>l es rets l' insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (q, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l';\n        (q, insa, outsa, ca) \\<in> set procs; Exit = n; Label l' = n';\n        q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 6. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 7. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 8. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')", "thus ?case"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (q, Exit) -\\<lambda>cf.\n  snd cf =\n  (p, Label\n       l')\\<hookleftarrow>\\<^bsub>q\\<^esub>\\<lambda>cf cf'. cf'(retsx [:=]\n        map cf outsx)\\<rightarrow> (p, Label l')\n\ngoal (1 subgoal):\n 1. \\<exists>et'. prog,procs \\<turnstile> (q, n) -et'\\<rightarrow> (p, n')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>et'. prog,procs \\<turnstile> (q, n) -et'\\<rightarrow> (p, n')\n\ngoal (7 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 3. \\<And>l es rets n'a insa outsa ca.\n       \\<lbrakk>c \\<turnstile> Label\n                                l -CEdge\n                                    (Main, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'a;\n        (Main, insa, outsa, ca) \\<in> set procs; Main = q; Label l = n;\n        Entry = n'; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 4. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (Main, es',\n                              rets')\\<rightarrow>\\<^sub>p Label l';\n        (Main, ins', outs', c') \\<in> set procs; containsCall procs c psa q;\n        Label l = n; Entry = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 5. \\<And>insa outsa ca l es' rets' l' ins' outs' c' psa.\n       \\<lbrakk>(Main, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (q, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (q, ins', outs', c') \\<in> set procs; containsCall procs c psa Main;\n        Exit = n; Label l' = n'; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 6. \\<And>pa es rets.\n       \\<lbrakk>c \\<turnstile> n -CEdge\n                                   (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = q; q \\<noteq> Main; (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')\n 7. \\<And>insa outsa ca p' es' rets' psa.\n       \\<lbrakk>(q, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs c psa q; q = Main; q \\<noteq> Main;\n        (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>et'.\n                            prog,procs \\<turnstile> (q,\n               n) -et'\\<rightarrow> (p, n')", "qed auto"], ["", "fun lift_edge :: \"edge \\<Rightarrow> pname \\<Rightarrow> edge\"\nwhere \"lift_edge a p = ((p,snd(sourcenode a)),kind a,(p,snd(targetnode a)))\""], ["", "fun lift_path :: \"edge list \\<Rightarrow> pname \\<Rightarrow> edge list\"\n  where \"lift_path as p = map (\\<lambda>a. lift_edge a p) as\""], ["", "lemma lift_path_Proc: \n  assumes \"Rep_wf_prog wfp' = (c,procs)\" and \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"containsCall procs prog ps p\"\n  shows \"\\<lbrakk>wfp' \\<turnstile> (Main,n) -as\\<rightarrow>* (Main,n'); \\<forall>a \\<in> set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> wfp \\<turnstile> (p,n) -lift_path as p\\<rightarrow>* (p,n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp' (Main, n) as (Main, n');\n     \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p) (p, n')", "proof(induct \"(Main,n)\" as \"(Main,n')\" arbitrary:n rule:ProcCFG.path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp' (Main, n');\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (p, n') (lift_path [] p) (p, n')\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "case empty_path"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp' (Main, n')\n  \\<forall>a\\<in>set []. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp' (Main, n');\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (p, n') (lift_path [] p) (p, n')\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp' (Main, n');\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (p, n') (lift_path [] p) (p, n')\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge wfp') (Main, n')\\<close>\n    assms wf"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp' (Main, n')\n  Rep_wf_prog wfp' = (c, procs)\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs", "have \"CFG.valid_node sourcenode targetnode (valid_edge wfp) (p,n')\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp' (Main, n')\n  Rep_wf_prog wfp' = (c, procs)\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_node wfp (p, n')", "apply(auto simp:ProcCFG.valid_node_def valid_edge_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ab ba.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (Main, n') -aa\\<rightarrow> (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)\n 2. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (a, b) -aa\\<rightarrow> (Main, n')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)", "apply(case_tac \"ab = Main\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ab ba.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (Main, n') -aa\\<rightarrow> (ab, ba);\n        ab = Main\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)\n 2. \\<And>aa ab ba.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (Main, n') -aa\\<rightarrow> (ab, ba);\n        ab \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)\n 3. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (a, b) -aa\\<rightarrow> (Main, n')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)", "apply(fastforce dest:lift_edge_Main_Main)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ab ba.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (Main, n') -aa\\<rightarrow> (ab, ba);\n        ab \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)\n 2. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (a, b) -aa\\<rightarrow> (Main, n')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)", "apply(fastforce dest!:lift_edge_Main_Proc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (a, b) -aa\\<rightarrow> (Main, n')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)", "apply(case_tac \"a = Main\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (a, b) -aa\\<rightarrow> (Main, n');\n        a = Main\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)\n 2. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (a, b) -aa\\<rightarrow> (Main, n');\n        a \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)", "apply(fastforce dest:lift_edge_Main_Main)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa.\n       \\<lbrakk>Rep_wf_prog wfp' = (c, procs);\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; well_formed procs;\n        c,procs \\<turnstile> (a, b) -aa\\<rightarrow> (Main, n');\n        a \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b aa ab ba.\n                            prog,procs \\<turnstile> (a,\n               b) -aa\\<rightarrow> (ab, ba) \\<and>\n                            (p = a \\<and> n' = b \\<or>\n                             p = ab \\<and> n' = ba)", "by(fastforce dest!:lift_edge_Proc_Main)"], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp (p, n')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.valid_node wfp' (Main, n');\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (p, n') (lift_path [] p) (p, n')\n 2. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "thus ?case"], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp (p, n')\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p, n') (lift_path [] p) (p, n')", "by(fastforce dest:ProcCFG.empty_path)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p, n') (lift_path [] p) (p, n')\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "case (Cons_path m'' as a n)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' m'' as (Main, n')\n  \\<lbrakk>m'' = (Main, ?n);\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp (p, ?n) (lift_path as p) (p, n')\n  valid_edge wfp' a\n  sourcenode a = (Main, n)\n  targetnode a = m''\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "note IH = \\<open>\\<And>n. \\<lbrakk>m'' = (Main, n); \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> wfp \\<turnstile> (p, n) -lift_path as p\\<rightarrow>* (p, n')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>m'' = (Main, ?n);\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.path wfp (p, ?n) (lift_path as p) (p, n')\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"intra_kind (kind a)\"\n    and \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a) &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "from \\<open>valid_edge wfp' a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>sourcenode a = (Main, n)\\<close> \n    \\<open>targetnode a = m''\\<close> \\<open>Rep_wf_prog wfp' = (c,procs)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp' a\n  intra_kind (kind a)\n  sourcenode a = (Main, n)\n  targetnode a = m''\n  Rep_wf_prog wfp' = (c, procs)", "obtain n'' where \"m'' = (Main, n'')\""], ["proof (prove)\nusing this:\n  valid_edge wfp' a\n  intra_kind (kind a)\n  sourcenode a = (Main, n)\n  targetnode a = m''\n  Rep_wf_prog wfp' = (c, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        m'' = (Main, n'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:PCFG.cases simp:valid_edge_def intra_kind_def)"], ["proof (state)\nthis:\n  m'' = (Main, n'')\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "with \\<open>valid_edge wfp' a\\<close> \\<open>Rep_wf_prog wfp' = (c,procs)\\<close>\n    \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = m''\\<close>\n    \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>containsCall procs prog ps p\\<close> \n    \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp' a\n  Rep_wf_prog wfp' = (c, procs)\n  sourcenode a = (Main, n)\n  targetnode a = m''\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  Rep_wf_prog wfp = (prog, procs)\n  well_formed procs\n  m'' = (Main, n'')", "have \"prog,procs \\<turnstile> (p, n) -kind a\\<rightarrow> (p, n'')\""], ["proof (prove)\nusing this:\n  valid_edge wfp' a\n  Rep_wf_prog wfp' = (c, procs)\n  sourcenode a = (Main, n)\n  targetnode a = m''\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  Rep_wf_prog wfp = (prog, procs)\n  well_formed procs\n  m'' = (Main, n'')\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p, n) -kind a\\<rightarrow> (p, n'')", "by(auto intro:lift_edge_Main_Main simp:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p, n) -kind a\\<rightarrow> (p, n'')\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "from IH[OF \\<open>m'' = (Main, n'')\\<close> \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close>]"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (p, n'') (lift_path as p) (p, n')", "have \"wfp \\<turnstile> (p, n'') -lift_path as p\\<rightarrow>* (p, n')\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (p, n'') (lift_path as p) (p, n')\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p, n'') (lift_path as p) (p, n')", "."], ["proof (state)\nthis:\n  ProcCFG.path wfp (p, n'') (lift_path as p) (p, n')\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n.\n       \\<lbrakk>ProcCFG.path wfp' n'' as (Main, n');\n        \\<And>n.\n           \\<lbrakk>n'' = (Main, n);\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path as p)\n                              (p, n');\n        valid_edge wfp' a; sourcenode a = (Main, n); targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.path wfp (p, n) (lift_path (a # as) p)\n                          (p, n')", "with \\<open>prog,procs \\<turnstile> (p, n) -kind a\\<rightarrow> (p, n'')\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>\n    \\<open>sourcenode a = (Main, n)\\<close> \\<open>targetnode a = m''\\<close> \\<open>m'' = (Main, n'')\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> (p, n) -kind a\\<rightarrow> (p, n'')\n  Rep_wf_prog wfp = (prog, procs)\n  sourcenode a = (Main, n)\n  targetnode a = m''\n  m'' = (Main, n'')\n  ProcCFG.path wfp (p, n'') (lift_path as p) (p, n')", "show ?case"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (p, n) -kind a\\<rightarrow> (p, n'')\n  Rep_wf_prog wfp = (prog, procs)\n  sourcenode a = (Main, n)\n  targetnode a = m''\n  m'' = (Main, n'')\n  ProcCFG.path wfp (p, n'') (lift_path as p) (p, n')\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p, n) (lift_path (a # as) p) (p, n')", "by simp (rule ProcCFG.Cons_path,auto simp:valid_edge_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p, n) (lift_path (a # as) p) (p, n')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Existence of paths from Entry and to Exit\\<close>"], ["", "lemma Label_Proc_CFG_Entry_Exit_path_Proc:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\" and \"l < #:c\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"containsCall procs prog ps p\"\n  obtains as as' where \"wfp \\<turnstile> (p,Label l) -as\\<rightarrow>* (p,Exit)\"\n  and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n  and \"wfp \\<turnstile> (p,Entry) -as'\\<rightarrow>* (p,Label l)\"\n  and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (p, Label l) as (p, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (p, Entry) as' (p, Label l);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close>\n    \\<open>containsCall procs prog ps p\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p", "obtain wfp' where \"Rep_wf_prog wfp' = (c,procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_Call)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp' = (c, procs)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from this \\<open>l < #:c\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp' = (c, procs)\n  l < #:c", "obtain as as' where \"wfp' \\<turnstile> (Main,Label l) -as\\<rightarrow>* (Main,Exit)\"\n    and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n    and \"wfp' \\<turnstile> (Main,Entry) -as'\\<rightarrow>* (Main,Label l)\"\n    and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp' = (c, procs)\n  l < #:c\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp' (Main, Label l) as (Main, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp' (Main, Entry) as' (Main, Label l);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule Label_Proc_CFG_Entry_Exit_path_Main)"], ["proof (state)\nthis:\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp' = (c,procs)\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>\n    \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>containsCall procs prog ps p\\<close>\n    \\<open>wfp' \\<turnstile> (Main,Label l) -as\\<rightarrow>* (Main,Exit)\\<close> \\<open>\\<forall>a \\<in> set as. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp' = (c, procs)\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"wfp \\<turnstile> (p,Label l) -lift_path as p\\<rightarrow>* (p,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp' = (c, procs)\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  ProcCFG.path wfp' (Main, Label l) as (Main, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p, Label l) (lift_path as p) (p, Exit)", "by(fastforce intro:lift_path_Proc)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p, Label l) (lift_path as p) (p, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p, Label l) (lift_path as p) (p, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>Rep_wf_prog wfp' = (c,procs)\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>\n    \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>containsCall procs prog ps p\\<close>\n    \\<open>wfp' \\<turnstile> (Main,Entry) -as'\\<rightarrow>* (Main,Label l)\\<close> \\<open>\\<forall>a \\<in> set as'. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp' = (c, procs)\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)", "have \"wfp \\<turnstile> (p,Entry) -lift_path as' p\\<rightarrow>* (p,Label l)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp' = (c, procs)\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n  ProcCFG.path wfp' (Main, Entry) as' (Main, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p, Entry) (lift_path as' p) (p, Label l)", "by(fastforce intro:lift_path_Proc)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p, Entry) (lift_path as' p) (p, Label l)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p, Entry) (lift_path as' p) (p, Label l)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "from \\<open>\\<forall>a \\<in> set as. intra_kind (kind a)\\<close> \\<open>\\<forall>a \\<in> set as'. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)", "have \"\\<forall>a \\<in> set (lift_path as p). intra_kind (kind a)\"\n    and \"\\<forall>a \\<in> set (lift_path as' p). intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (lift_path as p). intra_kind (kind a) &&&\n    \\<forall>a\\<in>set (lift_path as' p). intra_kind (kind a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (lift_path as p). intra_kind (kind a)\n  \\<forall>a\\<in>set (lift_path as' p). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (p, Label l) (lift_path as p) (p, Exit)\n  ProcCFG.path wfp (p, Entry) (lift_path as' p) (p, Label l)\n  \\<forall>a\\<in>set (lift_path as p). intra_kind (kind a)\n  \\<forall>a\\<in>set (lift_path as' p). intra_kind (kind a)", "show \"\\<exists>as as'. wfp \\<turnstile> (p, Label l) -as\\<rightarrow>* (p, Exit) \\<and>\n    (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and> wfp \\<turnstile> (p, Entry) -as'\\<rightarrow>* (p, Label l) \\<and>\n    (\\<forall>a\\<in>set as'. intra_kind (kind a))\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (p, Label l) (lift_path as p) (p, Exit)\n  ProcCFG.path wfp (p, Entry) (lift_path as' p) (p, Label l)\n  \\<forall>a\\<in>set (lift_path as p). intra_kind (kind a)\n  \\<forall>a\\<in>set (lift_path as' p). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n       (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n       ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n       (\\<forall>a\\<in>set as'. intra_kind (kind a))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.path wfp (p, Label l) as (p, Exit) \\<and>\n     (\\<forall>a\\<in>set as. intra_kind (kind a)) \\<and>\n     ProcCFG.path wfp (p, Entry) as' (p, Label l) \\<and>\n     (\\<forall>a\\<in>set as'. intra_kind (kind a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Entry_to_Entry_and_Exit_to_Exit: \n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"containsCall procs prog ps p\" and \"(p,ins,outs,c) \\<in> set procs\"\n  obtains as as' where \"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (Main,Entry) as (p,Entry)\"\n  and \"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (p,Exit) as' (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry);\n         ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n       ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)", "from \\<open>containsCall procs prog ps p\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs", "show \"\\<exists>as as'. CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n    (get_return_edges wfp) (Main, Entry) as (p, Entry) \\<and>\n    CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n    (get_return_edges wfp) (p, Exit) as' (Main, Exit)\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n       ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)", "proof(induct ps arbitrary:p ins outs c rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "case Nil"], ["proof (state)\nthis:\n  containsCall procs prog [] p\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>containsCall procs prog [] p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog [] p", "obtain lx es rets lx' where \"prog \\<turnstile> Label lx -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label lx'\""], ["proof (prove)\nusing this:\n  containsCall procs prog [] p\n\ngoal (1 subgoal):\n 1. (\\<And>lx es rets lx'.\n        prog \\<turnstile> Label\n                           lx -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label\n                       lx' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule containsCall_empty_Proc_CFG_Call_edge)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  prog \\<turnstile> Label\n                     lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'", "have \"prog,procs \\<turnstile> (Main,Label lx) -(\\<lambda>s. True):(Main,Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>\n      map (\\<lambda>e cf. interpret e cf) es\\<rightarrow>  (p,Entry)\" \n      and \"prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (Main,Label lx'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label lx')\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  prog \\<turnstile> Label\n                     lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (Main,\n                             Label\n                              lx) -\\<lambda>s.\nTrue:(Main,\n      Label\n       lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n        es\\<rightarrow> (p, Entry) &&&\n    prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n    snd cf =\n    (Main,\n     Label\n      lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (Main, Label lx')", "by -(rule MainCall,assumption+,rule MainReturn)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            lx) -\\<lambda>s.\n                                    True:(Main,\n    Label\n     lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      es\\<rightarrow> (p, Entry)\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n      map cf outs)\\<rightarrow> (Main, Label lx')\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            lx) -\\<lambda>s.\n                                    True:(Main,\n    Label\n     lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      es\\<rightarrow> (p, Entry)\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n      map cf outs)\\<rightarrow> (Main, Label lx')", "have \"wfp \\<turnstile> (Main,Label lx) -[((Main,Label lx),\n      (\\<lambda>s. True):(Main,Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es,(p,Entry))]\\<rightarrow>* \n      (p,Entry)\"\n      and \"wfp \\<turnstile> (p,Exit) -[((p,Exit),(\\<lambda>cf. snd cf = (Main,Label lx'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs)),(Main,Label lx'))]\\<rightarrow>* (Main,Label lx')\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  prog,procs \\<turnstile> (Main,\n                           Label\n                            lx) -\\<lambda>s.\n                                    True:(Main,\n    Label\n     lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      es\\<rightarrow> (p, Entry)\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (Main,\n   Label\n    lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n      map cf outs)\\<rightarrow> (Main, Label lx')\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Label lx)\n     [((Main, Label lx),\n       \\<lambda>s.\n          True:(Main,\n                Label\n                 lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n       p, Entry)]\n     (p, Entry) &&&\n    ProcCFG.path wfp (p, Exit)\n     [((p, Exit),\n       \\<lambda>cf.\n          snd cf =\n          (Main,\n           Label\n            lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs),\n       Main, Label lx')]\n     (Main, Label lx')", "by(fastforce intro:ProcCFG.path.intros \n        simp:ProcCFG.valid_node_def valid_edge_def)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label lx)\n   [((Main, Label lx),\n     \\<lambda>s.\n        True:(Main,\n              Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n     p, Entry)]\n   (p, Entry)\n  ProcCFG.path wfp (p, Exit)\n   [((p, Exit),\n     \\<lambda>cf.\n        snd cf =\n        (Main,\n         Label\n          lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs),\n     Main, Label lx')]\n   (Main, Label lx')\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label lx)\n   [((Main, Label lx),\n     \\<lambda>s.\n        True:(Main,\n              Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n     p, Entry)]\n   (p, Entry)\n  ProcCFG.path wfp (p, Exit)\n   [((p, Exit),\n     \\<lambda>cf.\n        snd cf =\n        (Main,\n         Label\n          lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs),\n     Main, Label lx')]\n   (Main, Label lx')\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>prog \\<turnstile> Label lx -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label lx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'", "have \"lx < #:prog\" and \"lx' < #:prog\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'\n\ngoal (1 subgoal):\n 1. lx < #:prog &&& lx' < #:prog", "by(auto intro:Proc_CFG_sourcelabel_less_num_nodes \n                    Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  lx < #:prog\n  lx' < #:prog\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>lx < #:prog\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  lx < #:prog", "obtain as \n      where \"wfp \\<turnstile> (Main,Entry) -as\\<rightarrow>* (Main,Label lx)\"\n      and \"\\<forall>a \\<in> set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  lx < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label lx);\n         \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Main)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label lx)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label lx)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>lx' < #:prog\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  lx' < #:prog", "obtain as' \n      where \"wfp \\<turnstile> (Main,Label lx') -as'\\<rightarrow>* (Main,Exit)\"\n      and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  lx' < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>ProcCFG.path wfp (Main, Label lx') as' (Main, Exit);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Main)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label lx') as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Label lx') as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>\\<forall>a \\<in> set as. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"CFG.valid_path kind (get_return_edges wfp) \n      (as@[((Main,Label lx),(\\<lambda>s. True):(Main,Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>\n      map (\\<lambda>e cf. interpret e cf) es,(p,Entry))])\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path wfp\n     (as @\n      [((Main, Label lx),\n        \\<lambda>s.\n           True:(Main,\n                 Label\n                  lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n        p, Entry)])", "by(fastforce intro:ProcCFG.same_level_path_valid_path_Append \n        ProcCFG.intras_same_level_path simp:ProcCFG.valid_path_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_path wfp\n   (as @\n    [((Main, Label lx),\n      \\<lambda>s.\n         True:(Main,\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.valid_path wfp\n   (as @\n    [((Main, Label lx),\n      \\<lambda>s.\n         True:(Main,\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>\\<forall>a \\<in> set as'. intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as'. intra_kind (kind a)", "have \"CFG.valid_path kind (get_return_edges wfp) \n      ([((p,Exit),(\\<lambda>cf. snd cf = (Main,Label lx'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs)),(Main,Label lx'))]@as')\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path wfp\n     ([((p, Exit),\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs),\n        Main, Label lx')] @\n      as')", "by(fastforce intro:ProcCFG.valid_path_same_level_path_Append \n        ProcCFG.intras_same_level_path simp:ProcCFG.valid_path_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_path wfp\n   ([((p, Exit),\n      \\<lambda>cf.\n         snd cf =\n         (Main,\n          Label\n           lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n             [:=] map cf outs),\n      Main, Label lx')] @\n    as')\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs c.\n       \\<lbrakk>containsCall procs prog [] p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)\n 2. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Label lx)\n   [((Main, Label lx),\n     \\<lambda>s.\n        True:(Main,\n              Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n     p, Entry)]\n   (p, Entry)\n  ProcCFG.path wfp (p, Exit)\n   [((p, Exit),\n     \\<lambda>cf.\n        snd cf =\n        (Main,\n         Label\n          lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs),\n     Main, Label lx')]\n   (Main, Label lx')\n  ProcCFG.path wfp (Main, Entry) as (Main, Label lx)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label lx') as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path wfp\n   (as @\n    [((Main, Label lx),\n      \\<lambda>s.\n         True:(Main,\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n  ProcCFG.valid_path wfp\n   ([((p, Exit),\n      \\<lambda>cf.\n         snd cf =\n         (Main,\n          Label\n           lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n             [:=] map cf outs),\n      Main, Label lx')] @\n    as')", "show ?case"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Label lx)\n   [((Main, Label lx),\n     \\<lambda>s.\n        True:(Main,\n              Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n     p, Entry)]\n   (p, Entry)\n  ProcCFG.path wfp (p, Exit)\n   [((p, Exit),\n     \\<lambda>cf.\n        snd cf =\n        (Main,\n         Label\n          lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs),\n     Main, Label lx')]\n   (Main, Label lx')\n  ProcCFG.path wfp (Main, Entry) as (Main, Label lx)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label lx') as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path wfp\n   (as @\n    [((Main, Label lx),\n      \\<lambda>s.\n         True:(Main,\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n  ProcCFG.valid_path wfp\n   ([((p, Exit),\n      \\<lambda>cf.\n         snd cf =\n         (Main,\n          Label\n           lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n             [:=] map cf outs),\n      Main, Label lx')] @\n    as')\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n       ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)", "by(fastforce intro:ProcCFG.path_Append simp:ProcCFG.vp_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n     ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "case (snoc p' ps')"], ["proof (state)\nthis:\n  \\<lbrakk>containsCall procs prog ps' ?p;\n   (?p, ?ins, ?outs, ?c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.valid_path' wfp (Main, Entry) as\n                        (?p, Entry) \\<and>\n                       ProcCFG.valid_path' wfp (?p, Exit) as' (Main, Exit)\n  containsCall procs prog (ps' @ [p']) p\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "note IH = \\<open>\\<And>p ins outs c. \n      \\<lbrakk>containsCall procs prog ps' p; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n      \\<Longrightarrow> \\<exists>as as'. CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n      (get_return_edges wfp) (Main, Entry) as (p, Entry) \\<and>\n      CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n      (get_return_edges wfp) (p, Exit) as' (Main, Exit)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>containsCall procs prog ps' ?p;\n   (?p, ?ins, ?outs, ?c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as as'.\n                       ProcCFG.valid_path' wfp (Main, Entry) as\n                        (?p, Entry) \\<and>\n                       ProcCFG.valid_path' wfp (?p, Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>containsCall procs prog (ps' @ [p']) p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog (ps' @ [p']) p", "obtain ins' outs' c' where \"(p',ins',outs',c') \\<in> set procs\"\n      and \"containsCall procs c' [] p\" \n      and \"containsCall procs prog ps' p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog (ps' @ [p']) p\n\ngoal (1 subgoal):\n 1. (\\<And>ins' outs' c'.\n        \\<lbrakk>(p', ins', outs', c') \\<in> set procs;\n         containsCall procs c' [] p; containsCall procs prog ps' p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:containsCallE)"], ["proof (state)\nthis:\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs c' [] p\n  containsCall procs prog ps' p'\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from IH[OF \\<open>containsCall procs prog ps' p'\\<close> \\<open>(p',ins',outs',c') \\<in> set procs\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry) \\<and>\n     ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)", "obtain as as' where pathE:\"CFG.valid_path' sourcenode targetnode kind \n      (valid_edge wfp) (get_return_edges wfp) (Main, Entry) as (p', Entry)\"\n      and pathX:\"CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n      (get_return_edges wfp) (p', Exit) as' (Main, Exit)\""], ["proof (prove)\nusing this:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry) \\<and>\n     ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry);\n         ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>containsCall procs c' [] p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs c' [] p", "obtain lx es rets lx' where edge:\"c' \\<turnstile> Label lx -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label lx'\""], ["proof (prove)\nusing this:\n  containsCall procs c' [] p\n\ngoal (1 subgoal):\n 1. (\\<And>lx es rets lx'.\n        c' \\<turnstile> Label\n                         lx -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     lx' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule containsCall_empty_Proc_CFG_Call_edge)"], ["proof (state)\nthis:\n  c' \\<turnstile> Label\n                   lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "hence \"lx < #:c'\" and \"lx' < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> Label\n                   lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'\n\ngoal (1 subgoal):\n 1. lx < #:c' &&& lx' < #:c'", "by(auto intro:Proc_CFG_sourcelabel_less_num_nodes \n                    Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  lx < #:c'\n  lx' < #:c'\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>lx < #:c'\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(p',ins',outs',c') \\<in> set procs\\<close>\n      \\<open>containsCall procs prog ps' p'\\<close>"], ["proof (chain)\npicking this:\n  lx < #:c'\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps' p'", "obtain asx \n      where \"wfp \\<turnstile> (p',Entry) -asx\\<rightarrow>* (p',Label lx)\"\n      and \"\\<forall>a \\<in> set asx. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  lx < #:c'\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps' p'\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>ProcCFG.path wfp (p', Entry) asx (p', Label lx);\n         \\<forall>a\\<in>set asx. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:Label_Proc_CFG_Entry_Exit_path_Proc)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p', Entry) asx (p', Label lx)\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "with pathE"], ["proof (chain)\npicking this:\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.path wfp (p', Entry) asx (p', Label lx)\n  \\<forall>a\\<in>set asx. intra_kind (kind a)", "have pathE2:\"CFG.valid_path' sourcenode targetnode kind \n      (valid_edge wfp) (get_return_edges wfp) (Main, Entry) (as@asx) (p', Label lx)\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.path wfp (p', Entry) asx (p', Label lx)\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path' wfp (Main, Entry) (as @ asx) (p', Label lx)", "by(fastforce intro:ProcCFG.path_Append ProcCFG.valid_path_same_level_path_Append\n        ProcCFG.intras_same_level_path simp:ProcCFG.vp_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) (as @ asx) (p', Label lx)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from \\<open>lx' < #:c'\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>\n      \\<open>(p',ins',outs',c') \\<in> set procs\\<close> \\<open>containsCall procs prog ps' p'\\<close>"], ["proof (chain)\npicking this:\n  lx' < #:c'\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps' p'", "obtain asx' where \"wfp \\<turnstile> (p',Label lx') -asx'\\<rightarrow>* (p',Exit)\"\n      and \"\\<forall>a \\<in> set asx'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  lx' < #:c'\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps' p'\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>ProcCFG.path wfp (p', Label lx') asx' (p', Exit);\n         \\<forall>a\\<in>set asx'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:Label_Proc_CFG_Entry_Exit_path_Proc)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p', Label lx') asx' (p', Exit)\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "with pathX"], ["proof (chain)\npicking this:\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n  ProcCFG.path wfp (p', Label lx') asx' (p', Exit)\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)", "have pathX2:\"CFG.valid_path' sourcenode targetnode kind \n      (valid_edge wfp) (get_return_edges wfp) (p', Label lx') (asx'@as') (Main, Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n  ProcCFG.path wfp (p', Label lx') asx' (p', Exit)\n  \\<forall>a\\<in>set asx'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path' wfp (p', Label lx') (asx' @ as') (Main, Exit)", "by(fastforce intro:ProcCFG.path_Append ProcCFG.same_level_path_valid_path_Append\n        ProcCFG.intras_same_level_path simp:ProcCFG.vp_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (p', Label lx') (asx' @ as') (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from edge \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>(p',ins',outs',c') \\<in> set procs\\<close>\n      \\<open>containsCall procs prog ps' p'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> Label\n                   lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps' p'", "have \"prog,procs \\<turnstile> (p',Label lx) -(\\<lambda>s. True):(p',Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>\n      map (\\<lambda>e cf. interpret e cf) es\\<rightarrow> (p,Entry)\"\n      and \"prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (p',Label lx'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (p',Label lx')\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> Label\n                   lx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label lx'\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps' p'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p',\n                             Label\n                              lx) -\\<lambda>s.\nTrue:(p',\n      Label\n       lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n        es\\<rightarrow> (p, Entry) &&&\n    prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n    snd cf =\n    (p',\n     Label\n      lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\\<rightarrow> (p', Label lx')", "by(fastforce intro:ProcCall ProcReturn)+"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p',\n                           Label\n                            lx) -\\<lambda>s.\n                                    True:(p',\n    Label\n     lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      es\\<rightarrow> (p, Entry)\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n      map cf outs)\\<rightarrow> (p', Label lx')\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  prog,procs \\<turnstile> (p',\n                           Label\n                            lx) -\\<lambda>s.\n                                    True:(p',\n    Label\n     lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      es\\<rightarrow> (p, Entry)\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n      map cf outs)\\<rightarrow> (p', Label lx')", "have path:\"wfp \\<turnstile> (p',Label lx) -[((p',Label lx),(\\<lambda>s. True):(p',Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>\n      map (\\<lambda>e cf. interpret e cf) es,(p,Entry))]\\<rightarrow>* (p,Entry)\"\n      and path':\"wfp \\<turnstile> (p,Exit) -[((p,Exit),(\\<lambda>cf. snd cf = (p',Label lx'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs)),(p',Label lx'))]\\<rightarrow>* \n      (p',Label lx')\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  prog,procs \\<turnstile> (p',\n                           Label\n                            lx) -\\<lambda>s.\n                                    True:(p',\n    Label\n     lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n      es\\<rightarrow> (p, Entry)\n  prog,procs \\<turnstile> (p, Exit) -\\<lambda>cf.\n  snd cf =\n  (p',\n   Label\n    lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n      map cf outs)\\<rightarrow> (p', Label lx')\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p', Label lx)\n     [((p', Label lx),\n       \\<lambda>s.\n          True:(p',\n                Label\n                 lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n       p, Entry)]\n     (p, Entry) &&&\n    ProcCFG.path wfp (p, Exit)\n     [((p, Exit),\n       \\<lambda>cf.\n          snd cf =\n          (p',\n           Label\n            lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs),\n       p', Label lx')]\n     (p', Label lx')", "by(fastforce intro:ProcCFG.path.intros \n                  simp:ProcCFG.valid_node_def valid_edge_def)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p', Label lx)\n   [((p', Label lx),\n     \\<lambda>s.\n        True:(p',\n              Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n     p, Entry)]\n   (p, Entry)\n  ProcCFG.path wfp (p, Exit)\n   [((p, Exit),\n     \\<lambda>cf.\n        snd cf =\n        (p',\n         Label\n          lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs),\n     p', Label lx')]\n   (p', Label lx')\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from path pathE2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (p', Label lx)\n   [((p', Label lx),\n     \\<lambda>s.\n        True:(p',\n              Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n     p, Entry)]\n   (p, Entry)\n  ProcCFG.valid_path' wfp (Main, Entry) (as @ asx) (p', Label lx)", "have \"CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n      (get_return_edges wfp) (Main, Entry) ((as@asx)@[((p',Label lx),\n      (\\<lambda>s. True):(p',Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es,(p,Entry))])\n      (p,Entry)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (p', Label lx)\n   [((p', Label lx),\n     \\<lambda>s.\n        True:(p',\n              Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n     p, Entry)]\n   (p, Entry)\n  ProcCFG.valid_path' wfp (Main, Entry) (as @ asx) (p', Label lx)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path' wfp (Main, Entry)\n     ((as @ asx) @\n      [((p', Label lx),\n        \\<lambda>s.\n           True:(p',\n                 Label\n                  lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n        p, Entry)])\n     (p, Entry)", "apply(unfold ProcCFG.vp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Label lx)\n              [((p', Label lx),\n                \\<lambda>s.\n                   True:(p',\n                         Label\n                          lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                           interpret es,\n                p, Entry)]\n              (p, Entry);\n     ProcCFG.path wfp (Main, Entry) (as @ asx) (p', Label lx) \\<and>\n     ProcCFG.valid_path wfp (as @ asx)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (Main, Entry)\n                       ((as @ asx) @\n                        [((p', Label lx),\n                          \\<lambda>s.\n                             True:(p',\n                                   Label\n                                    lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es,\n                          p, Entry)])\n                       (p, Entry) \\<and>\n                      ProcCFG.valid_path wfp\n                       ((as @ asx) @\n                        [((p', Label lx),\n                          \\<lambda>s.\n                             True:(p',\n                                   Label\n                                    lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es,\n                          p, Entry)])", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Label lx)\n              [((p', Label lx),\n                \\<lambda>s.\n                   True:(p',\n                         Label\n                          lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                           interpret es,\n                p, Entry)]\n              (p, Entry);\n     ProcCFG.path wfp (Main, Entry) (as @ asx) (p', Label lx) \\<and>\n     ProcCFG.valid_path wfp (as @ asx)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (Main, Entry)\n                       ((as @ asx) @\n                        [((p', Label lx),\n                          \\<lambda>s.\n                             True:(p',\n                                   Label\n                                    lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es,\n                          p, Entry)])\n                       (p, Entry)\n 2. \\<lbrakk>ProcCFG.path wfp (p', Label lx)\n              [((p', Label lx),\n                \\<lambda>s.\n                   True:(p',\n                         Label\n                          lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                           interpret es,\n                p, Entry)]\n              (p, Entry);\n     ProcCFG.path wfp (Main, Entry) (as @ asx) (p', Label lx) \\<and>\n     ProcCFG.valid_path wfp (as @ asx)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path wfp\n                       ((as @ asx) @\n                        [((p', Label lx),\n                          \\<lambda>s.\n                             True:(p',\n                                   Label\n                                    lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es,\n                          p, Entry)])", "apply(fastforce intro:ProcCFG.path_Append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Label lx)\n              [((p', Label lx),\n                \\<lambda>s.\n                   True:(p',\n                         Label\n                          lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                           interpret es,\n                p, Entry)]\n              (p, Entry);\n     ProcCFG.path wfp (Main, Entry) (as @ asx) (p', Label lx) \\<and>\n     ProcCFG.valid_path wfp (as @ asx)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path wfp\n                       ((as @ asx) @\n                        [((p', Label lx),\n                          \\<lambda>s.\n                             True:(p',\n                                   Label\n                                    lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es,\n                          p, Entry)])", "by(unfold ProcCFG.valid_path_def,fastforce intro:ProcCFG.vpa_snoc_Call)"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry)\n   ((as @ asx) @\n    [((p', Label lx),\n      \\<lambda>s.\n         True:(p',\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n   (p, Entry)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry)\n   ((as @ asx) @\n    [((p', Label lx),\n      \\<lambda>s.\n         True:(p',\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n   (p, Entry)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "from path' pathX2"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (p, Exit)\n   [((p, Exit),\n     \\<lambda>cf.\n        snd cf =\n        (p',\n         Label\n          lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs),\n     p', Label lx')]\n   (p', Label lx')\n  ProcCFG.valid_path' wfp (p', Label lx') (asx' @ as') (Main, Exit)", "have \"CFG.valid_path' sourcenode targetnode kind \n      (valid_edge wfp) (get_return_edges wfp) (p,Exit)\n      ([((p,Exit),(\\<lambda>cf. snd cf = (p',Label lx'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n      (\\<lambda>cf cf'. cf'(rets [:=] map cf outs)),(p',Label lx'))]@(asx'@as')) (Main, Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (p, Exit)\n   [((p, Exit),\n     \\<lambda>cf.\n        snd cf =\n        (p',\n         Label\n          lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs),\n     p', Label lx')]\n   (p', Label lx')\n  ProcCFG.valid_path' wfp (p', Label lx') (asx' @ as') (Main, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path' wfp (p, Exit)\n     ([((p, Exit),\n        \\<lambda>cf.\n           snd cf =\n           (p',\n            Label\n             lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs),\n        p', Label lx')] @\n      asx' @ as')\n     (Main, Exit)", "apply(unfold ProcCFG.vp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p, Exit)\n              [((p, Exit),\n                \\<lambda>cf.\n                   snd cf =\n                   (p',\n                    Label\n                     lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                       cf'(rets [:=] map cf outs),\n                p', Label lx')]\n              (p', Label lx');\n     ProcCFG.path wfp (p', Label lx') (asx' @ as') (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp (asx' @ as')\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (p, Exit)\n                       ([((p, Exit),\n                          \\<lambda>cf.\n                             snd cf =\n                             (p',\n                              Label\n                               lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                 cf'. cf'(rets [:=] map cf outs),\n                          p', Label lx')] @\n                        asx' @ as')\n                       (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp\n                       ([((p, Exit),\n                          \\<lambda>cf.\n                             snd cf =\n                             (p',\n                              Label\n                               lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                 cf'. cf'(rets [:=] map cf outs),\n                          p', Label lx')] @\n                        asx' @ as')", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp (p, Exit)\n              [((p, Exit),\n                \\<lambda>cf.\n                   snd cf =\n                   (p',\n                    Label\n                     lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                       cf'(rets [:=] map cf outs),\n                p', Label lx')]\n              (p', Label lx');\n     ProcCFG.path wfp (p', Label lx') (asx' @ as') (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp (asx' @ as')\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (p, Exit)\n                       ([((p, Exit),\n                          \\<lambda>cf.\n                             snd cf =\n                             (p',\n                              Label\n                               lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                 cf'. cf'(rets [:=] map cf outs),\n                          p', Label lx')] @\n                        asx' @ as')\n                       (Main, Exit)\n 2. \\<lbrakk>ProcCFG.path wfp (p, Exit)\n              [((p, Exit),\n                \\<lambda>cf.\n                   snd cf =\n                   (p',\n                    Label\n                     lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                       cf'(rets [:=] map cf outs),\n                p', Label lx')]\n              (p', Label lx');\n     ProcCFG.path wfp (p', Label lx') (asx' @ as') (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp (asx' @ as')\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path wfp\n                       ([((p, Exit),\n                          \\<lambda>cf.\n                             snd cf =\n                             (p',\n                              Label\n                               lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                 cf'. cf'(rets [:=] map cf outs),\n                          p', Label lx')] @\n                        asx' @ as')", "apply(fastforce intro:ProcCFG.path_Append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p, Exit)\n              [((p, Exit),\n                \\<lambda>cf.\n                   snd cf =\n                   (p',\n                    Label\n                     lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                       cf'(rets [:=] map cf outs),\n                p', Label lx')]\n              (p', Label lx');\n     ProcCFG.path wfp (p', Label lx') (asx' @ as') (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp (asx' @ as')\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path wfp\n                       ([((p, Exit),\n                          \\<lambda>cf.\n                             snd cf =\n                             (p',\n                              Label\n                               lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                 cf'. cf'(rets [:=] map cf outs),\n                          p', Label lx')] @\n                        asx' @ as')", "by(simp add:ProcCFG.valid_path_def ProcCFG.valid_path_def)"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (p, Exit)\n   ([((p, Exit),\n      \\<lambda>cf.\n         snd cf =\n         (p',\n          Label\n           lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n             [:=] map cf outs),\n      p', Label lx')] @\n    asx' @ as')\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>x xs p ins outs c.\n       \\<lbrakk>\\<And>p ins outs c.\n                   \\<lbrakk>containsCall procs prog xs p;\n                    (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as as'.\n  ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n  ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit);\n        containsCall procs prog (xs @ [x]) p;\n        (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, Entry) \\<and>\n                            ProcCFG.valid_path' wfp (p, Exit) as'\n                             (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.valid_path' wfp (Main, Entry)\n   ((as @ asx) @\n    [((p', Label lx),\n      \\<lambda>s.\n         True:(p',\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n   (p, Entry)\n  ProcCFG.valid_path' wfp (p, Exit)\n   ([((p, Exit),\n      \\<lambda>cf.\n         snd cf =\n         (p',\n          Label\n           lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n             [:=] map cf outs),\n      p', Label lx')] @\n    asx' @ as')\n   (Main, Exit)", "show ?case"], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (Main, Entry)\n   ((as @ asx) @\n    [((p', Label lx),\n      \\<lambda>s.\n         True:(p',\n               Label lx')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es,\n      p, Entry)])\n   (p, Entry)\n  ProcCFG.valid_path' wfp (p, Exit)\n   ([((p, Exit),\n      \\<lambda>cf.\n         snd cf =\n         (p',\n          Label\n           lx')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n             [:=] map cf outs),\n      p', Label lx')] @\n    asx' @ as')\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n       ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n     ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, Entry) \\<and>\n     ProcCFG.valid_path' wfp (p, Exit) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma edge_valid_paths:\n  assumes \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\"\n  and disj:\"(p,n) = sourcenode a \\<or> (p,n) = targetnode a\" \n  and [simp]:\"Rep_wf_prog wfp = (prog,procs)\"\n  shows \"\\<exists>as as'. CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n                (get_return_edges wfp) (Main,Entry) as (p,n) \\<and>\n              CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n                (get_return_edges wfp) (p,n) as' (Main,Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "show ?thesis"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 8. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (Main nx nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (Main, nx') = targetnode a\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 8. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym] \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]\n      disj"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a", "have [simp]:\"p = Main\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. p = Main", "by auto"], ["proof (state)\nthis:\n  p = Main\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 8. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "have \"prog,procs \\<turnstile> (Main, Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main, Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (Main,\n                             Entry) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (Main, Exit)", "by(fastforce intro:PCFG.Main Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (Main,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (Main, Exit)\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 8. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence EXpath:\"wfp \\<turnstile> (Main,Entry) -[((Main,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(Main,Exit))]\\<rightarrow>*\n        (Main,Exit)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (Main,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (Main, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry)\n     [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n     (Main, Exit)", "by(fastforce intro:ProcCFG.path.intros\n        simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n   (Main, Exit)\n\ngoal (8 subgoals):\n 1. \\<And>na n'.\n       \\<lbrakk>prog \\<turnstile> na -IEdge\n (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 8. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close> \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym]\n        \\<open>(Main, nx') = targetnode a\\<close>[THEN sym] disj"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  n = Label l", "have \"l < #:prog\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(auto intro:Proc_CFG_sourcelabel_less_num_nodes\n        Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:prog", "obtain as as' where \"wfp \\<turnstile> (Main,Entry) -as\\<rightarrow>* (Main,Label l)\"\n        and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n        and \"wfp \\<turnstile> (Main,Label l) -as'\\<rightarrow>* (Main,Exit)\"\n        and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Main)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l) as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with Label"], ["proof (chain)\npicking this:\n  n = Label l\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l) as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Label l\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l) as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = Label l; ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry) as\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = Label l; ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = Label l; ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) as\n                       (Main, Label l) \\<and>\n                      ProcCFG.valid_path' wfp (Main, Label l) as'\n                       (Main, Exit)", "by(fastforce intro:ProcCFG.intra_path_vp simp:ProcCFG.intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence \"wfp \\<turnstile> (Main,Entry) -[]\\<rightarrow>* (Main,n)\""], ["proof (prove)\nusing this:\n  n = Entry\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, Entry) [] (Main, n)", "by(fastforce intro:ProcCFG.empty_path)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) [] (Main, n)\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with EXpath"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry) [] (Main, n)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, Entry) [] (Main, n)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "by(fastforce simp:ProcCFG.vp_def ProcCFG.valid_path_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence \"wfp \\<turnstile> (Main,n) -[]\\<rightarrow>* (Main,Exit)\""], ["proof (prove)\nusing this:\n  n = Exit\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (Main, n) [] (Main, Exit)", "by(fastforce intro:ProcCFG.empty_path)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, n) [] (Main, Exit)\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with Exit EXpath"], ["proof (chain)\npicking this:\n  n = Exit\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, n) [] (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Exit\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, n) [] (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "using Exit"], ["proof (prove)\nusing this:\n  n = Exit\n  ProcCFG.path wfp (Main, Entry)\n   [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n   (Main, Exit)\n  ProcCFG.path wfp (Main, n) [] (Main, Exit)\n  n = Exit\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"[((Main,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(Main,Exit))]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = Exit;\n     ProcCFG.path wfp (Main, Entry)\n      [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n      (Main, Exit);\n     ProcCFG.path wfp (Main, n) [] (Main, Exit); n = Exit\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry)\n                          [((Main, Entry),\n                            (\\<lambda>s. False)\\<^sub>\\<surd>, Main, Exit)]\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, Entry)\n              [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, Main,\n                Exit)]\n              (Main, Exit);\n     ProcCFG.path wfp (Main, Exit) [] (Main, Exit); n = Exit\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry)\n                       [((Main, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                         Main, Exit)]\n                       (Main, Exit) \\<and>\n                      (\\<exists>as'.\n                          ProcCFG.valid_path' wfp (Main, Exit) as'\n                           (Main, Exit))", "by(fastforce intro:ProcCFG.intra_path_vp \n          simp:ProcCFG.intra_path_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (Proc px ins outs c nx nx' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  containsCall procs prog ps px\n  (px, nx) = sourcenode a\n  (px, nx') = targetnode a\n\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>(px, ins, outs, c) \\<in> set procs\\<close> wf"], ["proof (chain)\npicking this:\n  (px, ins, outs, c) \\<in> set procs\n  well_formed procs", "have [simp]:\"px \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (px, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. px \\<noteq> Main", "by auto"], ["proof (state)\nthis:\n  px \\<noteq> Main\n\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from disj \\<open>(px, nx) = sourcenode a\\<close>[THEN sym] \\<open>(px, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')", "have [simp]:\"p = px\""], ["proof (prove)\nusing this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')\n\ngoal (1 subgoal):\n 1. p = px", "by auto"], ["proof (state)\nthis:\n  p = px\n\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n      \\<open>containsCall procs prog ps px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs", "obtain asx asx' where path:\"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (Main,Entry) asx (px,Entry)\"\n      and path':\"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (px,Exit) asx' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (\\<And>asx asx'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n         ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>containsCall procs prog ps px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs", "have \"prog,procs \\<turnstile> (px, Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (px,\n                             Entry) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)", "by(fastforce intro:PCFG.Proc Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (px,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\n\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence EXpath:\"wfp \\<turnstile> (px,Entry) -[((px,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(px,Exit))]\\<rightarrow>* \n      (px,Exit)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (px,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (px, Entry)\n     [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)", "by(fastforce intro:ProcCFG.path.intros \n        simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n\ngoal (7 subgoals):\n 1. \\<And>pa ins outs c na n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 7. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\\<close> disj \\<open>(px, nx) = sourcenode a\\<close>[THEN sym]\n        \\<open>(px, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')\n  n = Label l", "have \"l < #:c\""], ["proof (prove)\nusing this:\n  c \\<turnstile> nx -IEdge (kind a)\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:c", "by(auto intro:Proc_CFG_sourcelabel_less_num_nodes\n        Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close> \n        \\<open>containsCall procs prog ps px\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  l < #:c", "obtain as as' where \"wfp \\<turnstile> (px,Entry) -as\\<rightarrow>* (px,Label l)\"\n        and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n        and \"wfp \\<turnstile> (px,Label l) -as'\\<rightarrow>* (px,Exit)\"\n        and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  l < #:c\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (px, Entry) as (px, Label l);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (px, Label l) as' (px, Exit);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Proc)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<exists>as as'.\n          ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n          ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with path path'"], ["proof (chain)\npicking this:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "using Label"], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  n = Label l\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"asx@as\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit);\n     ProcCFG.path wfp (px, Entry) as (px, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Label l) as' (px, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a); n = Label l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry) (asx @ as)\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as'@asx'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit);\n     ProcCFG.path wfp (px, Entry) as (px, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Label l) as' (px, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a); n = Label l\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) (asx @ as)\n                       (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) (as' @ asx')\n                       (Main, Exit)", "by(auto intro:ProcCFG.path_Append ProcCFG.valid_path_same_level_path_Append\n          ProcCFG.same_level_path_valid_path_Append ProcCFG.intras_same_level_path\n          simp:ProcCFG.vp_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from EXpath path'"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)", "have \"CFG.valid_path' sourcenode targetnode kind \n        (valid_edge wfp) (get_return_edges wfp) (px,Entry) \n        ([((px,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(px,Exit))]@asx') (Main, Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path' wfp (px, Entry)\n     ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ asx')\n     (Main, Exit)", "apply(unfold ProcCFG.vp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (px, Exit) asx' (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp asx'\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (px, Entry)\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        asx')\n                       (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        asx')", "apply(erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (px, Exit) asx' (Main, Exit);\n     ProcCFG.valid_path wfp asx'\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (px, Entry)\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        asx')\n                       (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        asx')", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (px, Exit) asx' (Main, Exit);\n     ProcCFG.valid_path wfp asx'\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (px, Entry)\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        asx')\n                       (Main, Exit)\n 2. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (px, Exit) asx' (Main, Exit);\n     ProcCFG.valid_path wfp asx'\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path wfp\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        asx')", "by(fastforce intro:ProcCFG.path_Append \n          ProcCFG.same_level_path_valid_path_Append ProcCFG.intras_same_level_path\n          simp:intra_kind_def)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (px, Entry)\n   ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ asx')\n   (Main, Exit)\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with path Entry"], ["proof (chain)\npicking this:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  n = Entry\n  ProcCFG.valid_path' wfp (px, Entry)\n   ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ asx')\n   (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  n = Entry\n  ProcCFG.valid_path' wfp (px, Entry)\n   ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ asx')\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with path EXpath path'"], ["proof (chain)\npicking this:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n  n = Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n  n = Exit\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"asx@[((px,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(px,Exit))]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.path wfp (px, Entry)\n      [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n      (px, Exit);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit); n = Exit\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry)\n                          (asx @\n                           [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                             px, Exit)])\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.path wfp (px, Entry)\n      [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n      (px, Exit);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit); n = Exit\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry)\n                       (asx @\n                        [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)])\n                       (px, Exit) \\<and>\n                      (\\<exists>as'.\n                          ProcCFG.valid_path' wfp (px, Exit) as'\n                           (Main, Exit))", "by(fastforce intro:ProcCFG.path_Append \n          ProcCFG.valid_path_same_level_path_Append ProcCFG.intras_same_level_path\n          simp:ProcCFG.vp_def ProcCFG.intra_path_def intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (6 subgoals):\n 1. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (MainCall l px es rets nx' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (px, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, nx')\\<hookrightarrow>\\<^bsub>px\\<^esub>map interpret es =\n  kind a\n  (px, Entry) = targetnode a\n\ngoal (6 subgoals):\n 1. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 6. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from disj"], ["proof (chain)\npicking this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p,n) = sourcenode a\""], ["proof (state)\nthis:\n  (p, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, Label l)\n  (p, n) = sourcenode a", "have [simp]:\"n = Label l\" \"p = Main\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, Label l)\n  (p, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. n = Label l &&& p = Main", "by simp_all"], ["proof (state)\nthis:\n  n = Label l\n  p = Main\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  n = Label l\n  p = Main", "have \"l < #:prog\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  n = Label l\n  p = Main\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:prog", "obtain as as' where \"wfp \\<turnstile> (Main,Entry) -as\\<rightarrow>* (Main,Label l)\"\n        and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n        and \"wfp \\<turnstile> (Main,Label l) -as'\\<rightarrow>* (Main,Exit)\"\n        and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Main)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l) as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l) as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "by(fastforce intro:ProcCFG.intra_path_vp simp:ProcCFG.intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p,n) = targetnode a\""], ["proof (state)\nthis:\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(px, Entry) = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (px, Entry)\n  (p, n) = targetnode a", "have [simp]:\"n = Entry\" \"p = px\""], ["proof (prove)\nusing this:\n  targetnode a = (px, Entry)\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Entry &&& p = px", "by simp_all"], ["proof (state)\nthis:\n  n = Entry\n  p = px\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'", "have \"containsCall procs prog [] px\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] px", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] px\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px", "obtain as' where Xpath:\"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (px,Exit) as' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        ProcCFG.valid_path' wfp (px, Exit) as'\n         (Main, Exit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>containsCall procs prog [] px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog [] px\n  (px, ins, outs, c) \\<in> set procs", "have \"prog,procs \\<turnstile> (px, Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\""], ["proof (prove)\nusing this:\n  containsCall procs prog [] px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (px,\n                             Entry) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)", "by(fastforce intro:PCFG.Proc Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (px,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence \"wfp \\<turnstile> (px,Entry) -[((px,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(px,Exit))]\\<rightarrow>* (px,Exit)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (px,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (px, Entry)\n     [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)", "by(fastforce intro:ProcCFG.path.intros \n          simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with Xpath"], ["proof (chain)\npicking this:\n  ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)", "have \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (px,Entry) \n        ([((px,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(px,Exit))]@as') (Main,Exit)\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.valid_path' wfp (px, Entry)\n     ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ as')\n     (Main, Exit)", "apply(unfold ProcCFG.vp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Exit) as' (Main, Exit) \\<and>\n             ProcCFG.valid_path wfp as';\n     ProcCFG.path wfp (px, Entry)\n      [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n      (px, Exit)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (px, Entry)\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        as')\n                       (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        as')", "apply(erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (px, Exit) as' (Main, Exit);\n     ProcCFG.valid_path wfp as'\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (px, Entry)\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        as')\n                       (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        as')", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (px, Exit) as' (Main, Exit);\n     ProcCFG.valid_path wfp as'\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.path wfp (px, Entry)\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        as')\n                       (Main, Exit)\n 2. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (px, Exit) as' (Main, Exit);\n     ProcCFG.valid_path wfp as'\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path wfp\n                       ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)] @\n                        as')", "by(fastforce intro:ProcCFG.path_Append \n          ProcCFG.same_level_path_valid_path_Append ProcCFG.intras_same_level_path\n          simp:intra_kind_def)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (px, Entry)\n   ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ as')\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>containsCall procs prog [] px\\<close> \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>\n        \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog [] px\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  ProcCFG.valid_path' wfp (px, Entry)\n   ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ as')\n   (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  containsCall procs prog [] px\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  ProcCFG.valid_path' wfp (px, Entry)\n   ([((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] @ as')\n   (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "by(fastforce elim:Entry_to_Entry_and_Exit_to_Exit)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (5 subgoals):\n 1. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (ProcCall px ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n\ngoal (5 subgoals):\n 1. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 5. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from disj"], ["proof (chain)\npicking this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p,n) = sourcenode a\""], ["proof (state)\nthis:\n  (p, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(px, Label l) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (px, Label l)\n  (p, n) = sourcenode a", "have [simp]:\"n = Label l\" \"p = px\""], ["proof (prove)\nusing this:\n  sourcenode a = (px, Label l)\n  (p, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. n = Label l &&& p = px", "by simp_all"], ["proof (state)\nthis:\n  n = Label l\n  p = px\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  n = Label l\n  p = px", "have \"l < #:c\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  n = Label l\n  p = px\n\ngoal (1 subgoal):\n 1. l < #:c", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>l < #:c\\<close> \n        \\<open>containsCall procs prog ps px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:c\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs", "obtain as as' where \"wfp \\<turnstile> (px,Label l) -as\\<rightarrow>* (px,Exit)\"\n        and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n        and \"wfp \\<turnstile> (px,Entry) -as'\\<rightarrow>* (px,Label l)\"\n        and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:c\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (px, Label l) as (px, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (px, Entry) as' (px, Label l);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Proc)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Label l) as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Label l) as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>containsCall procs prog ps px\\<close>\n        \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs", "obtain asx asx' \n        where\" CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (Main,Entry) asx (px,Entry)\"\n        and \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (px,Exit) asx' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (\\<And>asx asx'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n         ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (px, Label l) as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (px, Label l) as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"asx@as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Label l) as (px, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Entry) as' (px, Label l);\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'a.\n                         ProcCFG.valid_path' wfp (Main, Entry) (asx @ as')\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as'a (Main, Exit)", "apply(rule_tac x=\"as@asx'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Label l) as (px, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Entry) as' (px, Label l);\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) (asx @ as')\n                       (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) (as @ asx')\n                       (Main, Exit)", "by(auto intro:ProcCFG.path_Append ProcCFG.valid_path_same_level_path_Append\n          ProcCFG.same_level_path_valid_path_Append ProcCFG.intras_same_level_path\n          simp:ProcCFG.vp_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p,n) = targetnode a\""], ["proof (state)\nthis:\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(p', Entry) = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (p', Entry)\n  (p, n) = targetnode a", "have [simp]:\"n = Entry\" \"p = p'\""], ["proof (prove)\nusing this:\n  targetnode a = (p', Entry)\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Entry &&& p = p'", "by simp_all"], ["proof (state)\nthis:\n  n = Entry\n  p = p'\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs c [] p'\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs c [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs c [] p'\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>containsCall procs prog ps px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'", "have \"containsCall procs prog (ps@[px]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [px]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'", "have \"prog,procs \\<turnstile> (p', Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)\""], ["proof (prove)\nusing this:\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p',\n                             Entry) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)", "by(fastforce intro:PCFG.Proc Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p',\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence \"wfp \\<turnstile> (p',Entry) -[((p',Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(p',Exit))]\\<rightarrow>* (p',Exit)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (p',\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p', Entry)\n     [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)", "by(fastforce intro:ProcCFG.path.intros \n          simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n        \\<open>containsCall procs prog (ps@[px]) p'\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'", "obtain as as' where \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (Main,Entry) as (p',Entry)\"\n        and \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (p',Exit) as' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry);\n         ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Entry)\n              [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)]\n              (p', Exit);\n     ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry);\n     ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry) as\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"[((p',Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(p',Exit))]@as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Entry)\n              [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)]\n              (p', Exit);\n     ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry);\n     ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n)\n                       ([((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          p', Exit)] @\n                        as')\n                       (Main, Exit)", "apply(unfold ProcCFG.vp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Entry)\n              [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)]\n              (p', Exit);\n     ProcCFG.path wfp (Main, Entry) as (p', Entry) \\<and>\n     ProcCFG.valid_path wfp as;\n     ProcCFG.path wfp (p', Exit) as' (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp as'\\<rbrakk>\n    \\<Longrightarrow> (ProcCFG.path wfp (Main, Entry) as (p, n) \\<and>\n                       ProcCFG.valid_path wfp as) \\<and>\n                      ProcCFG.path wfp (p, n)\n                       ([((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          p', Exit)] @\n                        as')\n                       (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp\n                       ([((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          p', Exit)] @\n                        as')", "by(fastforce intro:ProcCFG.path_Append \n          ProcCFG.same_level_path_valid_path_Append ProcCFG.intras_same_level_path\n          simp:intra_kind_def)+"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (4 subgoals):\n 1. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (MainReturn l px es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px, ins, outs, c) \\<in> set procs\n  (px, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>px\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 4. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from disj"], ["proof (chain)\npicking this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p,n) = sourcenode a\""], ["proof (state)\nthis:\n  (p, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(px, Exit) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (px, Exit)\n  (p, n) = sourcenode a", "have [simp]:\"n = Exit\" \"p = px\""], ["proof (prove)\nusing this:\n  sourcenode a = (px, Exit)\n  (p, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. n = Exit &&& p = px", "by simp_all"], ["proof (state)\nthis:\n  n = Exit\n  p = px\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs prog [] px\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] px", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] px\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px", "have \"prog,procs \\<turnstile> (px, Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\""], ["proof (prove)\nusing this:\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (px,\n                             Entry) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)", "by(fastforce intro:PCFG.Proc Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (px,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence \"wfp \\<turnstile> (px,Entry) -[((px,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(px,Exit))]\\<rightarrow>* (px,Exit)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (px,\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (px, Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (px, Entry)\n     [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)", "by(fastforce intro:ProcCFG.path.intros \n          simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>\n        \\<open>containsCall procs prog [] px\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px", "obtain as as' where \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (Main,Entry) as (px,Entry)\"\n        and \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (px,Exit) as' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog [] px\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) as (px, Entry);\n         ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) as (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n  ProcCFG.valid_path' wfp (Main, Entry) as (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (px, Entry)\n   [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)] (px, Exit)\n  ProcCFG.valid_path' wfp (Main, Entry) as (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as@[((px,Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(px,Exit))]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.valid_path' wfp (Main, Entry) as (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry)\n                          (as @\n                           [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                             px, Exit)])\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.valid_path' wfp (Main, Entry) as (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) as' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry)\n                       (as @\n                        [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          px, Exit)])\n                       (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(unfold ProcCFG.vp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry)\n              [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, px, Exit)]\n              (px, Exit);\n     ProcCFG.path wfp (Main, Entry) as (px, Entry) \\<and>\n     ProcCFG.valid_path wfp as;\n     ProcCFG.path wfp (px, Exit) as' (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp as'\\<rbrakk>\n    \\<Longrightarrow> (ProcCFG.path wfp (Main, Entry)\n                        (as @\n                         [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                           px, Exit)])\n                        (p, n) \\<and>\n                       ProcCFG.valid_path wfp\n                        (as @\n                         [((px, Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                           px, Exit)])) \\<and>\n                      ProcCFG.path wfp (p, n) as' (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp as'", "by(fastforce intro:ProcCFG.path_Append \n          ProcCFG.valid_path_same_level_path_Append ProcCFG.intras_same_level_path\n          simp:intra_kind_def)+"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p, n) = targetnode a\""], ["proof (state)\nthis:\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(Main, Label l') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (Main, Label l')\n  (p, n) = targetnode a", "have [simp]:\"n = Label l'\" \"p = Main\""], ["proof (prove)\nusing this:\n  targetnode a = (Main, Label l')\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l' &&& p = Main", "by simp_all"], ["proof (state)\nthis:\n  n = Label l'\n  p = Main\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  n = Label l'\n  p = Main", "have \"l' < #:prog\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  n = Label l'\n  p = Main\n\ngoal (1 subgoal):\n 1. l' < #:prog", "by(fastforce intro:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:prog\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  l' < #:prog", "obtain as as' where \"wfp \\<turnstile> (Main,Entry) -as\\<rightarrow>* (Main,Label l')\"\n        and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n        and \"wfp \\<turnstile> (Main,Label l') -as'\\<rightarrow>* (Main,Exit)\"\n        and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  l' < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label l');\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (Main, Label l') as' (Main, Exit);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Main)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l')\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l') as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l')\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l') as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "by(fastforce intro:ProcCFG.intra_path_vp simp:ProcCFG.intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (3 subgoals):\n 1. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (ProcReturn px ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n         map cf outs') =\n  kind a\n  (px, Label l') = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 3. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from disj"], ["proof (chain)\npicking this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a", "show ?case"], ["proof (prove)\nusing this:\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p,n) = sourcenode a\""], ["proof (state)\nthis:\n  (p, n) = sourcenode a\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(p', Exit) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (p', Exit)\n  (p, n) = sourcenode a", "have [simp]:\"n = Exit\" \"p = p'\""], ["proof (prove)\nusing this:\n  sourcenode a = (p', Exit)\n  (p, n) = sourcenode a\n\ngoal (1 subgoal):\n 1. n = Exit &&& p = p'", "by simp_all"], ["proof (state)\nthis:\n  n = Exit\n  p = p'\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs c [] p'\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs c [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs c [] p'\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>containsCall procs prog ps px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'", "have \"containsCall procs prog (ps@[px]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [px]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'", "have \"prog,procs \\<turnstile> (p', Entry) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)\""], ["proof (prove)\nusing this:\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> (p',\n                             Entry) -(\\<lambda>s.\n   False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)", "by(fastforce intro:PCFG.Proc Proc_CFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> (p',\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "hence \"wfp \\<turnstile> (p',Entry) -[((p',Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(p',Exit))]\\<rightarrow>* (p',Exit)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (p',\n                           Entry) -(\\<lambda>s.\n False)\\<^sub>\\<surd>\\<rightarrow> (p', Exit)\n\ngoal (1 subgoal):\n 1. ProcCFG.path wfp (p', Entry)\n     [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)", "by(fastforce intro:ProcCFG.path.intros \n          simp:valid_edge_def ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n        \\<open>containsCall procs prog (ps@[px]) p'\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'", "obtain as as' where \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (Main,Entry) as (p',Entry)\"\n        and \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (p',Exit) as' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry);\n         ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n\ngoal (2 subgoals):\n 1. (p, n) = sourcenode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (p', Entry)\n   [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)] (p', Exit)\n  ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry)\n  ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as@[((p',Entry),(\\<lambda>s. False)\\<^sub>\\<surd>,(p',Exit))]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Entry)\n              [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)]\n              (p', Exit);\n     ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry);\n     ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry)\n                          (as @\n                           [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                             p', Exit)])\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Entry)\n              [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)]\n              (p', Exit);\n     ProcCFG.valid_path' wfp (Main, Entry) as (p', Entry);\n     ProcCFG.valid_path' wfp (p', Exit) as' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry)\n                       (as @\n                        [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                          p', Exit)])\n                       (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(unfold ProcCFG.vp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (p', Entry)\n              [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>, p', Exit)]\n              (p', Exit);\n     ProcCFG.path wfp (Main, Entry) as (p', Entry) \\<and>\n     ProcCFG.valid_path wfp as;\n     ProcCFG.path wfp (p', Exit) as' (Main, Exit) \\<and>\n     ProcCFG.valid_path wfp as'\\<rbrakk>\n    \\<Longrightarrow> (ProcCFG.path wfp (Main, Entry)\n                        (as @\n                         [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                           p', Exit)])\n                        (p, n) \\<and>\n                       ProcCFG.valid_path wfp\n                        (as @\n                         [((p', Entry), (\\<lambda>s. False)\\<^sub>\\<surd>,\n                           p', Exit)])) \\<and>\n                      ProcCFG.path wfp (p, n) as' (Main, Exit) \\<and>\n                      ProcCFG.valid_path wfp as'", "by(fastforce intro:ProcCFG.path_Append \n          ProcCFG.valid_path_same_level_path_Append ProcCFG.intras_same_level_path\n          simp:intra_kind_def)+"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "assume \"(p, n) = targetnode a\""], ["proof (state)\nthis:\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>(px, Label l') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (px, Label l')\n  (p, n) = targetnode a", "have [simp]:\"n = Label l'\" \"p = px\""], ["proof (prove)\nusing this:\n  targetnode a = (px, Label l')\n  (p, n) = targetnode a\n\ngoal (1 subgoal):\n 1. n = Label l' &&& p = px", "by simp_all"], ["proof (state)\nthis:\n  n = Label l'\n  p = px\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  n = Label l'\n  p = px", "have \"l' < #:c\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  n = Label l'\n  p = px\n\ngoal (1 subgoal):\n 1. l' < #:c", "by(fastforce intro:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>l' < #:c\\<close> \n        \\<open>containsCall procs prog ps px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  l' < #:c\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs", "obtain as as' where \"wfp \\<turnstile> (px,Label l') -as\\<rightarrow>* (px,Exit)\"\n        and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n        and \"wfp \\<turnstile> (px,Entry) -as'\\<rightarrow>* (px,Label l')\"\n        and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  l' < #:c\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (px, Label l') as (px, Exit);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (px, Entry) as' (px, Label l');\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Proc)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Label l') as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Label l') as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>containsCall procs prog ps px\\<close>\n        \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs", "obtain asx asx' \n        where\" CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (Main,Entry) asx (px,Entry)\"\n        and \"CFG.valid_path' sourcenode targetnode kind\n        (valid_edge wfp) (get_return_edges wfp) (px,Exit) asx' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (\\<And>asx asx'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n         ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (1 subgoal):\n 1. (p, n) = targetnode a \\<Longrightarrow>\n    \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (px, Label l') as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (px, Label l') as (px, Exit)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Entry) as' (px, Label l')\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"asx@as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Label l') as (px, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Entry) as' (px, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'a.\n                         ProcCFG.valid_path' wfp (Main, Entry) (asx @ as')\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as'a (Main, Exit)", "apply(rule_tac x=\"as@asx'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Label l') as (px, Exit);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Entry) as' (px, Label l');\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) (asx @ as')\n                       (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) (as @ asx')\n                       (Main, Exit)", "by(auto intro:ProcCFG.path_Append ProcCFG.valid_path_same_level_path_Append\n          ProcCFG.same_level_path_valid_path_Append ProcCFG.intras_same_level_path\n          simp:ProcCFG.vp_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (2 subgoals):\n 1. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (MainCallReturn nx px es rets nx')"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (Main, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, nx') = targetnode a\n\ngoal (2 subgoals):\n 1. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>prog \\<turnstile> nx -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close> disj\n      \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym] \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')", "obtain l where [simp]:\"n = Label l\" \"p = Main\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n = Label l; p = Main\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  n = Label l\n  p = Main\n\ngoal (2 subgoals):\n 1. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>prog \\<turnstile> nx -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\\<close> disj\n      \\<open>(Main, nx) = sourcenode a\\<close>[THEN sym] \\<open>(Main, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')", "have \"l < #:prog\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (Main, nx)\n  targetnode a = (Main, nx')\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(auto intro:Proc_CFG_sourcelabel_less_num_nodes\n      Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (2 subgoals):\n 1. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:prog", "obtain as as' where \"wfp \\<turnstile> (Main,Entry) -as\\<rightarrow>* (Main,Label l)\"\n      and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n      and \"wfp \\<turnstile> (Main,Label l) -as'\\<rightarrow>* (Main,Exit)\"\n      and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  l < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Main)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l) as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>na pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> na -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n 2. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (Main, Entry) as (Main, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (Main, Label l) as' (Main, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry) as\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (Main, Entry) as (Main, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (Main, Label l) as' (Main, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) as\n                       (Main, Label l) \\<and>\n                      ProcCFG.valid_path' wfp (Main, Label l) as'\n                       (Main, Exit)", "by(fastforce intro:ProcCFG.intra_path_vp simp:ProcCFG.intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "case (ProcCallReturn px ins outs c nx p' es' rets' nx' ps)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  containsCall procs prog ps px\n  (px, nx) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (px, nx') = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>(px, ins, outs, c) \\<in> set procs\\<close> wf"], ["proof (chain)\npicking this:\n  (px, ins, outs, c) \\<in> set procs\n  well_formed procs", "have [simp]:\"px \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (px, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. px \\<noteq> Main", "by auto"], ["proof (state)\nthis:\n  px \\<noteq> Main\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\\<close> disj \n      \\<open>(px, nx) = sourcenode a\\<close>[THEN sym] \\<open>(px, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')", "obtain l where [simp]:\"n = Label l\" \"p = px\""], ["proof (prove)\nusing this:\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n = Label l; p = px\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  n = Label l\n  p = px\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\\<close> disj \n    \\<open>(px, nx) = sourcenode a\\<close>[THEN sym] \\<open>(px, nx') = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')", "have \"l < #:c\""], ["proof (prove)\nusing this:\n  c \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  (p, n) = sourcenode a \\<or> (p, n) = targetnode a\n  sourcenode a = (px, nx)\n  targetnode a = (px, nx')\n\ngoal (1 subgoal):\n 1. l < #:c", "by(auto intro:Proc_CFG_sourcelabel_less_num_nodes\n        Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "with \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close> \n      \\<open>containsCall procs prog ps px\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  l < #:c", "obtain as as' where \"wfp \\<turnstile> (px,Entry) -as\\<rightarrow>* (px,Label l)\"\n      and \"\\<forall>a \\<in> set as. intra_kind (kind a)\"\n      and \"wfp \\<turnstile> (px,Label l) -as'\\<rightarrow>* (px,Exit)\"\n      and \"\\<forall>a \\<in> set as'. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (px, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps px\n  l < #:c\n\ngoal (1 subgoal):\n 1. (\\<And>as as'.\n        \\<lbrakk>ProcCFG.path wfp (px, Entry) as (px, Label l);\n         \\<forall>a\\<in>set as. intra_kind (kind a);\n         ProcCFG.path wfp (px, Label l) as' (px, Exit);\n         \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Label_Proc_CFG_Entry_Exit_path_Proc)+"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "moreover"], ["proof (state)\nthis:\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \n      \\<open>containsCall procs prog ps px\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs", "obtain asx asx' where \"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (Main,Entry) asx (px,Entry)\"\n      and \"CFG.valid_path' sourcenode targetnode kind\n      (valid_edge wfp) (get_return_edges wfp) (px,Exit) asx' (Main,Exit)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  containsCall procs prog ps px\n  (px, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (\\<And>asx asx'.\n        \\<lbrakk>ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n         ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_to_Entry_and_Exit_to_Exit)+"], ["proof (state)\nthis:\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>pa ins outs c na p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> na -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, na) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (pa, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as as'.\n                            ProcCFG.valid_path' wfp (Main, Entry) as\n                             (p, n) \\<and>\n                            ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "ultimately"], ["proof (chain)\npicking this:\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  ProcCFG.path wfp (px, Entry) as (px, Label l)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  ProcCFG.path wfp (px, Label l) as' (px, Exit)\n  \\<forall>a\\<in>set as'. intra_kind (kind a)\n  ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry)\n  ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as as'.\n       ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n       ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"asx@as\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry) as (px, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Label l) as' (px, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as'.\n                         ProcCFG.valid_path' wfp (Main, Entry) (asx @ as)\n                          (p, n) \\<and>\n                         ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)", "apply(rule_tac x=\"as'@asx'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ProcCFG.path wfp (px, Entry) as (px, Label l);\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     ProcCFG.path wfp (px, Label l) as' (px, Exit);\n     \\<forall>a\\<in>set as'. intra_kind (kind a);\n     ProcCFG.valid_path' wfp (Main, Entry) asx (px, Entry);\n     ProcCFG.valid_path' wfp (px, Exit) asx' (Main, Exit)\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.valid_path' wfp (Main, Entry) (asx @ as)\n                       (p, n) \\<and>\n                      ProcCFG.valid_path' wfp (p, n) (as' @ asx')\n                       (Main, Exit)", "by(auto intro:ProcCFG.path_Append ProcCFG.valid_path_same_level_path_Append\n        ProcCFG.same_level_path_valid_path_Append ProcCFG.intras_same_level_path\n        simp:ProcCFG.vp_def)"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as as'.\n     ProcCFG.valid_path' wfp (Main, Entry) as (p, n) \\<and>\n     ProcCFG.valid_path' wfp (p, n) as' (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instantiating the \\<open>Postdomination\\<close> locale\\<close>"], ["", "interpretation ProcPostdomination:\n  Postdomination sourcenode targetnode kind \"valid_edge wfp\" \"(Main,Entry)\"\n  get_proc \"get_return_edges wfp\" \"lift_procs wfp\" Main \"(Main,Exit)\"\n  for wfp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "from Rep_wf_prog[of wfp]"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp \\<in> wf_prog", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp \\<in> wf_prog\n\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:wf_prog_def)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "hence wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "show \"Postdomination sourcenode targetnode kind (valid_edge wfp)\n    (Main, Entry) get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp (Main, Entry) as n\n 2. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 3. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp (Main, Entry) as n\n 2. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 3. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"CFG.valid_node sourcenode targetnode (valid_edge wfp) m\""], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp m\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp (Main, Entry) as n\n 2. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 3. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "then"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp m", "obtain a where \"valid_edge wfp a\"\n      and \"m = sourcenode a \\<or> m = targetnode a\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp m\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge wfp a;\n         m = sourcenode a \\<or> m = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  valid_edge wfp a\n  m = sourcenode a \\<or> m = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp (Main, Entry) as n\n 2. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 3. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "obtain p n where [simp]:\"m = (p,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p n. m = (p, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m) auto"], ["proof (state)\nthis:\n  m = (p, n)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp (Main, Entry) as n\n 2. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 3. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from \\<open>valid_edge wfp a\\<close> \\<open>m = sourcenode a \\<or> m = targetnode a\\<close> \n      \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  m = sourcenode a \\<or> m = targetnode a\n  Rep_wf_prog wfp = (prog, procs)", "show \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n      (get_return_edges wfp) (Main, Entry) as m\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  m = sourcenode a \\<or> m = targetnode a\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. \\<exists>as. ProcCFG.valid_path' wfp (Main, Entry) as m", "by(auto dest!:edge_valid_paths simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>as. ProcCFG.valid_path' wfp (Main, Entry) as m\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 2. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 2. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 2. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"CFG.valid_node sourcenode targetnode (valid_edge wfp) m\""], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp m\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 2. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "then"], ["proof (chain)\npicking this:\n  ProcCFG.valid_node wfp m", "obtain a where \"valid_edge wfp a\"\n      and \"m = sourcenode a \\<or> m = targetnode a\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp m\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge wfp a;\n         m = sourcenode a \\<or> m = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:ProcCFG.valid_node_def)"], ["proof (state)\nthis:\n  valid_edge wfp a\n  m = sourcenode a \\<or> m = targetnode a\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 2. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "obtain p n where [simp]:\"m = (p,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p n. m = (p, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m) auto"], ["proof (state)\nthis:\n  m = (p, n)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       ProcCFG.valid_node wfp n \\<Longrightarrow>\n       \\<exists>as. ProcCFG.valid_path' wfp n as (Main, Exit)\n 2. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from \\<open>valid_edge wfp a\\<close> \\<open>m = sourcenode a \\<or> m = targetnode a\\<close> \n      \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  m = sourcenode a \\<or> m = targetnode a\n  Rep_wf_prog wfp = (prog, procs)", "show \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge wfp)\n      (get_return_edges wfp) m as (Main,Exit)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  m = sourcenode a \\<or> m = targetnode a\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. \\<exists>as. ProcCFG.valid_path' wfp m as (Main, Exit)", "by(auto dest!:edge_valid_paths simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>as. ProcCFG.valid_path' wfp m as (Main, Exit)\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume mex1:\"CFGExit.method_exit sourcenode kind (valid_edge wfp) (Main,Exit) n\"\n      and mex2:\"CFGExit.method_exit sourcenode kind (valid_edge wfp) (Main,Exit) n'\"\n      and \"get_proc n = get_proc n'\""], ["proof (state)\nthis:\n  ProcCFGExit.method_exit wfp n\n  ProcCFGExit.method_exit wfp n'\n  get_proc n = get_proc n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from mex1"], ["proof (chain)\npicking this:\n  ProcCFGExit.method_exit wfp n", "have \"n = (Main,Exit) \\<or> (\\<exists>a Q p f. n = sourcenode a \\<and> valid_edge wfp a \\<and> \n      kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  ProcCFGExit.method_exit wfp n\n\ngoal (1 subgoal):\n 1. n = (Main, Exit) \\<or>\n    (\\<exists>a Q p f.\n        n = sourcenode a \\<and>\n        valid_edge wfp a \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by(simp add:ProcCFGExit.method_exit_def)"], ["proof (state)\nthis:\n  n = (Main, Exit) \\<or>\n  (\\<exists>a Q p f.\n      n = sourcenode a \\<and>\n      valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>ProcCFGExit.method_exit wfp n;\n        ProcCFGExit.method_exit wfp n'; get_proc n = get_proc n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus \"n = n'\""], ["proof (prove)\nusing this:\n  n = (Main, Exit) \\<or>\n  (\\<exists>a Q p f.\n      n = sourcenode a \\<and>\n      valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. n = n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "assume \"n = (Main,Exit)\""], ["proof (state)\nthis:\n  n = (Main, Exit)\n\ngoal (2 subgoals):\n 1. n = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from mex2"], ["proof (chain)\npicking this:\n  ProcCFGExit.method_exit wfp n'", "have \"n' = (Main,Exit) \\<or> (\\<exists>a Q p f. n' = sourcenode a \\<and> \n        valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  ProcCFGExit.method_exit wfp n'\n\ngoal (1 subgoal):\n 1. n' = (Main, Exit) \\<or>\n    (\\<exists>a Q p f.\n        n' = sourcenode a \\<and>\n        valid_edge wfp a \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by(simp add:ProcCFGExit.method_exit_def)"], ["proof (state)\nthis:\n  n' = (Main, Exit) \\<or>\n  (\\<exists>a Q p f.\n      n' = sourcenode a \\<and>\n      valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (2 subgoals):\n 1. n = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n' = (Main, Exit) \\<or>\n  (\\<exists>a Q p f.\n      n' = sourcenode a \\<and>\n      valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. n = n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "assume \"n' = (Main,Exit)\""], ["proof (state)\nthis:\n  n' = (Main, Exit)\n\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>n = (Main,Exit)\\<close>"], ["proof (chain)\npicking this:\n  n = (Main, Exit)\n  n' = (Main, Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = (Main, Exit)\n  n' = (Main, Exit)\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "assume \"\\<exists>a Q p f. n' = sourcenode a \\<and> \n          valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  \\<exists>a Q p f.\n     n' = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>a Q p f.\n     n' = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain a Q p f where \"n' = sourcenode a\"\n          and \"valid_edge wfp a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (prove)\nusing this:\n  \\<exists>a Q p f.\n     n' = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>a Q p f.\n        \\<lbrakk>n' = sourcenode a; valid_edge wfp a;\n         kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n' = sourcenode a\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule ProcCFG.get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>get_proc n = get_proc n'\\<close> \\<open>n = (Main,Exit)\\<close> \\<open>n' = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  get_proc n = get_proc n'\n  n = (Main, Exit)\n  n' = sourcenode a\n  get_proc (sourcenode a) = p", "have \"get_proc (Main,Exit) = p\""], ["proof (prove)\nusing this:\n  get_proc n = get_proc n'\n  n = (Main, Exit)\n  n' = sourcenode a\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. get_proc (Main, Exit) = p", "by simp"], ["proof (state)\nthis:\n  get_proc (Main, Exit) = p\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "hence \"p = Main\""], ["proof (prove)\nusing this:\n  get_proc (Main, Exit) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>valid_edge wfp a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule ProcCFG.Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "assume \"\\<exists>a Q p f. n = sourcenode a \\<and> \n        valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  \\<exists>a Q p f.\n     n = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>a Q p f.\n     n = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain a Q p f where \"n = sourcenode a\"\n        and \"valid_edge wfp a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (prove)\nusing this:\n  \\<exists>a Q p f.\n     n = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>a Q p f.\n        \\<lbrakk>n = sourcenode a; valid_edge wfp a;\n         kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = sourcenode a\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule ProcCFG.get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from mex2"], ["proof (chain)\npicking this:\n  ProcCFGExit.method_exit wfp n'", "have \"n' = (Main,Exit) \\<or> (\\<exists>a Q p f. n' = sourcenode a \\<and> \n        valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  ProcCFGExit.method_exit wfp n'\n\ngoal (1 subgoal):\n 1. n' = (Main, Exit) \\<or>\n    (\\<exists>a Q p f.\n        n' = sourcenode a \\<and>\n        valid_edge wfp a \\<and>\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "by(simp add:ProcCFGExit.method_exit_def)"], ["proof (state)\nthis:\n  n' = (Main, Exit) \\<or>\n  (\\<exists>a Q p f.\n      n' = sourcenode a \\<and>\n      valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n' = (Main, Exit) \\<or>\n  (\\<exists>a Q p f.\n      n' = sourcenode a \\<and>\n      valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. n = n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "assume \"n' = (Main,Exit)\""], ["proof (state)\nthis:\n  n' = (Main, Exit)\n\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from \\<open>get_proc (sourcenode a) = p\\<close> \\<open>get_proc n = get_proc n'\\<close>\n          \\<open>n' = (Main,Exit)\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  get_proc (sourcenode a) = p\n  get_proc n = get_proc n'\n  n' = (Main, Exit)\n  n = sourcenode a", "have \"get_proc (Main,Exit) = p\""], ["proof (prove)\nusing this:\n  get_proc (sourcenode a) = p\n  get_proc n = get_proc n'\n  n' = (Main, Exit)\n  n = sourcenode a\n\ngoal (1 subgoal):\n 1. get_proc (Main, Exit) = p", "by simp"], ["proof (state)\nthis:\n  get_proc (Main, Exit) = p\n\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "hence \"p = Main\""], ["proof (prove)\nusing this:\n  get_proc (Main, Exit) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>valid_edge wfp a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule ProcCFG.Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n' = (Main, Exit) \\<Longrightarrow> n = n'\n 2. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "assume \"\\<exists>a Q p f. n' = sourcenode a \\<and> \n          valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  \\<exists>a Q p f.\n     n' = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>a Q p f.\n     n' = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain a' Q' p' f' where \"n' = sourcenode a'\"\n          and \"valid_edge wfp a'\" and \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (prove)\nusing this:\n  \\<exists>a Q p f.\n     n' = sourcenode a \\<and>\n     valid_edge wfp a \\<and> kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' p' f'.\n        \\<lbrakk>n' = sourcenode a'; valid_edge wfp a';\n         kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n' = sourcenode a'\n  valid_edge wfp a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from \\<open>valid_edge wfp a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'", "have \"get_proc (sourcenode a') = p'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p'", "by(rule ProcCFG.get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p'\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>get_proc n = get_proc n'\\<close> \\<open>get_proc (sourcenode a) = p\\<close>\n          \\<open>n = sourcenode a\\<close> \\<open>n' = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  get_proc n = get_proc n'\n  get_proc (sourcenode a) = p\n  n = sourcenode a\n  n' = sourcenode a'\n  get_proc (sourcenode a') = p'", "have \"p' = p\""], ["proof (prove)\nusing this:\n  get_proc n = get_proc n'\n  get_proc (sourcenode a) = p\n  n = sourcenode a\n  n' = sourcenode a'\n  get_proc (sourcenode a') = p'\n\ngoal (1 subgoal):\n 1. p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from \\<open>valid_edge wfp a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"sourcenode a = (p,Exit)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. sourcenode a = (p, Exit)", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  sourcenode a = (p, Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "from \\<open>valid_edge wfp a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge wfp a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'", "have \"sourcenode a' = (p',Exit)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. sourcenode a' = (p', Exit)", "by(auto elim:PCFG.cases simp:valid_edge_def)"], ["proof (state)\nthis:\n  sourcenode a' = (p', Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>a Q p f.\n       n' = sourcenode a \\<and>\n       valid_edge wfp a \\<and>\n       kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    n = n'", "with \\<open>n = sourcenode a\\<close> \\<open>n' = sourcenode a'\\<close> \\<open>p' = p\\<close>\n          \\<open>sourcenode a = (p,Exit)\\<close>"], ["proof (chain)\npicking this:\n  n = sourcenode a\n  n' = sourcenode a'\n  p' = p\n  sourcenode a = (p, Exit)\n  sourcenode a' = (p', Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = sourcenode a\n  n' = sourcenode a'\n  p' = p\n  sourcenode a = (p, Exit)\n  sourcenode a' = (p', Exit)\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Postdomination sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n   get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}