{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/Postdomination.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma get_return_edges_unique:\n  assumes \"valid_edge a\" and \"a' \\<in> get_return_edges a\" and \"a'' \\<in> get_return_edges a\"\n  shows \"a' = a''\"", "lemma postdominate_implies_inner_path: \n  assumes \"n' postdominates n\" \n  obtains as where \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"n' \\<notin> set (sourcenodes as)\"", "lemma postdominate_variant:\n  assumes \"n' postdominates n\" \n  shows \"\\<forall>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow> n' \\<in> set (sourcenodes as)\"", "lemma postdominate_refl:\n  assumes \"valid_node n\" and \"\\<not> method_exit n\" shows \"n postdominates n\"", "lemma postdominate_trans:\n  assumes \"n'' postdominates n\" and \"n' postdominates n''\"\n  shows \"n' postdominates n\"", "lemma postdominate_antisym:\n  assumes \"n' postdominates n\" and \"n postdominates n'\"\n  shows \"n = n'\"", "lemma postdominate_path_branch:\n  assumes \"n -as\\<rightarrow>* n''\" and \"n' postdominates n''\" and \"\\<not> n' postdominates n\"\n  obtains a as' as'' where \"as = as'@a#as''\" and \"valid_edge a\"\n  and \"\\<not> n' postdominates (sourcenode a)\" and \"n' postdominates (targetnode a)\"", "lemma Exit_no_postdominator:\n  assumes \"(_Exit_) postdominates n\" shows False", "lemma postdominate_inner_path_targetnode:\n  assumes \"n' postdominates n\" and \"n -as\\<rightarrow>\\<^sub>\\<iota>* n''\" and \"n' \\<notin> set(sourcenodes as)\"\n  shows \"n' postdominates n''\"", "lemma not_postdominate_source_not_postdominate_target:\n  assumes \"\\<not> n postdominates (sourcenode a)\" \n  and \"valid_node n\" and \"valid_edge a\" and \"intra_kind (kind a)\"\n  obtains ax where \"sourcenode a = sourcenode ax\" and \"valid_edge ax\"\n  and \"\\<not> n postdominates targetnode ax\"", "lemma inner_node_Exit_edge:\n  assumes \"inner_node n\" \n  obtains a where \"valid_edge a\" and \"intra_kind (kind a)\" \n  and \"inner_node (sourcenode a)\" and \"targetnode a = (_Exit_)\"", "lemma inner_node_Entry_edge:\n  assumes \"inner_node n\" \n  obtains a where \"valid_edge a\" and \"intra_kind (kind a)\" \n  and \"inner_node (targetnode a)\" and \"sourcenode a = (_Entry_)\"", "lemma intra_path_to_matching_method_exit:\n  assumes \"method_exit n'\" and \"get_proc n = get_proc n'\" and \"valid_node n\"\n  obtains as where \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\""], "translations": [["", "lemma get_return_edges_unique:\n  assumes \"valid_edge a\" and \"a' \\<in> get_return_edges a\" and \"a'' \\<in> get_return_edges a\"\n  shows \"a' = a''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = a''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q r p fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. a' = a''", "with \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. a' = a''", "from this \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc (sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"method_exit (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a')", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode a')\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a\\<close> \\<open>a'' \\<in> get_return_edges a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a'' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q'' f'' where \"kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a'' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q'' f''.\n        kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a\\<close> \\<open>a'' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a'' \\<in> get_return_edges a", "have \"valid_edge a''\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a'' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a''", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a''\n\ngoal (1 subgoal):\n 1. a' = a''", "from this \\<open>kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"get_proc (sourcenode a'') = p\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a'') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a'') = p\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a''\\<close> \\<open>kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''", "have \"method_exit (sourcenode a'')\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  kind a'' = Q''\\<hookleftarrow>\\<^bsub>p\\<^esub>f''\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a'')", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode a'')\n\ngoal (1 subgoal):\n 1. a' = a''", "with \\<open>method_exit (sourcenode a')\\<close> \\<open>get_proc (sourcenode a') = p\\<close>\n    \\<open>get_proc (sourcenode a'') = p\\<close>"], ["proof (chain)\npicking this:\n  method_exit (sourcenode a')\n  get_proc (sourcenode a') = p\n  get_proc (sourcenode a'') = p\n  method_exit (sourcenode a'')", "have \"sourcenode a' = sourcenode a''\""], ["proof (prove)\nusing this:\n  method_exit (sourcenode a')\n  get_proc (sourcenode a') = p\n  get_proc (sourcenode a'') = p\n  method_exit (sourcenode a'')\n\ngoal (1 subgoal):\n 1. sourcenode a' = sourcenode a''", "by(fastforce elim!:method_exit_unique)"], ["proof (state)\nthis:\n  sourcenode a' = sourcenode a''\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain ax' where \"valid_edge ax'\" and \"sourcenode ax' = sourcenode a\"\n    and \"targetnode ax' = targetnode a'\" and \"intra_kind(kind ax')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>ax'.\n        \\<lbrakk>valid_edge ax'; sourcenode ax' = sourcenode a;\n         targetnode ax' = targetnode a'; intra_kind (kind ax')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge ax'\n  sourcenode ax' = sourcenode a\n  targetnode ax' = targetnode a'\n  intra_kind (kind ax')\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a\\<close> \\<open>a'' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a'' \\<in> get_return_edges a", "obtain ax'' where \"valid_edge ax''\" and \"sourcenode ax'' = sourcenode a\"\n    and \"targetnode ax'' = targetnode a''\" and \"intra_kind(kind ax'')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a'' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>ax''.\n        \\<lbrakk>valid_edge ax''; sourcenode ax'' = sourcenode a;\n         targetnode ax'' = targetnode a''; intra_kind (kind ax'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge ax''\n  sourcenode ax'' = sourcenode a\n  targetnode ax'' = targetnode a''\n  intra_kind (kind ax'')\n\ngoal (1 subgoal):\n 1. a' = a''", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge ax'\\<close> \n    \\<open>sourcenode ax' = sourcenode a\\<close> \\<open>intra_kind(kind ax')\\<close>\n    \\<open>valid_edge ax''\\<close> \\<open>sourcenode ax'' = sourcenode a\\<close> \\<open>intra_kind(kind ax'')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge ax'\n  sourcenode ax' = sourcenode a\n  intra_kind (kind ax')\n  valid_edge ax''\n  sourcenode ax'' = sourcenode a\n  intra_kind (kind ax'')", "have \"ax' = ax''\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge ax'\n  sourcenode ax' = sourcenode a\n  intra_kind (kind ax')\n  valid_edge ax''\n  sourcenode ax'' = sourcenode a\n  intra_kind (kind ax'')\n\ngoal (1 subgoal):\n 1. ax' = ax''", "by -(drule call_only_one_intra_edge,auto)"], ["proof (state)\nthis:\n  ax' = ax''\n\ngoal (1 subgoal):\n 1. a' = a''", "with \\<open>targetnode ax' = targetnode a'\\<close> \\<open>targetnode ax'' = targetnode a''\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax' = targetnode a'\n  targetnode ax'' = targetnode a''\n  ax' = ax''", "have \"targetnode a' = targetnode a''\""], ["proof (prove)\nusing this:\n  targetnode ax' = targetnode a'\n  targetnode ax'' = targetnode a''\n  ax' = ax''\n\ngoal (1 subgoal):\n 1. targetnode a' = targetnode a''", "by simp"], ["proof (state)\nthis:\n  targetnode a' = targetnode a''\n\ngoal (1 subgoal):\n 1. a' = a''", "with \\<open>valid_edge a'\\<close> \\<open>valid_edge a''\\<close> \\<open>sourcenode a' = sourcenode a''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge a''\n  sourcenode a' = sourcenode a''\n  targetnode a' = targetnode a''", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge a''\n  sourcenode a' = sourcenode a''\n  targetnode a' = targetnode a''\n\ngoal (1 subgoal):\n 1. a' = a''", "by(rule edge_det)"], ["proof (state)\nthis:\n  a' = a''\n\ngoal:\nNo subgoals!", "qed"], ["", "definition postdominate :: \"'node \\<Rightarrow> 'node \\<Rightarrow> bool\" (\"_ postdominates _\" [51,0])\nwhere postdominate_def:\"n' postdominates n \\<equiv> \n  (valid_node n \\<and> valid_node n' \\<and>\n  (\\<forall>as pex. (n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and> method_exit pex) \\<longrightarrow> n' \\<in> set (sourcenodes as)))\""], ["", "lemma postdominate_implies_inner_path: \n  assumes \"n' postdominates n\" \n  obtains as where \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\" and \"n' \\<notin> set (sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* n';\n         n' \\<notin> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "from \\<open>n' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates n", "have \"valid_node n\"\n    and all:\"\\<forall>as pex. (n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and> method_exit pex) \\<longrightarrow> n' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  n' postdominates n\n\ngoal (1 subgoal):\n 1. valid_node n &&&\n    \\<forall>as pex.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "by(auto simp:postdominate_def)"], ["proof (state)\nthis:\n  valid_node n\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "from \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n", "obtain asx where \"n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:Exit_path)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as where \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\"\n    and \"\\<forall>a \\<in> set as. intra_kind(kind a) \\<or> (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n         \\<forall>a\\<in>set as.\n            intra_kind (kind a) \\<or>\n            (\\<exists>Q f p.\n                kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Exit_path_descending_path)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  \\<forall>a\\<in>set as.\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "show \"\\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and> n' \\<notin> set (sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "proof(cases \"\\<exists>a \\<in> set as. \\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "case True"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set as.\n     \\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>set as.\n     \\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain asx ax asx' where [simp]:\"as = asx@ax#asx'\" \n      and \"\\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"\\<forall>a \\<in> set asx. \\<forall>Q f p. kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set as.\n     \\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>asx ax asx'.\n        \\<lbrakk>as = asx @ ax # asx';\n         \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n         \\<forall>a\\<in>set asx.\n            \\<forall>Q f p.\n               kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule split_list_first_propE,simp)"], ["proof (state)\nthis:\n  as = asx @ ax # asx'\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<forall>a\\<in>set asx.\n     \\<forall>Q f p. kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "with \\<open>\\<forall>a \\<in> set as. intra_kind(kind a) \\<or> (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as.\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  as = asx @ ax # asx'\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<forall>a\\<in>set asx.\n     \\<forall>Q f p. kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"\\<forall>a \\<in> set asx. intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as.\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  as = asx @ ax # asx'\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  \\<forall>a\\<in>set asx.\n     \\<forall>Q f p. kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set asx. intra_kind (kind a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"n -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\"\n      and \"valid_edge ax\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax &&& valid_edge ax", "by(auto dest:vp_split)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\n  valid_edge ax\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "from \\<open>n -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\\<close> \\<open>\\<forall>a \\<in> set asx. intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\n  \\<forall>a\\<in>set asx. intra_kind (kind a)", "have \"n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\n  \\<forall>a\\<in>set asx. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax", "by(simp add:vp_def intra_path_def)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "from \\<open>valid_edge ax\\<close> \\<open>\\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"method_exit (sourcenode ax)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  \\<exists>Q f p. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode ax)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode ax)\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "with \\<open>n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\\<close> all"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n  method_exit (sourcenode ax)", "have \"n' \\<in> set (sourcenodes asx)\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n  method_exit (sourcenode ax)\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes asx)", "by fastforce"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes asx)\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  n' \\<in> set (sourcenodes asx)", "obtain xs ys where \"sourcenodes asx = xs@n'#ys\" and \"n' \\<notin> set xs\""], ["proof (prove)\nusing this:\n  n' \\<in> set (sourcenodes asx)\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>sourcenodes asx = xs @ n' # ys; n' \\<notin> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:split_list_first)"], ["proof (state)\nthis:\n  sourcenodes asx = xs @ n' # ys\n  n' \\<notin> set xs\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  sourcenodes asx = xs @ n' # ys\n  n' \\<notin> set xs", "obtain as' a as'' where \"xs = sourcenodes as'\"\n      and [simp]:\"asx = as'@a#as''\" and \"sourcenode a = n'\""], ["proof (prove)\nusing this:\n  sourcenodes asx = xs @ n' # ys\n  n' \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>xs = sourcenodes as'; asx = as' @ a # as'';\n         sourcenode a = n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  xs = sourcenodes as'\n  asx = as' @ a # as''\n  sourcenode a = n'\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "from \\<open>n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax", "have \"n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>\\<^sub>\\<iota>* sourcenode ax\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce dest:path_split simp:intra_path_def)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set as.\n       \\<exists>Q f p.\n          kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)\n 2. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "with \\<open>sourcenode a = n'\\<close> \\<open>n' \\<notin> set xs\\<close> \\<open>xs = sourcenodes as'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = n'\n  n' \\<notin> set xs\n  xs = sourcenodes as'\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = n'\n  n' \\<notin> set xs\n  xs = sourcenodes as'\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>a\\<in>set as.\n             \\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "with \\<open>\\<forall>a \\<in> set as. intra_kind(kind a) \\<or> (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set as.\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  \\<not> (\\<exists>a\\<in>set as.\n             \\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)", "have \"\\<forall>a \\<in> set as. intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set as.\n     intra_kind (kind a) \\<or>\n     (\\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n  \\<not> (\\<exists>a\\<in>set as.\n             \\<exists>Q f p. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close> all"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n  \\<forall>a\\<in>set as. intra_kind (kind a)", "have \"n' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes as)", "by(auto simp:vp_def intra_path_def simp:method_exit_def)"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  n' \\<in> set (sourcenodes as)", "obtain xs ys where \"sourcenodes as = xs@n'#ys\" and \"n' \\<notin> set xs\""], ["proof (prove)\nusing this:\n  n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>sourcenodes as = xs @ n' # ys; n' \\<notin> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:split_list_first)"], ["proof (state)\nthis:\n  sourcenodes as = xs @ n' # ys\n  n' \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  sourcenodes as = xs @ n' # ys\n  n' \\<notin> set xs", "obtain as' a as'' where \"xs = sourcenodes as'\"\n      and [simp]:\"as = as'@a#as''\" and \"sourcenode a = n'\""], ["proof (prove)\nusing this:\n  sourcenodes as = xs @ n' # ys\n  n' \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>xs = sourcenodes as'; as = as' @ a # as'';\n         sourcenode a = n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  xs = sourcenodes as'\n  as = as' @ a # as''\n  sourcenode a = n'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close> \\<open>\\<forall>a \\<in> set as. intra_kind(kind a)\\<close> \\<open>as = as'@a#as''\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  as = as' @ a # as''", "have \"n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  as = as' @ a # as''\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce dest:path_split simp:vp_def intra_path_def)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set as.\n               \\<exists>Q f p.\n                  kind a =\n                  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f) \\<Longrightarrow>\n    \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "with \\<open>sourcenode a = n'\\<close> \\<open>n' \\<notin> set xs\\<close> \\<open>xs = sourcenodes as'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = n'\n  n' \\<notin> set xs\n  xs = sourcenodes as'\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = n'\n  n' \\<notin> set xs\n  xs = sourcenodes as'\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       n' \\<notin> set (sourcenodes as)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     n' \\<notin> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma postdominate_variant:\n  assumes \"n' postdominates n\" \n  shows \"\\<forall>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow> n' \\<in> set (sourcenodes as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "from \\<open>n' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates n", "have all:\"\\<forall>as pex. (n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and> method_exit pex) \\<longrightarrow> n' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  n' postdominates n\n\ngoal (1 subgoal):\n 1. \\<forall>as pex.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "by(simp add:postdominate_def)"], ["proof (state)\nthis:\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "{"], ["proof (state)\nthis:\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "fix as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "assume \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "then"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as' pex where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\"\n      and \"set(sourcenodes as') \\<subseteq> set(sourcenodes as)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as' pex.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex; method_exit pex;\n         set (sourcenodes as') \\<subseteq> set (sourcenodes as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "from \\<open>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\\<close> \\<open>method_exit pex\\<close> \\<open>n' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  n' postdominates n", "have \"n' \\<in> set (sourcenodes as')\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  n' postdominates n\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes as')", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "with \\<open>set(sourcenodes as') \\<subseteq> set(sourcenodes as)\\<close>"], ["proof (chain)\npicking this:\n  set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n  n' \\<in> set (sourcenodes as')", "have \"n' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  set (sourcenodes as') \\<subseteq> set (sourcenodes as)\n  n' \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes as)", "by fastforce"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "}"], ["proof (state)\nthis:\n  n -?as2\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n  n' \\<in> set (sourcenodes ?as2)\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n -?as2\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n  n' \\<in> set (sourcenodes ?as2)\n\ngoal (1 subgoal):\n 1. \\<forall>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n       n' \\<in> set (sourcenodes as)", "by simp"], ["proof (state)\nthis:\n  \\<forall>as.\n     n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma postdominate_refl:\n  assumes \"valid_node n\" and \"\\<not> method_exit n\" shows \"n postdominates n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n postdominates n", "using \\<open>valid_node n\\<close>"], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. n postdominates n", "proof(induct rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow> n postdominates n\n 2. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 3. inner_node n \\<Longrightarrow> n postdominates n", "case Entry"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (3 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow> n postdominates n\n 2. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 3. inner_node n \\<Longrightarrow> n postdominates n", "{"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (3 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow> n postdominates n\n 2. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 3. inner_node n \\<Longrightarrow> n postdominates n", "fix as pex"], ["proof (state)\ngoal (3 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow> n postdominates n\n 2. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 3. inner_node n \\<Longrightarrow> n postdominates n", "assume \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (3 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow> n postdominates n\n 2. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 3. inner_node n \\<Longrightarrow> n postdominates n", "from \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  method_exit pex", "have \"(_Entry_) \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  method_exit pex\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<in> set (sourcenodes as)", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "assume \"pex = (_Exit_)\""], ["proof (state)\nthis:\n  pex = (_Exit_)\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  pex = (_Exit_)", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  pex = (_Exit_)\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "apply(clarsimp simp:intra_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pex = (_Exit_); (_Entry_) -[]\\<rightarrow>* (_Exit_);\n     as = []\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule path.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>pex = (_Exit_); as = []; (_Entry_) = n; [] = [];\n        (_Exit_) = n; valid_node n\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n'' asa n' a n.\n       \\<lbrakk>pex = (_Exit_); as = []; (_Entry_) = n; [] = a # asa;\n        (_Exit_) = n'; n'' -asa\\<rightarrow>* n'; valid_edge a;\n        sourcenode a = n; targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> False", "by (drule sym,simp,drule Exit_noteq_Entry,auto)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  as \\<noteq> []", "have \"hd (sourcenodes as) = (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as) = (_Entry_)", "by(fastforce intro:path_sourcenode simp:intra_path_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as) = (_Entry_)\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "with \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []\n  hd (sourcenodes as) = (_Entry_)", "show ?thesis"], ["proof (prove)\nusing this:\n  as \\<noteq> []\n  hd (sourcenodes as) = (_Entry_)\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<in> set (sourcenodes as)", "by(fastforce intro:hd_in_set simp:sourcenodes_def)"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "fix a Q p f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "assume \"pex = sourcenode a\" and \"valid_edge a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  pex = sourcenode a\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"get_proc (_Entry_) = get_proc pex\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. get_proc (_Entry_) = get_proc pex", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (_Entry_) = get_proc pex\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "hence \"get_proc pex = Main\""], ["proof (prove)\nusing this:\n  get_proc (_Entry_) = get_proc pex\n\ngoal (1 subgoal):\n 1. get_proc pex = Main", "by(simp add:get_proc_Entry)"], ["proof (state)\nthis:\n  get_proc pex = Main\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "with \\<open>pex = sourcenode a\\<close> \\<open>get_proc pex = Main\\<close>"], ["proof (chain)\npicking this:\n  pex = sourcenode a\n  get_proc pex = Main\n  get_proc (sourcenode a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  pex = sourcenode a\n  get_proc pex = Main\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. False", "by simp (rule Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes as)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (_Entry_) \\<in> set (sourcenodes as)", "by simp"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (_Entry_) \\<in> set (sourcenodes as)\n\ngoal (3 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow> n postdominates n\n 2. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 3. inner_node n \\<Longrightarrow> n postdominates n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(_Entry_) -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes ?as2)\n\ngoal (3 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow> n postdominates n\n 2. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 3. inner_node n \\<Longrightarrow> n postdominates n", "with Entry"], ["proof (chain)\npicking this:\n  n = (_Entry_)\n  \\<lbrakk>(_Entry_) -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes ?as2)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = (_Entry_)\n  \\<lbrakk>(_Entry_) -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> (_Entry_) \\<in> set (sourcenodes ?as2)\n\ngoal (1 subgoal):\n 1. n postdominates n", "by(fastforce intro:empty_path simp:postdominate_def intra_path_def)"], ["proof (state)\nthis:\n  n postdominates n\n\ngoal (2 subgoals):\n 1. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 2. inner_node n \\<Longrightarrow> n postdominates n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 2. inner_node n \\<Longrightarrow> n postdominates n", "case Exit"], ["proof (state)\nthis:\n  n = (_Exit_)\n\ngoal (2 subgoals):\n 1. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 2. inner_node n \\<Longrightarrow> n postdominates n", "with \\<open>\\<not> method_exit n\\<close>"], ["proof (chain)\npicking this:\n  \\<not> method_exit n\n  n = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  \\<not> method_exit n\n  n = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(simp add:method_exit_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n = (_Exit_) \\<Longrightarrow> n postdominates n\n 2. inner_node n \\<Longrightarrow> n postdominates n", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n postdominates n", "by simp"], ["proof (state)\nthis:\n  n postdominates n\n\ngoal (1 subgoal):\n 1. inner_node n \\<Longrightarrow> n postdominates n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node n \\<Longrightarrow> n postdominates n", "case inner"], ["proof (state)\nthis:\n  inner_node n\n\ngoal (1 subgoal):\n 1. inner_node n \\<Longrightarrow> n postdominates n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n postdominates n", "proof(cases \"\\<exists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "case True"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "{"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "fix as pex"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "assume \"n -as\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "with \\<open>\\<not> method_exit n\\<close>"], ["proof (chain)\npicking this:\n  \\<not> method_exit n\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> method_exit n\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close> inner"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  inner_node n\n  as \\<noteq> []", "have \"hd (sourcenodes as) = n\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  inner_node n\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as) = n", "by(fastforce intro:path_sourcenode simp:intra_path_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as) = n\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "from \\<open>as \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  as \\<noteq> []", "have \"sourcenodes as \\<noteq> []\""], ["proof (prove)\nusing this:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. sourcenodes as \\<noteq> []", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes as \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "with \\<open>hd (sourcenodes as) = n\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  n = hd (sourcenodes as)\n  sourcenodes as \\<noteq> []", "have \"n \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  n = hd (sourcenodes as)\n  sourcenodes as \\<noteq> []\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes as)", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> n \\<in> set (sourcenodes ?as2)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "hence \"\\<forall>as pex. (n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and> method_exit pex) \\<longrightarrow> n \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> n \\<in> set (sourcenodes ?as2)\n\ngoal (1 subgoal):\n 1. \\<forall>as pex.\n       n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n       method_exit pex \\<longrightarrow>\n       n \\<in> set (sourcenodes as)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n \\<in> set (sourcenodes as)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n\n 2. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "with True inner"], ["proof (chain)\npicking this:\n  \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  inner_node n\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n \\<in> set (sourcenodes as)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  inner_node n\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n postdominates n", "by(fastforce intro:empty_path \n                   simp:postdominate_def inner_is_valid intra_path_def)"], ["proof (state)\nthis:\n  n postdominates n\n\ngoal (1 subgoal):\n 1. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "case False"], ["proof (state)\nthis:\n  \\<nexists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<nexists>as.\n       n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n    n postdominates n", "with inner"], ["proof (chain)\npicking this:\n  inner_node n\n  \\<nexists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_node n\n  \\<nexists>as. n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n postdominates n", "by(fastforce dest:inner_is_valid Exit_path)"], ["proof (state)\nthis:\n  n postdominates n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n postdominates n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma postdominate_trans:\n  assumes \"n'' postdominates n\" and \"n' postdominates n''\"\n  shows \"n' postdominates n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' postdominates n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n' postdominates n", "from \\<open>n'' postdominates n\\<close> \\<open>n' postdominates n''\\<close>"], ["proof (chain)\npicking this:\n  n'' postdominates n\n  n' postdominates n''", "have \"valid_node n\" and \"valid_node n'\""], ["proof (prove)\nusing this:\n  n'' postdominates n\n  n' postdominates n''\n\ngoal (1 subgoal):\n 1. valid_node n &&& valid_node n'", "by(simp_all add:postdominate_def)"], ["proof (state)\nthis:\n  valid_node n\n  valid_node n'\n\ngoal (1 subgoal):\n 1. n' postdominates n", "{"], ["proof (state)\nthis:\n  valid_node n\n  valid_node n'\n\ngoal (1 subgoal):\n 1. n' postdominates n", "fix as pex"], ["proof (state)\ngoal (1 subgoal):\n 1. n' postdominates n", "assume \"n -as\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. n' postdominates n", "with \\<open>n'' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n'' postdominates n\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex", "have \"n'' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  n'' postdominates n\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. n'' \\<in> set (sourcenodes as)", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n' postdominates n", "then"], ["proof (chain)\npicking this:\n  n'' \\<in> set (sourcenodes as)", "obtain ns' ns'' where \"sourcenodes as = ns'@n''#ns''\""], ["proof (prove)\nusing this:\n  n'' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. (\\<And>ns' ns''.\n        sourcenodes as = ns' @ n'' # ns'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:split_list)"], ["proof (state)\nthis:\n  sourcenodes as = ns' @ n'' # ns''\n\ngoal (1 subgoal):\n 1. n' postdominates n", "then"], ["proof (chain)\npicking this:\n  sourcenodes as = ns' @ n'' # ns''", "obtain as' as'' a where \"sourcenodes as'' = ns''\" and [simp]:\"as=as'@a#as''\"\n      and [simp]:\"sourcenode a = n''\""], ["proof (prove)\nusing this:\n  sourcenodes as = ns' @ n'' # ns''\n\ngoal (1 subgoal):\n 1. (\\<And>as'' as' a.\n        \\<lbrakk>sourcenodes as'' = ns''; as = as' @ a # as'';\n         sourcenode a = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes as'' = ns''\n  as = as' @ a # as''\n  sourcenode a = n''\n\ngoal (1 subgoal):\n 1. n' postdominates n", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"n -as'@a#as''\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n -as' @ a # as''\\<rightarrow>\\<^sub>\\<iota>* pex", "by simp"], ["proof (state)\nthis:\n  n -as' @ a # as''\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n' postdominates n", "hence \"n'' -a#as''\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  n -as' @ a # as''\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n'' -a # as''\\<rightarrow>\\<^sub>\\<iota>* pex", "by(fastforce dest:path_split_second simp:intra_path_def)"], ["proof (state)\nthis:\n  n'' -a # as''\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n' postdominates n", "with \\<open>n' postdominates n''\\<close> \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates n''\n  method_exit pex\n  n'' -a # as''\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"n' \\<in> set(sourcenodes (a#as''))\""], ["proof (prove)\nusing this:\n  n' postdominates n''\n  method_exit pex\n  n'' -a # as''\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes (a # as''))", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes (a # as''))\n\ngoal (1 subgoal):\n 1. n' postdominates n", "hence \"n' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  n' \\<in> set (sourcenodes (a # as''))\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes as)", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n' postdominates n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> n' \\<in> set (sourcenodes ?as2)\n\ngoal (1 subgoal):\n 1. n' postdominates n", "with \\<open>valid_node n\\<close> \\<open>valid_node n'\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\n  valid_node n'\n  \\<lbrakk>n -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> n' \\<in> set (sourcenodes ?as2)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_node n\n  valid_node n'\n  \\<lbrakk>n -?as2\\<rightarrow>\\<^sub>\\<iota>* ?pex2;\n   method_exit ?pex2\\<rbrakk>\n  \\<Longrightarrow> n' \\<in> set (sourcenodes ?as2)\n\ngoal (1 subgoal):\n 1. n' postdominates n", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  n' postdominates n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma postdominate_antisym:\n  assumes \"n' postdominates n\" and \"n postdominates n'\"\n  shows \"n = n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n = n'", "from \\<open>n' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates n", "have \"valid_node n\" and \"valid_node n'\""], ["proof (prove)\nusing this:\n  n' postdominates n\n\ngoal (1 subgoal):\n 1. valid_node n &&& valid_node n'", "by(auto simp:postdominate_def)"], ["proof (state)\nthis:\n  valid_node n\n  valid_node n'\n\ngoal (1 subgoal):\n 1. n = n'", "from \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n", "obtain asx where \"n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:Exit_path)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n = n'", "then"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as' pex where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as' pex.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. n = n'", "with \\<open>n' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates n\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex", "have \"\\<exists>nx \\<in> set(sourcenodes as'). nx = n'\""], ["proof (prove)\nusing this:\n  n' postdominates n\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. \\<exists>nx\\<in>set (sourcenodes as'). nx = n'", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  \\<exists>nx\\<in>set (sourcenodes as'). nx = n'\n\ngoal (1 subgoal):\n 1. n = n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>nx\\<in>set (sourcenodes as'). nx = n'", "obtain ns ns' where \"sourcenodes as' = ns@n'#ns'\"\n    and \"\\<forall>nx \\<in> set ns'. nx \\<noteq> n'\""], ["proof (prove)\nusing this:\n  \\<exists>nx\\<in>set (sourcenodes as'). nx = n'\n\ngoal (1 subgoal):\n 1. (\\<And>ns ns'.\n        \\<lbrakk>sourcenodes as' = ns @ n' # ns';\n         \\<forall>nx\\<in>set ns'. nx \\<noteq> n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_last_propE)"], ["proof (state)\nthis:\n  sourcenodes as' = ns @ n' # ns'\n  \\<forall>nx\\<in>set ns'. nx \\<noteq> n'\n\ngoal (1 subgoal):\n 1. n = n'", "from \\<open>sourcenodes as' = ns@n'#ns'\\<close>"], ["proof (chain)\npicking this:\n  sourcenodes as' = ns @ n' # ns'", "obtain asx a asx' \n    where [simp]:\"ns' = sourcenodes asx'\" \"as' = asx@a#asx'\" \"sourcenode a = n'\""], ["proof (prove)\nusing this:\n  sourcenodes as' = ns @ n' # ns'\n\ngoal (1 subgoal):\n 1. (\\<And>asx' asx a.\n        \\<lbrakk>ns' = sourcenodes asx'; as' = asx @ a # asx';\n         sourcenode a = n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  ns' = sourcenodes asx'\n  as' = asx @ a # asx'\n  sourcenode a = n'\n\ngoal (1 subgoal):\n 1. n = n'", "from \\<open>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"n' -a#asx'\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n' -a # asx'\\<rightarrow>\\<^sub>\\<iota>* pex", "by(fastforce dest:path_split_second simp:intra_path_def)"], ["proof (state)\nthis:\n  n' -a # asx'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n = n'", "with \\<open>n postdominates n'\\<close> \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  n postdominates n'\n  method_exit pex\n  n' -a # asx'\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"n \\<in> set(sourcenodes (a#asx'))\""], ["proof (prove)\nusing this:\n  n postdominates n'\n  method_exit pex\n  n' -a # asx'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes (a # asx'))", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  n \\<in> set (sourcenodes (a # asx'))\n\ngoal (1 subgoal):\n 1. n = n'", "hence \"n = n' \\<or> n \\<in> set(sourcenodes asx')\""], ["proof (prove)\nusing this:\n  n \\<in> set (sourcenodes (a # asx'))\n\ngoal (1 subgoal):\n 1. n = n' \\<or> n \\<in> set (sourcenodes asx')", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n = n' \\<or> n \\<in> set (sourcenodes asx')\n\ngoal (1 subgoal):\n 1. n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = n' \\<or> n \\<in> set (sourcenodes asx')\n\ngoal (1 subgoal):\n 1. n = n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n = n' \\<Longrightarrow> n = n'\n 2. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "assume \"n = n'\""], ["proof (state)\nthis:\n  n = n'\n\ngoal (2 subgoals):\n 1. n = n' \\<Longrightarrow> n = n'\n 2. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = n'\n\ngoal (1 subgoal):\n 1. n = n'", "."], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "assume \"n \\<in> set(sourcenodes asx')\""], ["proof (state)\nthis:\n  n \\<in> set (sourcenodes asx')\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "then"], ["proof (chain)\npicking this:\n  n \\<in> set (sourcenodes asx')", "obtain nsx' nsx'' where \"sourcenodes asx' = nsx'@n#nsx''\""], ["proof (prove)\nusing this:\n  n \\<in> set (sourcenodes asx')\n\ngoal (1 subgoal):\n 1. (\\<And>nsx' nsx''.\n        sourcenodes asx' = nsx' @ n # nsx'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:split_list)"], ["proof (state)\nthis:\n  sourcenodes asx' = nsx' @ n # nsx''\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "then"], ["proof (chain)\npicking this:\n  sourcenodes asx' = nsx' @ n # nsx''", "obtain asi asi' a' where [simp]:\"asx' = asi@a'#asi'\" \"sourcenode a' = n\""], ["proof (prove)\nusing this:\n  sourcenodes asx' = nsx' @ n # nsx''\n\ngoal (1 subgoal):\n 1. (\\<And>asi a' asi'.\n        \\<lbrakk>asx' = asi @ a' # asi'; sourcenode a' = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  asx' = asi @ a' # asi'\n  sourcenode a' = n\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "with \\<open>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx' = asi @ a' # asi'\n  sourcenode a' = n", "have \"n -(asx@a#asi)@a'#asi'\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx' = asi @ a' # asi'\n  sourcenode a' = n\n\ngoal (1 subgoal):\n 1. n -(asx @ a # asi) @ a' # asi'\\<rightarrow>\\<^sub>\\<iota>* pex", "by simp"], ["proof (state)\nthis:\n  n -(asx @ a # asi) @ a' # asi'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "hence \"n -(asx@a#asi)@a'#asi'\\<rightarrow>* pex\"\n      and \"\\<forall>a \\<in> set ((asx@a#asi)@a'#asi'). intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  n -(asx @ a # asi) @ a' # asi'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n -(asx @ a # asi) @ a' # asi'\\<rightarrow>* pex &&&\n    \\<forall>a\\<in>set ((asx @ a # asi) @ a' # asi'). intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  n -(asx @ a # asi) @ a' # asi'\\<rightarrow>* pex\n  \\<forall>a\\<in>set ((asx @ a # asi) @ a' # asi'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "from \\<open>n -(asx@a#asi)@a'#asi'\\<rightarrow>* pex\\<close>"], ["proof (chain)\npicking this:\n  n -(asx @ a # asi) @ a' # asi'\\<rightarrow>* pex", "have \"n -a'#asi'\\<rightarrow>* pex\""], ["proof (prove)\nusing this:\n  n -(asx @ a # asi) @ a' # asi'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. n -a' # asi'\\<rightarrow>* pex", "by(fastforce dest:path_split_second)"], ["proof (state)\nthis:\n  n -a' # asi'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "with \\<open>\\<forall>a \\<in> set ((asx@a#asi)@a'#asi'). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set ((asx @ a # asi) @ a' # asi'). intra_kind (kind a)\n  n -a' # asi'\\<rightarrow>* pex", "have \"n -a'#asi'\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ((asx @ a # asi) @ a' # asi'). intra_kind (kind a)\n  n -a' # asi'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. n -a' # asi'\\<rightarrow>\\<^sub>\\<iota>* pex", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  n -a' # asi'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "with \\<open>n' postdominates n\\<close> \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates n\n  method_exit pex\n  n -a' # asi'\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"n' \\<in> set(sourcenodes (a'#asi'))\""], ["proof (prove)\nusing this:\n  n' postdominates n\n  method_exit pex\n  n -a' # asi'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes (a' # asi'))", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes (a' # asi'))\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "hence \"n' = n \\<or> n' \\<in> set(sourcenodes asi')\""], ["proof (prove)\nusing this:\n  n' \\<in> set (sourcenodes (a' # asi'))\n\ngoal (1 subgoal):\n 1. n' = n \\<or> n' \\<in> set (sourcenodes asi')", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n' = n \\<or> n' \\<in> set (sourcenodes asi')\n\ngoal (1 subgoal):\n 1. n \\<in> set (sourcenodes asx') \\<Longrightarrow> n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n' = n \\<or> n' \\<in> set (sourcenodes asi')\n\ngoal (1 subgoal):\n 1. n = n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = n \\<Longrightarrow> n = n'\n 2. n' \\<in> set (sourcenodes asi') \\<Longrightarrow> n = n'", "assume \"n' = n\""], ["proof (state)\nthis:\n  n' = n\n\ngoal (2 subgoals):\n 1. n' = n \\<Longrightarrow> n = n'\n 2. n' \\<in> set (sourcenodes asi') \\<Longrightarrow> n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n' = n\n\ngoal (1 subgoal):\n 1. n = n'", "by(rule sym)"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes asi') \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes asi') \\<Longrightarrow> n = n'", "assume \"n' \\<in> set(sourcenodes asi')\""], ["proof (state)\nthis:\n  n' \\<in> set (sourcenodes asi')\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes asi') \\<Longrightarrow> n = n'", "with \\<open>\\<forall>nx \\<in> set ns'. nx \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>nx\\<in>set ns'. nx \\<noteq> n'\n  n' \\<in> set (sourcenodes asi')", "have False"], ["proof (prove)\nusing this:\n  \\<forall>nx\\<in>set ns'. nx \\<noteq> n'\n  n' \\<in> set (sourcenodes asi')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n' \\<in> set (sourcenodes asi') \\<Longrightarrow> n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma postdominate_path_branch:\n  assumes \"n -as\\<rightarrow>* n''\" and \"n' postdominates n''\" and \"\\<not> n' postdominates n\"\n  obtains a as' as'' where \"as = as'@a#as''\" and \"valid_edge a\"\n  and \"\\<not> n' postdominates (sourcenode a)\" and \"n' postdominates (targetnode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>as = as' @ a # as''; valid_edge a;\n         \\<not> n' postdominates sourcenode a;\n         n' postdominates targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' a as''.\n       as = as' @ a # as'' \\<and>\n       valid_edge a \\<and>\n       \\<not> n' postdominates sourcenode a \\<and>\n       n' postdominates targetnode a", "from assms"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n''\n  n' postdominates n''\n  \\<not> n' postdominates n", "show \"\\<exists>as' a as''. as = as'@a#as'' \\<and> valid_edge a \\<and> \n    \\<not> n' postdominates (sourcenode a) \\<and> n' postdominates (targetnode a)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n''\n  n' postdominates n''\n  \\<not> n' postdominates n\n\ngoal (1 subgoal):\n 1. \\<exists>as' a as''.\n       as = as' @ a # as'' \\<and>\n       valid_edge a \\<and>\n       \\<not> n' postdominates sourcenode a \\<and>\n       n' postdominates targetnode a", "proof(induct rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n' postdominates n;\n        \\<not> n' postdominates n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a as''.\n                            [] = as' @ a # as'' \\<and>\n                            valid_edge a \\<and>\n                            \\<not> n' postdominates sourcenode a \\<and>\n                            n' postdominates targetnode a\n 2. \\<And>n'' as n'a a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n'a;\n        \\<lbrakk>n' postdominates n'a; \\<not> n' postdominates n''\\<rbrakk>\n        \\<Longrightarrow> \\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             valid_edge a \\<and>\n                             \\<not> n' postdominates sourcenode a \\<and>\n                             n' postdominates targetnode a;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' postdominates n'a; \\<not> n' postdominates n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' aa as''.\n                            a # as = as' @ aa # as'' \\<and>\n                            valid_edge aa \\<and>\n                            \\<not> n' postdominates sourcenode aa \\<and>\n                            n' postdominates targetnode aa", "case (Cons_path n'' as nx a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* nx\n  \\<lbrakk>n' postdominates nx; \\<not> n' postdominates n''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as' a as''.\n                       as = as' @ a # as'' \\<and>\n                       valid_edge a \\<and>\n                       \\<not> n' postdominates sourcenode a \\<and>\n                       n' postdominates targetnode a\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n' postdominates nx\n  \\<not> n' postdominates n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n' postdominates n;\n        \\<not> n' postdominates n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a as''.\n                            [] = as' @ a # as'' \\<and>\n                            valid_edge a \\<and>\n                            \\<not> n' postdominates sourcenode a \\<and>\n                            n' postdominates targetnode a\n 2. \\<And>n'' as n'a a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n'a;\n        \\<lbrakk>n' postdominates n'a; \\<not> n' postdominates n''\\<rbrakk>\n        \\<Longrightarrow> \\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             valid_edge a \\<and>\n                             \\<not> n' postdominates sourcenode a \\<and>\n                             n' postdominates targetnode a;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' postdominates n'a; \\<not> n' postdominates n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' aa as''.\n                            a # as = as' @ aa # as'' \\<and>\n                            valid_edge aa \\<and>\n                            \\<not> n' postdominates sourcenode aa \\<and>\n                            n' postdominates targetnode aa", "note IH = \\<open>\\<lbrakk>n' postdominates nx; \\<not> n' postdominates n''\\<rbrakk>\n      \\<Longrightarrow> \\<exists>as' a as''. as = as'@a#as'' \\<and> valid_edge a \\<and>\n        \\<not> n' postdominates sourcenode a \\<and> n' postdominates targetnode a\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n' postdominates nx; \\<not> n' postdominates n''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as' a as''.\n                       as = as' @ a # as'' \\<and>\n                       valid_edge a \\<and>\n                       \\<not> n' postdominates sourcenode a \\<and>\n                       n' postdominates targetnode a\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n' postdominates n;\n        \\<not> n' postdominates n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a as''.\n                            [] = as' @ a # as'' \\<and>\n                            valid_edge a \\<and>\n                            \\<not> n' postdominates sourcenode a \\<and>\n                            n' postdominates targetnode a\n 2. \\<And>n'' as n'a a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* n'a;\n        \\<lbrakk>n' postdominates n'a; \\<not> n' postdominates n''\\<rbrakk>\n        \\<Longrightarrow> \\<exists>as' a as''.\n                             as = as' @ a # as'' \\<and>\n                             valid_edge a \\<and>\n                             \\<not> n' postdominates sourcenode a \\<and>\n                             n' postdominates targetnode a;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' postdominates n'a; \\<not> n' postdominates n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' aa as''.\n                            a # as = as' @ aa # as'' \\<and>\n                            valid_edge aa \\<and>\n                            \\<not> n' postdominates sourcenode aa \\<and>\n                            n' postdominates targetnode aa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "proof(cases \"n' postdominates n''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n' postdominates n'' \\<Longrightarrow>\n    \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa\n 2. \\<not> n' postdominates n'' \\<Longrightarrow>\n    \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "case True"], ["proof (state)\nthis:\n  n' postdominates n''\n\ngoal (2 subgoals):\n 1. n' postdominates n'' \\<Longrightarrow>\n    \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa\n 2. \\<not> n' postdominates n'' \\<Longrightarrow>\n    \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "with \\<open>\\<not> n' postdominates n\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close>\n        \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<not> n' postdominates n\n  sourcenode a = n\n  targetnode a = n''\n  valid_edge a\n  n' postdominates n''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n' postdominates n\n  sourcenode a = n\n  targetnode a = n''\n  valid_edge a\n  n' postdominates n''\n\ngoal (1 subgoal):\n 1. \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "by blast"], ["proof (state)\nthis:\n  \\<exists>as' aa as''.\n     a # as = as' @ aa # as'' \\<and>\n     valid_edge aa \\<and>\n     \\<not> n' postdominates sourcenode aa \\<and>\n     n' postdominates targetnode aa\n\ngoal (1 subgoal):\n 1. \\<not> n' postdominates n'' \\<Longrightarrow>\n    \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n' postdominates n'' \\<Longrightarrow>\n    \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "case False"], ["proof (state)\nthis:\n  \\<not> n' postdominates n''\n\ngoal (1 subgoal):\n 1. \\<not> n' postdominates n'' \\<Longrightarrow>\n    \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "from IH[OF \\<open>n' postdominates nx\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>as' a as''.\n     as = as' @ a # as'' \\<and>\n     valid_edge a \\<and>\n     \\<not> n' postdominates sourcenode a \\<and>\n     n' postdominates targetnode a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>as' a as''.\n     as = as' @ a # as'' \\<and>\n     valid_edge a \\<and>\n     \\<not> n' postdominates sourcenode a \\<and>\n     n' postdominates targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>as' aa as''.\n       a # as = as' @ aa # as'' \\<and>\n       valid_edge aa \\<and>\n       \\<not> n' postdominates sourcenode aa \\<and>\n       n' postdominates targetnode aa", "by clarsimp(rule_tac x=\"a#as'\" in exI,clarsimp)"], ["proof (state)\nthis:\n  \\<exists>as' aa as''.\n     a # as = as' @ aa # as'' \\<and>\n     valid_edge aa \\<and>\n     \\<not> n' postdominates sourcenode aa \\<and>\n     n' postdominates targetnode aa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as' aa as''.\n     a # as = as' @ aa # as'' \\<and>\n     valid_edge aa \\<and>\n     \\<not> n' postdominates sourcenode aa \\<and>\n     n' postdominates targetnode aa\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>valid_node n; n' postdominates n;\n        \\<not> n' postdominates n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a as''.\n                            [] = as' @ a # as'' \\<and>\n                            valid_edge a \\<and>\n                            \\<not> n' postdominates sourcenode a \\<and>\n                            n' postdominates targetnode a", "qed simp"], ["proof (state)\nthis:\n  \\<exists>as' a as''.\n     as = as' @ a # as'' \\<and>\n     valid_edge a \\<and>\n     \\<not> n' postdominates sourcenode a \\<and>\n     n' postdominates targetnode a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_no_postdominator:\n  assumes \"(_Exit_) postdominates n\" shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>(_Exit_) postdominates n\\<close>"], ["proof (chain)\npicking this:\n  (_Exit_) postdominates n", "have \"valid_node n\""], ["proof (prove)\nusing this:\n  (_Exit_) postdominates n\n\ngoal (1 subgoal):\n 1. valid_node n", "by(simp add:postdominate_def)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. False", "from \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n", "obtain asx where \"n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:Exit_path)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as' pex where \"n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as' pex.\n        \\<lbrakk>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. False", "with \\<open>(_Exit_) postdominates n\\<close>"], ["proof (chain)\npicking this:\n  (_Exit_) postdominates n\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex", "have \"(_Exit_) \\<in> set (sourcenodes as')\""], ["proof (prove)\nusing this:\n  (_Exit_) postdominates n\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. (_Exit_) \\<in> set (sourcenodes as')", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  (_Exit_) \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. False", "with \\<open>n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  (_Exit_) \\<in> set (sourcenodes as')", "show False"], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<iota>* pex\n  (_Exit_) \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma postdominate_inner_path_targetnode:\n  assumes \"n' postdominates n\" and \"n -as\\<rightarrow>\\<^sub>\\<iota>* n''\" and \"n' \\<notin> set(sourcenodes as)\"\n  shows \"n' postdominates n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' postdominates n''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n' postdominates n''", "from \\<open>n' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n' postdominates n", "obtain asx \n    where \"valid_node n\" and \"valid_node n'\"\n    and all:\"\\<forall>as pex. (n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and> method_exit pex) \\<longrightarrow> n' \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  n' postdominates n\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>valid_node n; valid_node n';\n      \\<forall>as pex.\n         n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n         method_exit pex \\<longrightarrow>\n         n' \\<in> set (sourcenodes as)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:postdominate_def)"], ["proof (state)\nthis:\n  valid_node n\n  valid_node n'\n  \\<forall>as pex.\n     n -as\\<rightarrow>\\<^sub>\\<iota>* pex \\<and>\n     method_exit pex \\<longrightarrow>\n     n' \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. n' postdominates n''", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n''\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n''", "have \"valid_node n''\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n''\n\ngoal (1 subgoal):\n 1. valid_node n''", "by(fastforce dest:path_valid_node simp:intra_path_def)"], ["proof (state)\nthis:\n  valid_node n''\n\ngoal (1 subgoal):\n 1. n' postdominates n''", "have \"\\<forall>as' pex'. (n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and> method_exit pex') \\<longrightarrow> \n                   n' \\<in> set (sourcenodes as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>as' pex'.\n       n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n       method_exit pex' \\<longrightarrow>\n       n' \\<in> set (sourcenodes as')", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>as' pex'.\n               n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n               method_exit pex' \\<longrightarrow>\n               n' \\<in> set (sourcenodes as')) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>as' pex'. (n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and> method_exit pex') \\<longrightarrow> \n                          n' \\<in> set (sourcenodes as'))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>as' pex'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n             method_exit pex' \\<longrightarrow>\n             n' \\<in> set (sourcenodes as'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>as' pex'.\n               n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n               method_exit pex' \\<longrightarrow>\n               n' \\<in> set (sourcenodes as')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>as' pex'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n             method_exit pex' \\<longrightarrow>\n             n' \\<in> set (sourcenodes as'))", "obtain as' pex' where \"n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex'\" and \"method_exit pex'\"\n      and \"n' \\<notin> set (sourcenodes as')\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>as' pex'.\n             n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n             method_exit pex' \\<longrightarrow>\n             n' \\<in> set (sourcenodes as'))\n\ngoal (1 subgoal):\n 1. (\\<And>as' pex'.\n        \\<lbrakk>n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex';\n         method_exit pex'; n' \\<notin> set (sourcenodes as')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex'\n  method_exit pex'\n  n' \\<notin> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>as' pex'.\n               n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n               method_exit pex' \\<longrightarrow>\n               n' \\<in> set (sourcenodes as')) \\<Longrightarrow>\n    False", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* n''\\<close> \\<open>n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n''\n  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex'", "have \"n -as@as'\\<rightarrow>\\<^sub>\\<iota>* pex'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* n''\n  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex'\n\ngoal (1 subgoal):\n 1. n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* pex'", "by(fastforce intro:path_Append simp:intra_path_def)"], ["proof (state)\nthis:\n  n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* pex'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>as' pex'.\n               n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n               method_exit pex' \\<longrightarrow>\n               n' \\<in> set (sourcenodes as')) \\<Longrightarrow>\n    False", "from \\<open>n' \\<notin> set(sourcenodes as)\\<close> \\<open>n' \\<notin> set (sourcenodes as')\\<close>"], ["proof (chain)\npicking this:\n  n' \\<notin> set (sourcenodes as)\n  n' \\<notin> set (sourcenodes as')", "have \"n' \\<notin> set (sourcenodes (as@as'))\""], ["proof (prove)\nusing this:\n  n' \\<notin> set (sourcenodes as)\n  n' \\<notin> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. n' \\<notin> set (sourcenodes (as @ as'))", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  n' \\<notin> set (sourcenodes (as @ as'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>as' pex'.\n               n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n               method_exit pex' \\<longrightarrow>\n               n' \\<in> set (sourcenodes as')) \\<Longrightarrow>\n    False", "with \\<open>n -as@as'\\<rightarrow>\\<^sub>\\<iota>* pex'\\<close> \\<open>method_exit pex'\\<close> \\<open>n' postdominates n\\<close>"], ["proof (chain)\npicking this:\n  n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* pex'\n  method_exit pex'\n  n' postdominates n\n  n' \\<notin> set (sourcenodes (as @ as'))", "show False"], ["proof (prove)\nusing this:\n  n -as @ as'\\<rightarrow>\\<^sub>\\<iota>* pex'\n  method_exit pex'\n  n' postdominates n\n  n' \\<notin> set (sourcenodes (as @ as'))\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>as' pex'.\n     n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n     method_exit pex' \\<longrightarrow>\n     n' \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. n' postdominates n''", "with \\<open>valid_node n'\\<close> \\<open>valid_node n''\\<close>"], ["proof (chain)\npicking this:\n  valid_node n'\n  valid_node n''\n  \\<forall>as' pex'.\n     n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n     method_exit pex' \\<longrightarrow>\n     n' \\<in> set (sourcenodes as')", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_node n'\n  valid_node n''\n  \\<forall>as' pex'.\n     n'' -as'\\<rightarrow>\\<^sub>\\<iota>* pex' \\<and>\n     method_exit pex' \\<longrightarrow>\n     n' \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. n' postdominates n''", "by(auto simp:postdominate_def)"], ["proof (state)\nthis:\n  n' postdominates n''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_postdominate_source_not_postdominate_target:\n  assumes \"\\<not> n postdominates (sourcenode a)\" \n  and \"valid_node n\" and \"valid_edge a\" and \"intra_kind (kind a)\"\n  obtains ax where \"sourcenode a = sourcenode ax\" and \"valid_edge ax\"\n  and \"\\<not> n postdominates targetnode ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>sourcenode a = sourcenode ax; valid_edge ax;\n         \\<not> n postdominates targetnode ax\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "show \"\\<exists>ax. sourcenode a = sourcenode ax \\<and> valid_edge ax \\<and> \n    \\<not> n postdominates targetnode ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "from assms"], ["proof (chain)\npicking this:\n  \\<not> n postdominates sourcenode a\n  valid_node n\n  valid_edge a\n  intra_kind (kind a)", "obtain asx pex \n      where \"sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\"\n      and \"n \\<notin> set(sourcenodes asx)\""], ["proof (prove)\nusing this:\n  \\<not> n postdominates sourcenode a\n  valid_node n\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>asx pex.\n        \\<lbrakk>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex; n \\<notin> set (sourcenodes asx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  n \\<notin> set (sourcenodes asx)\n\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "proof(cases asx)"], ["proof (state)\ngoal (2 subgoals):\n 1. asx = [] \\<Longrightarrow>\n    \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n 2. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "case Nil"], ["proof (state)\nthis:\n  asx = []\n\ngoal (2 subgoals):\n 1. asx = [] \\<Longrightarrow>\n    \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n 2. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "with \\<open>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = []", "have \"pex = sourcenode a\""], ["proof (prove)\nusing this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = []\n\ngoal (1 subgoal):\n 1. pex = sourcenode a", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  pex = sourcenode a\n\ngoal (2 subgoals):\n 1. asx = [] \\<Longrightarrow>\n    \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n 2. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "with \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  method_exit pex\n  pex = sourcenode a", "have \"method_exit (sourcenode a)\""], ["proof (prove)\nusing this:\n  method_exit pex\n  pex = sourcenode a\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  method_exit (sourcenode a)\n\ngoal (2 subgoals):\n 1. asx = [] \\<Longrightarrow>\n    \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n 2. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "thus ?thesis"], ["proof (prove)\nusing this:\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a = (_Exit_) \\<Longrightarrow>\n    \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n 2. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "assume \"sourcenode a = (_Exit_)\""], ["proof (state)\nthis:\n  sourcenode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Exit_) \\<Longrightarrow>\n    \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n 2. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Exit_) \\<Longrightarrow>\n    \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n 2. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "by simp"], ["proof (state)\nthis:\n  \\<exists>ax.\n     sourcenode a = sourcenode ax \\<and>\n     valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "fix a' Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "assume \"sourcenode a = sourcenode a'\"\n          and \"valid_edge a'\" and \"kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  sourcenode a = sourcenode a'\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "hence False"], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "using \\<open>intra_kind (kind a)\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  intra_kind (kind a)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>aa Q f p.\n       \\<lbrakk>sourcenode a = sourcenode aa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ax.\n                            sourcenode a = sourcenode ax \\<and>\n                            valid_edge ax \\<and>\n                            \\<not> n postdominates targetnode ax", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "by simp"], ["proof (state)\nthis:\n  \\<exists>ax.\n     sourcenode a = sourcenode ax \\<and>\n     valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ax.\n     sourcenode a = sourcenode ax \\<and>\n     valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "case (Cons ax asx')"], ["proof (state)\nthis:\n  asx = ax # asx'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "with \\<open>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = ax # asx'", "have \"sourcenode a -[]@ax#asx'\\<rightarrow>* pex\" \n        and \"\\<forall>a \\<in> set (ax#asx'). intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = ax # asx'\n\ngoal (1 subgoal):\n 1. sourcenode a -[] @ ax # asx'\\<rightarrow>* pex &&&\n    \\<forall>a\\<in>set (ax # asx'). intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -[] @ ax # asx'\\<rightarrow>* pex\n  \\<forall>a\\<in>set (ax # asx'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "from \\<open>sourcenode a -[]@ax#asx'\\<rightarrow>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -[] @ ax # asx'\\<rightarrow>* pex", "have \"sourcenode a = sourcenode ax\" and \"valid_edge ax\"\n        and \"targetnode ax -asx'\\<rightarrow>* pex\""], ["proof (prove)\nusing this:\n  sourcenode a -[] @ ax # asx'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. sourcenode a = sourcenode ax &&&\n    valid_edge ax &&& targetnode ax -asx'\\<rightarrow>* pex", "by(fastforce dest:path_split)+"], ["proof (state)\nthis:\n  sourcenode a = sourcenode ax\n  valid_edge ax\n  targetnode ax -asx'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "with \\<open>\\<forall>a \\<in> set (ax#asx'). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (ax # asx'). intra_kind (kind a)\n  sourcenode a = sourcenode ax\n  valid_edge ax\n  targetnode ax -asx'\\<rightarrow>* pex", "have \"targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (ax # asx'). intra_kind (kind a)\n  sourcenode a = sourcenode ax\n  valid_edge ax\n  targetnode ax -asx'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "with \\<open>n \\<notin> set(sourcenodes asx)\\<close> Cons \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  n \\<notin> set (sourcenodes asx)\n  asx = ax # asx'\n  method_exit pex\n  targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"\\<not> n postdominates targetnode ax\""], ["proof (prove)\nusing this:\n  n \\<notin> set (sourcenodes asx)\n  asx = ax # asx'\n  method_exit pex\n  targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates targetnode ax", "by(fastforce simp:postdominate_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<not> n postdominates targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       asx = aa # list \\<Longrightarrow>\n       \\<exists>ax.\n          sourcenode a = sourcenode ax \\<and>\n          valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "with \\<open>sourcenode a = sourcenode ax\\<close> \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode ax\n  valid_edge ax\n  \\<not> n postdominates targetnode ax", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode ax\n  valid_edge ax\n  \\<not> n postdominates targetnode ax\n\ngoal (1 subgoal):\n 1. \\<exists>ax.\n       sourcenode a = sourcenode ax \\<and>\n       valid_edge ax \\<and> \\<not> n postdominates targetnode ax", "by blast"], ["proof (state)\nthis:\n  \\<exists>ax.\n     sourcenode a = sourcenode ax \\<and>\n     valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ax.\n     sourcenode a = sourcenode ax \\<and>\n     valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ax.\n     sourcenode a = sourcenode ax \\<and>\n     valid_edge ax \\<and> \\<not> n postdominates targetnode ax\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_node_Exit_edge:\n  assumes \"inner_node n\" \n  obtains a where \"valid_edge a\" and \"intra_kind (kind a)\" \n  and \"inner_node (sourcenode a)\" and \"targetnode a = (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; intra_kind (kind a);\n         inner_node (sourcenode a); targetnode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "from \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n", "have \"valid_node n\""], ["proof (prove)\nusing this:\n  inner_node n\n\ngoal (1 subgoal):\n 1. valid_node n", "by(rule inner_is_valid)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "then"], ["proof (chain)\npicking this:\n  valid_node n", "obtain as where \"n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "show \"\\<exists>a. valid_edge a \\<and> intra_kind (kind a) \\<and> inner_node (sourcenode a) \\<and> \n    targetnode a = (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "with \\<open>inner_node n\\<close> \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = []", "have False"], ["proof (prove)\nusing this:\n  inner_node n\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as = []\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp:vp_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as \\<noteq> []", "obtain a' as' where \"as = as'@[a']\" \n      and \"n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\" and \"valid_edge a'\" \n      and \"(_Exit_) = targetnode a'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        \\<lbrakk>as = as' @ [a'];\n         n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'; valid_edge a';\n         (_Exit_) = targetnode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule vp_split_snoc)"], ["proof (state)\nthis:\n  as = as' @ [a']\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  valid_edge a'\n  (_Exit_) = targetnode a'\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "from \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'", "have \"valid_node (sourcenode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a')", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "proof(cases \"sourcenode a'\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 3. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "case Entry"], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 3. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "with \\<open>n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  sourcenode a' = (_Entry_)", "have \"n -as'\\<rightarrow>* (_Entry_)\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* sourcenode a'\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>* (_Entry_)", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* (_Entry_)\n\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 3. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "with \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  n -as'\\<rightarrow>* (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  inner_node n\n  n -as'\\<rightarrow>* (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule path_Entry_target,auto simp:inner_node_def)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. sourcenode a' = (_Entry_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 3. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "case Exit"], ["proof (state)\nthis:\n  sourcenode a' = (_Exit_)\n\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "from \\<open>valid_edge a'\\<close> this"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n 2. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "case inner"], ["proof (state)\nthis:\n  inner_node (sourcenode a')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "have \"intra_kind (kind a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow> intra_kind (kind a')\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow> intra_kind (kind a')\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "case (Call Q r p fs)"], ["proof (state)\nthis:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc(targetnode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a') = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a') = p\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>(_Exit_) = targetnode a'\\<close> get_proc_Exit"], ["proof (chain)\npicking this:\n  (_Exit_) = targetnode a'\n  get_proc (_Exit_) = Main\n  get_proc (targetnode a') = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  (_Exit_) = targetnode a'\n  get_proc (_Exit_) = Main\n  get_proc (targetnode a') = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main", "have \"kind a' = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a' = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(_Exit_) = targetnode a'\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_no_return_target)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "with \\<open>valid_edge a'\\<close> \\<open>(_Exit_) = targetnode a'\\<close> \\<open>inner_node (sourcenode a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  (_Exit_) = targetnode a'\n  inner_node (sourcenode a')\n  intra_kind (kind a')", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a'\n  (_Exit_) = targetnode a'\n  inner_node (sourcenode a')\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (sourcenode a) \\<and> targetnode a = (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_node_Entry_edge:\n  assumes \"inner_node n\" \n  obtains a where \"valid_edge a\" and \"intra_kind (kind a)\" \n  and \"inner_node (targetnode a)\" and \"sourcenode a = (_Entry_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; intra_kind (kind a);\n         inner_node (targetnode a); sourcenode a = (_Entry_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "from \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n", "have \"valid_node n\""], ["proof (prove)\nusing this:\n  inner_node n\n\ngoal (1 subgoal):\n 1. valid_node n", "by(rule inner_is_valid)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "then"], ["proof (chain)\npicking this:\n  valid_node n", "obtain as where \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Entry_path)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "show \"\\<exists>a. valid_edge a \\<and> intra_kind (kind a) \\<and> inner_node (targetnode a) \\<and> \n    sourcenode a = (_Entry_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "with \\<open>inner_node n\\<close> \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = []", "have False"], ["proof (prove)\nusing this:\n  inner_node n\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as = []\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp:inner_node_def vp_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as \\<noteq> []", "obtain a' as' where \"as = a'#as'\" \n      and \"targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n\" and \"valid_edge a'\" \n      and \"(_Entry_) = sourcenode a'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* n\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as';\n         targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n; valid_edge a';\n         (_Entry_) = sourcenode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule vp_split_Cons)"], ["proof (state)\nthis:\n  as = a' # as'\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n\n  valid_edge a'\n  (_Entry_) = sourcenode a'\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "from \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'", "have \"valid_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a')", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a')\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_node (targetnode a')\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "proof(cases \"targetnode a'\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. targetnode a' = (_Entry_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 3. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "case Entry"], ["proof (state)\nthis:\n  targetnode a' = (_Entry_)\n\ngoal (3 subgoals):\n 1. targetnode a' = (_Entry_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 3. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "from \\<open>valid_edge a'\\<close> this"], ["proof (chain)\npicking this:\n  valid_edge a'\n  targetnode a' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  targetnode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. targetnode a' = (_Entry_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 3. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n\ngoal (2 subgoals):\n 1. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "case Exit"], ["proof (state)\nthis:\n  targetnode a' = (_Exit_)\n\ngoal (2 subgoals):\n 1. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "with \\<open>targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n\n  targetnode a' = (_Exit_)", "have \"(_Exit_) -as'\\<rightarrow>* n\""], ["proof (prove)\nusing this:\n  targetnode a' -as'\\<rightarrow>\\<^sub>\\<surd>* n\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. (_Exit_) -as'\\<rightarrow>* n", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  (_Exit_) -as'\\<rightarrow>* n\n\ngoal (2 subgoals):\n 1. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "with \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  (_Exit_) -as'\\<rightarrow>* n", "have False"], ["proof (prove)\nusing this:\n  inner_node n\n  (_Exit_) -as'\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. False", "by -(drule path_Exit_source,auto simp:inner_node_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. targetnode a' = (_Exit_) \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n 2. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "case inner"], ["proof (state)\nthis:\n  inner_node (targetnode a')\n\ngoal (1 subgoal):\n 1. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "have \"intra_kind (kind a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "proof(cases \"kind a'\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow> intra_kind (kind a')\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (3 subgoals):\n 1. intra_kind (kind a') \\<Longrightarrow> intra_kind (kind a')\n 2. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 3. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "case (Call Q r p fs)"], ["proof (state)\nthis:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \n          \\<open>(_Entry_) = sourcenode a'\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_no_call_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind a')\n 2. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc(sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>(_Entry_) = sourcenode a'\\<close> get_proc_Entry"], ["proof (chain)\npicking this:\n  (_Entry_) = sourcenode a'\n  get_proc (_Entry_) = Main\n  get_proc (sourcenode a') = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode a'\n  get_proc (_Entry_) = Main\n  get_proc (sourcenode a') = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"kind a' = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a' = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind a' = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>Q p f.\n       kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind a')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. inner_node (targetnode a') \\<Longrightarrow>\n    \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "with \\<open>valid_edge a'\\<close> \\<open>(_Entry_) = sourcenode a'\\<close> \\<open>inner_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  (_Entry_) = sourcenode a'\n  inner_node (targetnode a')\n  intra_kind (kind a')", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a'\n  (_Entry_) = sourcenode a'\n  inner_node (targetnode a')\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge a \\<and>\n       intra_kind (kind a) \\<and>\n       inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge a \\<and>\n     intra_kind (kind a) \\<and>\n     inner_node (targetnode a) \\<and> sourcenode a = (_Entry_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intra_path_to_matching_method_exit:\n  assumes \"method_exit n'\" and \"get_proc n = get_proc n'\" and \"valid_node n\"\n  obtains as where \"n -as\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        n -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "from \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n", "obtain as' where \"n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "then"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as mex where \"n -as\\<rightarrow>\\<^sub>\\<iota>* mex\" and \"method_exit mex\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as mex.\n        \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* mex;\n         method_exit mex\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* mex\n  method_exit mex\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* mex\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* mex", "have \"get_proc n = get_proc mex\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* mex\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc mex", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc n = get_proc mex\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "with \\<open>method_exit n'\\<close> \\<open>get_proc n = get_proc n'\\<close> \\<open>method_exit mex\\<close>"], ["proof (chain)\npicking this:\n  method_exit n'\n  get_proc n = get_proc n'\n  method_exit mex\n  get_proc n = get_proc mex", "have \"mex = n'\""], ["proof (prove)\nusing this:\n  method_exit n'\n  get_proc n = get_proc n'\n  method_exit mex\n  get_proc n = get_proc mex\n\ngoal (1 subgoal):\n 1. mex = n'", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  mex = n'\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "with \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* mex\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* mex\n  mex = n'", "show \"\\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* mex\n  mex = n'\n\ngoal (1 subgoal):\n 1. \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. n -as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}