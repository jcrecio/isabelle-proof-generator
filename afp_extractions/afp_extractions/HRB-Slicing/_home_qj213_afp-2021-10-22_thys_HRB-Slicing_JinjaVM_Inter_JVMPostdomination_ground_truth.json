{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/JinjaVM_Inter/JVMPostdomination.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma vp_snocI:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<surd>* n'; n' -[a]\\<rightarrow>* n''; \\<forall>Q p ret fs. kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>ret \\<rbrakk> \\<Longrightarrow> n -as @ [a]\\<rightarrow>\\<^sub>\\<surd>* n''\"", "lemma valid_node_cases' [case_names Source Target, consumes 1]:\n  \"\\<lbrakk> valid_node n; \\<And>e. \\<lbrakk> valid_edge e; sourcenode e = n \\<rbrakk> \\<Longrightarrow> thesis;\n  \\<And>e. \\<lbrakk> valid_edge e; targetnode e = n \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk>\n  \\<Longrightarrow> thesis\"", "lemma disjE_strong: \"\\<lbrakk>P \\<or> Q; P \\<Longrightarrow> R; \\<lbrakk>Q; \\<not> P\\<rbrakk> \\<Longrightarrow> R\\<rbrakk> \\<Longrightarrow> R\"", "lemmas path_intros [intro] = JVMCFG_Interpret.path.Cons_path JVMCFG_Interpret.path.empty_path", "lemma\n  \"(P, C0, Main) \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  \\<Longrightarrow> (\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n  (get_return_edges P) (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)) \\<and>\n  (\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n  (get_return_edges P) (ClassMain P, MethodMain P, None, Enter) as (C', M', pc', nt'))\"\n  and valid_Entry_path: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  \\<Longrightarrow> \\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n  (get_return_edges P) (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)\"", "lemma distinct_classes'':\n  \"''C'' \\<noteq> Object\"\n  \"''C'' \\<noteq> NullPointer\"\n  \"''C'' \\<noteq> OutOfMemory\"\n  \"''C'' \\<noteq> ClassCast\"", "lemmas distinct_classes =\n  distinct_classes distinct_classes'' distinct_classes'' [symmetric]", "lemma i_max_2D: \"i < Suc (Suc 0) \\<Longrightarrow> i = 0 \\<or> i = 1\"", "lemma EP_wf: \"wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\"", "lemma [simp]: \"PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP\"", "lemma [simp]: \"TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP\"", "lemma method_in_EP_is_M:\n  \"EP \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl, is, xt) in D\n  \\<Longrightarrow> C = ''C'' \\<and> M = ''M'' \\<and> Ts = [] \\<and> T = Void \\<and> mxs = 1 \\<and> mxl = 0 \\<and>\n  is = [Push Unit, instr.Return] \\<and> xt = [] \\<and> D = ''C''\"", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> is \\<noteq> []\"", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> \n  Suc 0 < length is\"", "lemma C_sees_M_in_EP [simp]:\n  \"EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0, [Push Unit, instr.Return], []) in ''C''\"", "lemma instrs_of_EP_C_M [simp]:\n  \"instrs_of EP ''C'' ''M'' = [Push Unit, instr.Return]\"", "lemma ClassMain_not_C [simp]: \"ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<noteq> ''C''\"", "lemma method_entry [dest!]: \"(Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<Longrightarrow> (C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<and> M = MethodMain (Abs_wf_jvmprog (EP, Phi_EP)))\n  \\<or> (C = ''C'' \\<and> M = ''M'')\"", "lemma valid_node_in_EP_D:\n  assumes vn: \"JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M'' n\"\n  shows \"n \\<in> {\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Return),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Enter),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Normal),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Return),\n  (''C'', ''M'', None, Enter),\n  (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n  (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n  (''C'', ''M'', None, Return)\n  }\"", "lemma Main_Entry_valid [simp]:\n  \"JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\"", "lemma main_0_Enter_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\"", "lemma main_0_Normal_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\"", "lemma main_0_Return_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Return)\"", "lemma Exit_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, None, Return)\"", "lemma valid_edge_CFG_def: \"valid_edge\\<^bsub>CFG\\<^esub> P = valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P))\""], "translations": [["", "lemma vp_snocI:\n  \"\\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<surd>* n'; n' -[a]\\<rightarrow>* n''; \\<forall>Q p ret fs. kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>ret \\<rbrakk> \\<Longrightarrow> n -as @ [a]\\<rightarrow>\\<^sub>\\<surd>* n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<surd>* n';\n     n' -[a]\\<rightarrow>* n'';\n     \\<forall>Q p ret fs.\n        kind a \\<noteq> Q\\<hookleftarrow>\\<^bsub>p\\<^esub>ret\\<rbrakk>\n    \\<Longrightarrow> n -as @ [a]\\<rightarrow>\\<^sub>\\<surd>* n''", "by (cases \"kind a\") (auto intro: path_Append valid_path_aux_Append simp: vp_def valid_path_def)"], ["", "lemma valid_node_cases' [case_names Source Target, consumes 1]:\n  \"\\<lbrakk> valid_node n; \\<And>e. \\<lbrakk> valid_edge e; sourcenode e = n \\<rbrakk> \\<Longrightarrow> thesis;\n  \\<And>e. \\<lbrakk> valid_edge e; targetnode e = n \\<rbrakk> \\<Longrightarrow> thesis \\<rbrakk>\n  \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node n;\n     \\<And>e.\n        \\<lbrakk>valid_edge e; sourcenode e = n\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>e.\n        \\<lbrakk>valid_edge e; targetnode e = n\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: valid_node_def)"], ["", "end"], ["", "lemma disjE_strong: \"\\<lbrakk>P \\<or> Q; P \\<Longrightarrow> R; \\<lbrakk>Q; \\<not> P\\<rbrakk> \\<Longrightarrow> R\\<rbrakk> \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<or> Q; P \\<Longrightarrow> R;\n     \\<lbrakk>Q; \\<not> P\\<rbrakk> \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by auto"], ["", "lemmas path_intros [intro] = JVMCFG_Interpret.path.Cons_path JVMCFG_Interpret.path.empty_path"], ["", "declare JVMCFG_Interpret.vp_snocI [intro]"], ["", "declare JVMCFG_Interpret.valid_node_def [simp add]\n  valid_edge_def [simp add]\n  JVMCFG_Interpret.intra_path_def [simp add]"], ["", "abbreviation vp_snoc :: \"wf_jvmprog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> cfg_edge list \\<Rightarrow> cfg_node\n  \\<Rightarrow> (var, val, cname \\<times> mname \\<times> pc, cname \\<times> mname) edge_kind \\<Rightarrow> cfg_node \\<Rightarrow> bool\"\n  where \"vp_snoc P C0 Main as n ek n'\n  \\<equiv> JVMCFG_Interpret.valid_path' P C0 Main\n  (ClassMain P, MethodMain P, None, Enter) (as @ [(n,ek,n')]) n'\""], ["", "lemma\n  \"(P, C0, Main) \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  \\<Longrightarrow> (\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n  (get_return_edges P) (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)) \\<and>\n  (\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n  (get_return_edges P) (ClassMain P, MethodMain P, None, Enter) as (C', M', pc', nt'))\"\n  and valid_Entry_path: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  \\<Longrightarrow> \\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n  (get_return_edges P) (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ( (P, C0,\n       Main) \\<turnstile> (C, M, pc,\n                           nt) -ek\\<rightarrow> (C', M', pc',\n           nt') \\<Longrightarrow>\n     (\\<exists>as.\n         JVMCFG_Interpret.valid_path' P C0 Main\n          (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)) \\<and>\n     (\\<exists>as.\n         JVMCFG_Interpret.valid_path' P C0 Main\n          (ClassMain P, MethodMain P, None, Enter) as\n          (C', M', pc', nt'))) &&&\n    ( (P, C0,\n       Main) \\<turnstile> \\<Rightarrow>(C, M, pc, nt) \\<Longrightarrow>\n     \\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt))", "proof (induct rule: JVMCFG_reachable_inducts)"], ["proof (state)\ngoal (51 subgoals):\n 1. \\<And>P C0 Main.\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' P C0 Main\n           (ClassMain P, MethodMain P, None, Enter) as\n           (ClassMain P, MethodMain P, None, Enter)\n 2. \\<And>a aa b ab ac ad ba e ae af ag bb.\n       \\<lbrakk> (a, aa, b) \\<turnstile> \\<Rightarrow>(ab, ac, ad, ba);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' a aa b\n            (ClassMain a, MethodMain a, None, Enter) as (ab, ac, ad, ba);\n         (a, aa,\n          b) \\<turnstile> (ab, ac, ad, ba) -e\\<rightarrow> (ae, af, ag, bb);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ab, ac, ad, ba)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ae, af, ag, bb))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            JVMCFG_Interpret.valid_path' a aa b\n                             (ClassMain a, MethodMain a, None, Enter) as\n                             (ae, af, ag, bb)\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 5. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 6. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 7. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Store n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Local n :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 51 subgoals...", "case (Entry_reachable P C0 Main)"], ["proof (state)\nthis:\n  \n\ngoal (51 subgoals):\n 1. \\<And>P C0 Main.\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' P C0 Main\n           (ClassMain P, MethodMain P, None, Enter) as\n           (ClassMain P, MethodMain P, None, Enter)\n 2. \\<And>a aa b ab ac ad ba e ae af ag bb.\n       \\<lbrakk> (a, aa, b) \\<turnstile> \\<Rightarrow>(ab, ac, ad, ba);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' a aa b\n            (ClassMain a, MethodMain a, None, Enter) as (ab, ac, ad, ba);\n         (a, aa,\n          b) \\<turnstile> (ab, ac, ad, ba) -e\\<rightarrow> (ae, af, ag, bb);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ab, ac, ad, ba)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ae, af, ag, bb))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            JVMCFG_Interpret.valid_path' a aa b\n                             (ClassMain a, MethodMain a, None, Enter) as\n                             (ae, af, ag, bb)\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 5. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 6. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 7. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Store n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Local n :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 51 subgoals...", "hence \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) [] (ClassMain P, MethodMain P, None, Enter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' P C0 Main\n     (ClassMain P, MethodMain P, None, Enter) []\n     (ClassMain P, MethodMain P, None, Enter)", "by (fastforce intro: JVMCFG_Interpret.intra_path_vp Method_LTrue\n      JVMCFG_reachable.Entry_reachable)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) []\n   (ClassMain P, MethodMain P, None, Enter)\n\ngoal (51 subgoals):\n 1. \\<And>P C0 Main.\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' P C0 Main\n           (ClassMain P, MethodMain P, None, Enter) as\n           (ClassMain P, MethodMain P, None, Enter)\n 2. \\<And>a aa b ab ac ad ba e ae af ag bb.\n       \\<lbrakk> (a, aa, b) \\<turnstile> \\<Rightarrow>(ab, ac, ad, ba);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' a aa b\n            (ClassMain a, MethodMain a, None, Enter) as (ab, ac, ad, ba);\n         (a, aa,\n          b) \\<turnstile> (ab, ac, ad, ba) -e\\<rightarrow> (ae, af, ag, bb);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ab, ac, ad, ba)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ae, af, ag, bb))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            JVMCFG_Interpret.valid_path' a aa b\n                             (ClassMain a, MethodMain a, None, Enter) as\n                             (ae, af, ag, bb)\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 5. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 6. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 7. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Store n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Local n :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 51 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) []\n   (ClassMain P, MethodMain P, None, Enter)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' P C0 Main\n        (ClassMain P, MethodMain P, None, Enter) as\n        (ClassMain P, MethodMain P, None, Enter)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, None, Enter)\n\ngoal (50 subgoals):\n 1. \\<And>a aa b ab ac ad ba e ae af ag bb.\n       \\<lbrakk> (a, aa, b) \\<turnstile> \\<Rightarrow>(ab, ac, ad, ba);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' a aa b\n            (ClassMain a, MethodMain a, None, Enter) as (ab, ac, ad, ba);\n         (a, aa,\n          b) \\<turnstile> (ab, ac, ad, ba) -e\\<rightarrow> (ae, af, ag, bb);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ab, ac, ad, ba)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ae, af, ag, bb))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            JVMCFG_Interpret.valid_path' a aa b\n                             (ClassMain a, MethodMain a, None, Enter) as\n                             (ae, af, ag, bb)\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 4. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 5. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc v ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Push v;\n         ek =\n         \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                 Value v)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 50 subgoals...", "next"], ["proof (state)\ngoal (50 subgoals):\n 1. \\<And>a aa b ab ac ad ba e ae af ag bb.\n       \\<lbrakk> (a, aa, b) \\<turnstile> \\<Rightarrow>(ab, ac, ad, ba);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' a aa b\n            (ClassMain a, MethodMain a, None, Enter) as (ab, ac, ad, ba);\n         (a, aa,\n          b) \\<turnstile> (ab, ac, ad, ba) -e\\<rightarrow> (ae, af, ag, bb);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ab, ac, ad, ba)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ae, af, ag, bb))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            JVMCFG_Interpret.valid_path' a aa b\n                             (ClassMain a, MethodMain a, None, Enter) as\n                             (ae, af, ag, bb)\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 4. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 5. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc v ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Push v;\n         ek =\n         \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                 Value v)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 50 subgoals...", "case (reachable_step P C0 Main C M pc nt ek C' M' pc' nt')"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)\n   (P, C0,\n    Main) \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C', M', pc', nt'))\n\ngoal (50 subgoals):\n 1. \\<And>a aa b ab ac ad ba e ae af ag bb.\n       \\<lbrakk> (a, aa, b) \\<turnstile> \\<Rightarrow>(ab, ac, ad, ba);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' a aa b\n            (ClassMain a, MethodMain a, None, Enter) as (ab, ac, ad, ba);\n         (a, aa,\n          b) \\<turnstile> (ab, ac, ad, ba) -e\\<rightarrow> (ae, af, ag, bb);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ab, ac, ad, ba)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' a aa b\n             (ClassMain a, MethodMain a, None, Enter) as\n             (ae, af, ag, bb))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            JVMCFG_Interpret.valid_path' a aa b\n                             (ClassMain a, MethodMain a, None, Enter) as\n                             (ae, af, ag, bb)\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 4. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 5. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc v ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Push v;\n         ek =\n         \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                 Value v)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 50 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)\n   (P, C0,\n    Main) \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, pc, nt)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C', M', pc', nt'))\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' P C0 Main\n        (ClassMain P, MethodMain P, None, Enter) as (C', M', pc', nt')", "by simp"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C', M', pc', nt')\n\ngoal (49 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 3. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 49 subgoals...", "next"], ["proof (state)\ngoal (49 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 3. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 49 subgoals...", "case (Main_to_Call P C0 Main)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\n\ngoal (49 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 3. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 49 subgoals...", "then"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n          Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\n\ngoal (49 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 3. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 49 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\n\ngoal (49 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 3. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 49 subgoals...", "with \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<close>"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Enter)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter) \\<Up>id\n    (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Enter)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter) \\<Up>id\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)", "by (fastforce intro: JVMCFG_reachable.Main_to_Call)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter) \\<Up>id\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (49 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 3. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 4. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 49 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter) \\<Up>id\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter) \\<Up>id\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal))\n\ngoal (48 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 2. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IAdd;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                     i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Intg (i1 + i2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 48 subgoals...", "next"], ["proof (state)\ngoal (48 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 2. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IAdd;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                     i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Intg (i1 + i2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 48 subgoals...", "case (Main_Call_LFalse P C0 Main)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (48 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 2. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IAdd;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                     i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Intg (i1 + i2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 48 subgoals...", "then"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n          Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (48 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 2. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IAdd;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                     i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Intg (i1 + i2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 48 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (48 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 2. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IAdd;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                     i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Intg (i1 + i2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 48 subgoals...", "with \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\\<close>"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal) (\\<lambda>s. False)\\<^sub>\\<surd>\n    (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Return)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n     (\\<lambda>s. False)\\<^sub>\\<surd>\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.Main_Call_LFalse)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (48 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             Normal)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return))\n 2. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 3. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IAdd;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                     i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Intg (i1 + i2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 48 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return))\n\ngoal (47 subgoals):\n 1. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 47 subgoals...", "next"], ["proof (state)\ngoal (47 subgoals):\n 1. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 47 subgoals...", "case (Main_Call P C0 Main T mxs mxl\\<^sub>0 \"is\" xt D initParams ek)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n              xt) in D\n  initParams =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  ek =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D, Main)\\<^esub>initParams\n\ngoal (47 subgoals):\n 1. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 47 subgoals...", "then"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n              xt) in D\n  initParams =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  ek =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D, Main)\\<^esub>initParams", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n              xt) in D\n  initParams =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  ek =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D, Main)\\<^esub>initParams\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n          Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (47 subgoals):\n 1. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 47 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (47 subgoals):\n 1. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 47 subgoals...", "with \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\\<close>\n    \\<open>PROG P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0, is, xt) in D\\<close>\n    \\<open>initParams = [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\\<close>\n    \\<open>ek = \\<lambda>(s, ret). True:(ClassMain P, MethodMain P, 0)\\<hookrightarrow>\\<^bsub>(D, Main)\\<^esub>initParams\\<close>"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n              xt) in D\n  initParams =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  ek =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D, Main)\\<^esub>initParams\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n    ((\\<lambda>(s, ret). True):(ClassMain P, MethodMain P, 0)\\<hookrightarrow>\\<^bsub>(D, Main)\\<^esub>[(\\<lambda>s. s Heap),(\\<lambda>s. \\<lfloor>Value Null\\<rfloor>)])\n    (D, Main, None, Enter)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n              xt) in D\n  initParams =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  ek =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(D, Main)\\<^esub>initParams\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n     (\\<lambda>(s, ret).\n         True:(ClassMain P, MethodMain P,\n               0)\\<hookrightarrow>\\<^bsub>(D,\n     Main)\\<^esub>[\\<lambda>s. s Heap,\n                   \\<lambda>s. \\<lfloor>Value Null\\<rfloor>])\n     (D, Main, None, Enter)", "by (fastforce intro: JVMCFG_reachable.Main_Call)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>(s, ret).\n       True:(ClassMain P, MethodMain P,\n             0)\\<hookrightarrow>\\<^bsub>(D,\n   Main)\\<^esub>[\\<lambda>s. s Heap,\n                 \\<lambda>s. \\<lfloor>Value Null\\<rfloor>])\n   (D, Main, None, Enter)\n\ngoal (47 subgoals):\n 1. \\<And>P C0 Main T mxs mxl\\<^sub>0 is xt D initParams ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in D;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        ek =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(D,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, Main, None, Enter))\n 2. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 47 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>(s, ret).\n       True:(ClassMain P, MethodMain P,\n             0)\\<hookrightarrow>\\<^bsub>(D,\n   Main)\\<^esub>[\\<lambda>s. s Heap,\n                 \\<lambda>s. \\<lfloor>Value Null\\<rfloor>])\n   (D, Main, None, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>(s, ret).\n       True:(ClassMain P, MethodMain P,\n             0)\\<hookrightarrow>\\<^bsub>(D,\n   Main)\\<^esub>[\\<lambda>s. s Heap,\n                 \\<lambda>s. \\<lfloor>Value Null\\<rfloor>])\n   (D, Main, None, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as (D, Main, None, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (D, Main, None, Enter))\n\ngoal (46 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = CmpEq;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                     e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Bool (e1 = e2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 46 subgoals...", "next"], ["proof (state)\ngoal (46 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = CmpEq;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                     e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Bool (e1 = e2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 46 subgoals...", "case (Main_Return_to_Exit P C0 Main)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (46 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = CmpEq;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                     e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Bool (e1 = e2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 46 subgoals...", "then"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n          nodeType.Return) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (46 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = CmpEq;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                     e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Bool (e1 = e2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 46 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (46 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = CmpEq;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                     e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Bool (e1 = e2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 46 subgoals...", "with \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\\<close>"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, nodeType.Return)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)", "have \"vp_snoc P C0 Main as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return) \\<Up>id\n    (ClassMain P, MethodMain P, None, nodeType.Return)\""], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, nodeType.Return)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n     \\<Up>id (ClassMain P, MethodMain P, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.Main_Return_to_Exit)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return) \\<Up>id\n   (ClassMain P, MethodMain P, None, nodeType.Return)\n\ngoal (46 subgoals):\n 1. \\<And>P C0 Main.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(ClassMain P,\n             MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n             nodeType.Return)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P,\n                               \\<lfloor>0\\<rfloor>, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (ClassMain P, MethodMain P, None,\n                               nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = CmpEq;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                     e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                 in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                    Value (Bool (e1 = e2)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 46 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return) \\<Up>id\n   (ClassMain P, MethodMain P, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return) \\<Up>id\n   (ClassMain P, MethodMain P, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n          nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n        nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (ClassMain P, MethodMain P, None, nodeType.Return))\n\ngoal (45 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Bool False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 45 subgoals...", "next"], ["proof (state)\ngoal (45 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Bool False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 45 subgoals...", "case (Method_LFalse P C0 Main C M)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (45 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Bool False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 45 subgoals...", "then"], ["proof (chain)\npicking this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (45 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Bool False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 45 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (45 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Bool False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 45 subgoals...", "with \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\\<close>"], ["proof (chain)\npicking this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)", "have \"vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. False)\\<^sub>\\<surd> (C, M, None, Return)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, None, Enter)\n     (\\<lambda>s. False)\\<^sub>\\<surd> (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.Method_LFalse)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. False)\\<^sub>\\<surd>\n   (C, M, None, nodeType.Return)\n\ngoal (45 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Bool False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                                Enter))\nA total of 45 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n  vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. False)\\<^sub>\\<surd>\n   (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n  vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. False)\\<^sub>\\<surd>\n   (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (44 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n             i = 1)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 44 subgoals...", "next"], ["proof (state)\ngoal (44 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n             i = 1)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 44 subgoals...", "case (Method_LTrue P C0 Main C M)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (44 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n             i = 1)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 44 subgoals...", "then"], ["proof (chain)\npicking this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (44 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n             i = 1)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 44 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (44 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n             i = 1)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 44 subgoals...", "with \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\\<close>"], ["proof (chain)\npicking this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)", "have \"vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. True)\\<^sub>\\<surd> (C, M, \\<lfloor>0\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, None, Enter)\n     (\\<lambda>s. True)\\<^sub>\\<surd> (C, M, \\<lfloor>0\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.Method_LTrue)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. True)\\<^sub>\\<surd>\n   (C, M, \\<lfloor>0\\<rfloor>, Enter)\n\ngoal (44 subgoals):\n 1. \\<And>P C0 Main C M.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None, Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, Enter)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>0\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 10. \\<And>C P C0 Main M pc i ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = IfFalse i;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n             i = 1)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 44 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n  vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. True)\\<^sub>\\<surd>\n   (C, M, \\<lfloor>0\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter)\n  vp_snoc P C0 Main as (C, M, None, Enter) (\\<lambda>s. True)\\<^sub>\\<surd>\n   (C, M, \\<lfloor>0\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>0\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>0\\<rfloor>, Enter))\n\ngoal (43 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 43 subgoals...", "next"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 43 subgoals...", "case (CFG_Load C P C0 Main M pc n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Load n\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) := s (Local n))\n\ngoal (43 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 43 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Load n\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) := s (Local n))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Load n\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) := s (Local n))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (43 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 43 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (43 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 43 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Load n\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) := s (Local n))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Load n\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) := s (Local n))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Load n\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) := s (Local n))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Load)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (43 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Load n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack (stkLength (P, C, M) pc) := s (Local n))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 9. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         (\\<lambda>s.\n             new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 43 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (42 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 42 subgoals...", "next"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 42 subgoals...", "case (CFG_Store C P C0 Main M pc n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Store n\n  ek = \\<Up>\\<lambda>s. s(Local n := s (Stack (stkLength (P, C, M) pc - 1)))\n\ngoal (42 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 42 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Store n\n  ek = \\<Up>\\<lambda>s. s(Local n := s (Stack (stkLength (P, C, M) pc - 1)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Store n\n  ek = \\<Up>\\<lambda>s. s(Local n := s (Stack (stkLength (P, C, M) pc - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (42 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 42 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (42 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 42 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Store n\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Store n\n  ek = \\<Up>\\<lambda>s. s(Local n := s (Stack (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Store n\n  ek = \\<Up>\\<lambda>s. s(Local n := s (Stack (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Store)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (42 subgoals):\n 1. \\<And>C P C0 Main M pc n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Store n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Local n := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 8. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         pc' =\n         (case match_ex_table (PROG P) OutOfMemory pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 42 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (41 subgoals):\n 1. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let a = the (new_Addr (heap_of s))\n                 in s(Heap \\<mapsto>\n                    Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                    Stack (stkLength (P, C, M) pc) \\<mapsto>\n                    Value (Addr a))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 41 subgoals...", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let a = the (new_Addr (heap_of s))\n                 in s(Heap \\<mapsto>\n                    Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                    Stack (stkLength (P, C, M) pc) \\<mapsto>\n                    Value (Addr a))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 41 subgoals...", "case (CFG_Push C P C0 Main M pc v ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Push v\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto> Value v)\n\ngoal (41 subgoals):\n 1. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let a = the (new_Addr (heap_of s))\n                 in s(Heap \\<mapsto>\n                    Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                    Stack (stkLength (P, C, M) pc) \\<mapsto>\n                    Value (Addr a))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 41 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Push v\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto> Value v)", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Push v\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto> Value v)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (41 subgoals):\n 1. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let a = the (new_Addr (heap_of s))\n                 in s(Heap \\<mapsto>\n                    Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                    Stack (stkLength (P, C, M) pc) \\<mapsto>\n                    Value (Addr a))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 41 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (41 subgoals):\n 1. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let a = the (new_Addr (heap_of s))\n                 in s(Heap \\<mapsto>\n                    Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                    Stack (stkLength (P, C, M) pc) \\<mapsto>\n                    Value (Addr a))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 41 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Push v\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto> Value v)\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Push v\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto> Value v)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Push v\n  ek = \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto> Value v)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Push)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (41 subgoals):\n 1. \\<And>C P C0 Main M pc v ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Push v;\n        ek =\n        \\<Up>\\<lambda>s. s(Stack (stkLength (P, C, M) pc) \\<mapsto>\n                Value v)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 7. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let a = the (new_Addr (heap_of s))\n                 in s(Heap \\<mapsto>\n                    Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                    Stack (stkLength (P, C, M) pc) \\<mapsto>\n                    Value (Addr a))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 41 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (40 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 40 subgoals...", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 40 subgoals...", "case (CFG_Pop C P C0 Main M pc ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Pop\n  ek = \\<Up>id\n\ngoal (40 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 40 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Pop\n  ek = \\<Up>id", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Pop\n  ek = \\<Up>id\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (40 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 40 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (40 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 40 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Pop\\<close> \\<open>ek = \\<Up>id\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Pop\n  ek = \\<Up>id\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Pop\n  ek = \\<Up>id\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Pop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (40 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Pop; ek = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 6. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 40 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (39 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 39 subgoals...", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 39 subgoals...", "case (CFG_IAdd C P C0 Main M pc ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IAdd\n  ek =\n  \\<Up>\\<lambda>s.\n          let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n              i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Intg (i1 + i2)))\n\ngoal (39 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 39 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IAdd\n  ek =\n  \\<Up>\\<lambda>s.\n          let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n              i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Intg (i1 + i2)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IAdd\n  ek =\n  \\<Up>\\<lambda>s.\n          let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n              i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Intg (i1 + i2)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (39 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 39 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (39 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 39 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = IAdd\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                   i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n    in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto> Value (Intg (i1 + i2)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IAdd\n  ek =\n  \\<Up>\\<lambda>s.\n          let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n              i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Intg (i1 + i2)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IAdd\n  ek =\n  \\<Up>\\<lambda>s.\n          let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n              i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Intg (i1 + i2)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_IAdd)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (39 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IAdd;\n        ek =\n        \\<Up>\\<lambda>s.\n                let i1 = the_Intg (stkAt s (stkLength (P, C, M) pc - 1));\n                    i2 = the_Intg (stkAt s (stkLength (P, C, M) pc - 2))\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Intg (i1 + i2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 5. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = New Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 39 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (38 subgoals):\n 1. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 38 subgoals...", "next"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 38 subgoals...", "case (CFG_Goto C P C0 Main M pc i)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Goto i\n\ngoal (38 subgoals):\n 1. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 38 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Goto i", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Goto i\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (38 subgoals):\n 1. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 38 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (38 subgoals):\n 1. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 38 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Goto i\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Goto i\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) (\\<lambda>s. True)\\<^sub>\\<surd> (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Goto i\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n     (\\<lambda>s. True)\\<^sub>\\<surd>\n     (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Goto)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n   (\\<lambda>s. True)\\<^sub>\\<surd>\n   (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)\n\ngoal (38 subgoals):\n 1. \\<And>C P C0 Main M pc i.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Goto i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 4. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 38 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n   (\\<lambda>s. True)\\<^sub>\\<surd>\n   (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n   (\\<lambda>s. True)\\<^sub>\\<surd>\n   (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter))\n\ngoal (37 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 37 subgoals...", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 37 subgoals...", "case (CFG_CmpEq C P C0 Main M pc ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = CmpEq\n  ek =\n  \\<Up>\\<lambda>s.\n          let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n              e2 = stkAt s (stkLength (P, C, M) pc - 2)\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Bool (e1 = e2)))\n\ngoal (37 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 37 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = CmpEq\n  ek =\n  \\<Up>\\<lambda>s.\n          let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n              e2 = stkAt s (stkLength (P, C, M) pc - 2)\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Bool (e1 = e2)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = CmpEq\n  ek =\n  \\<Up>\\<lambda>s.\n          let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n              e2 = stkAt s (stkLength (P, C, M) pc - 2)\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Bool (e1 = e2)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (37 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 37 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (37 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 37 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = CmpEq\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                   e2 = stkAt s (stkLength (P, C, M) pc - 2)\n    in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto> Value (Bool (e1 = e2)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = CmpEq\n  ek =\n  \\<Up>\\<lambda>s.\n          let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n              e2 = stkAt s (stkLength (P, C, M) pc - 2)\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Bool (e1 = e2)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = CmpEq\n  ek =\n  \\<Up>\\<lambda>s.\n          let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n              e2 = stkAt s (stkLength (P, C, M) pc - 2)\n          in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n             Value (Bool (e1 = e2)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_CmpEq)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (37 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = CmpEq;\n        ek =\n        \\<Up>\\<lambda>s.\n                let e1 = stkAt s (stkLength (P, C, M) pc - 1);\n                    e2 = stkAt s (stkLength (P, C, M) pc - 2)\n                in s(Stack (stkLength (P, C, M) pc - 2) \\<mapsto>\n                   Value (Bool (e1 = e2)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 3. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 1) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 37 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (36 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let (D, fs) =\n                       the (heap_of s\n                             (the_Addr\n                               (stkAt s (stkLength (P, C, M) pc - 1))))\n                 in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                    Value (the (fs (F, Cl))))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 36 subgoals...", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let (D, fs) =\n                       the (heap_of s\n                             (the_Addr\n                               (stkAt s (stkLength (P, C, M) pc - 1))))\n                 in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                    Value (the (fs (F, Cl))))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 36 subgoals...", "case (CFG_IfFalse_False C P C0 Main M pc i ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  i \\<noteq> 1\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) = Bool False)\\<^sub>\\<surd>\n\ngoal (36 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let (D, fs) =\n                       the (heap_of s\n                             (the_Addr\n                               (stkAt s (stkLength (P, C, M) pc - 1))))\n                 in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                    Value (the (fs (F, Cl))))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 36 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  i \\<noteq> 1\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) = Bool False)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  i \\<noteq> 1\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) = Bool False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (36 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let (D, fs) =\n                       the (heap_of s\n                             (the_Addr\n                               (stkAt s (stkLength (P, C, M) pc - 1))))\n                 in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                    Value (the (fs (F, Cl))))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 36 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (36 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let (D, fs) =\n                       the (heap_of s\n                             (the_Addr\n                               (stkAt s (stkLength (P, C, M) pc - 1))))\n                 in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                    Value (the (fs (F, Cl))))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 36 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = IfFalse i\\<close> \\<open>i \\<noteq> 1\\<close>\n    \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) = Bool False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  i \\<noteq> 1\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) = Bool False)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  i \\<noteq> 1\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) = Bool False)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_IfFalse_False)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)\n\ngoal (36 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i; i \\<noteq> 1;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Bool False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>,\n                               Enter))\n 2. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let (D, fs) =\n                       the (heap_of s\n                             (the_Addr\n                               (stkAt s (stkLength (P, C, M) pc - 1))))\n                 in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                    Value (the (fs (F, Cl))))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 36 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>nat (int pc + i)\\<rfloor>, Enter))\n\ngoal (35 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 35 subgoals...", "case (CFG_IfFalse_True C P C0 Main M pc i ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n      i = 1)\\<^sub>\\<surd>\n\ngoal (35 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 35 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n      i = 1)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n      i = 1)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (35 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 35 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (35 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 35 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = IfFalse i\\<close>\n    \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or> i = 1)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n      i = 1)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = IfFalse i\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n      i = 1)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_IfFalse_True)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (35 subgoals):\n 1. \\<And>C P C0 Main M pc i ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = IfFalse i;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Bool False \\<or>\n            i = 1)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 35 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (34 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 34 subgoals...", "case (CFG_New_Check_Normal C P C0 Main M pc Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek = (\\<lambda>s. new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\n\ngoal (34 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 34 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek = (\\<lambda>s. new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek = (\\<lambda>s. new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (34 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 34 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (34 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 34 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = New Cl\\<close> \\<open>ek = (\\<lambda>s. new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek = (\\<lambda>s. new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek = (\\<lambda>s. new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "by (fastforce intro: JVMCFG_reachable.CFG_New_Check_Normal)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (34 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        (\\<lambda>s.\n            new_Addr (heap_of s) \\<noteq> None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Getfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 34 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n\ngoal (33 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 33 subgoals...", "case (CFG_New_Check_Exceptional C P C0 Main M pc Cl pc' ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  pc' =\n  (case match_ex_table (PROG P) OutOfMemory pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek = (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\n\ngoal (33 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 33 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  pc' =\n  (case match_ex_table (PROG P) OutOfMemory pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek = (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  pc' =\n  (case match_ex_table (PROG P) OutOfMemory pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek = (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (33 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 33 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (33 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 33 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open> instrs_of (PROG P) C M ! pc = New Cl\\<close>\n    \\<open>pc' = (case match_ex_table (PROG P) OutOfMemory pc (ex_table_of (PROG P) C M) of None \\<Rightarrow> None\n    | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\\<close> \\<open>ek = (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  pc' =\n  (case match_ex_table (PROG P) OutOfMemory pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek = (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  pc' =\n  (case match_ex_table (PROG P) OutOfMemory pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek = (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_New_Check_Exceptional)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (33 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        pc' =\n        (case match_ex_table (PROG P) OutOfMemory pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s. new_Addr (heap_of s) = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 33 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal (32 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 32 subgoals...", "case (CFG_New_Update C P C0 Main M pc Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let a = the (new_Addr (heap_of s))\n          in s(Heap \\<mapsto> Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n             Stack (stkLength (P, C, M) pc) \\<mapsto> Value (Addr a))\n\ngoal (32 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 32 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let a = the (new_Addr (heap_of s))\n          in s(Heap \\<mapsto> Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n             Stack (stkLength (P, C, M) pc) \\<mapsto> Value (Addr a))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let a = the (new_Addr (heap_of s))\n          in s(Heap \\<mapsto> Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n             Stack (stkLength (P, C, M) pc) \\<mapsto> Value (Addr a))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (32 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 32 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (32 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 32 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\\<close>\n    \\<open> instrs_of (PROG P) C M ! pc = New Cl\\<close>\n    \\<open> ek = \\<Up>\\<lambda>s. let a = the (new_Addr (heap_of s)) in\n    s(Heap \\<mapsto> Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n      Stack (stkLength (P, C, M) pc) \\<mapsto> Value (Addr a))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let a = the (new_Addr (heap_of s))\n          in s(Heap \\<mapsto> Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n             Stack (stkLength (P, C, M) pc) \\<mapsto> Value (Addr a))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let a = the (new_Addr (heap_of s))\n          in s(Heap \\<mapsto> Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n             Stack (stkLength (P, C, M) pc) \\<mapsto> Value (Addr a))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_New_Update)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (32 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let a = the (new_Addr (heap_of s))\n                in s(Heap \\<mapsto>\n                   Hp (heap_of s(a \\<mapsto> blank (PROG P) Cl)),\n                   Stack (stkLength (P, C, M) pc) \\<mapsto>\n                   Value (Addr a))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc F Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - 2) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 32 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (31 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let v = stkAt s (stkLength (P, C, M) pc - 1);\n                     r = stkAt s (stkLength (P, C, M) pc - 2);\n                     a = the_Addr r; (D, fs) = the (heap_of s a);\n                     h' = heap_of s(a \\<mapsto>\n                       (D, fs((F, Cl) \\<mapsto> v)))\n                 in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let v = stkAt s (stkLength (P, C, M) pc - 1);\n                     r = stkAt s (stkLength (P, C, M) pc - 2);\n                     a = the_Addr r; (D, fs) = the (heap_of s a);\n                     h' = heap_of s(a \\<mapsto>\n                       (D, fs((F, Cl) \\<mapsto> v)))\n                 in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 31 subgoals...", "case (CFG_New_Exceptional_prop C P C0 Main M pc Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n\ngoal (31 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let v = stkAt s (stkLength (P, C, M) pc - 1);\n                     r = stkAt s (stkLength (P, C, M) pc - 2);\n                     a = the_Addr r; (D, fs) = the (heap_of s a);\n                     h' = heap_of s(a \\<mapsto>\n                       (D, fs((F, Cl) \\<mapsto> v)))\n                 in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 31 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt OutOfMemory)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional None Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (31 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let v = stkAt s (stkLength (P, C, M) pc - 1);\n                     r = stkAt s (stkLength (P, C, M) pc - 2);\n                     a = the_Addr r; (D, fs) = the (heap_of s a);\n                     h' = heap_of s(a \\<mapsto>\n                       (D, fs((F, Cl) \\<mapsto> v)))\n                 in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 31 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (31 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let v = stkAt s (stkLength (P, C, M) pc - 1);\n                     r = stkAt s (stkLength (P, C, M) pc - 2);\n                     a = the_Addr r; (D, fs) = the (heap_of s a);\n                     h' = heap_of s(a \\<mapsto>\n                       (D, fs((F, Cl) \\<mapsto> v)))\n                 in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 31 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = New Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception \\<mapsto> Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek (C, M, None, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_New_Exceptional_prop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (31 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s.\n                 let v = stkAt s (stkLength (P, C, M) pc - 1);\n                     r = stkAt s (stkLength (P, C, M) pc - 2);\n                     a = the_Addr r; (D, fs) = the (heap_of s a);\n                     h' = heap_of s(a \\<mapsto>\n                       (D, fs((F, Cl) \\<mapsto> v)))\n                 in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 31 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (30 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 30 subgoals...", "case (CFG_New_Exceptional_handle C P C0 Main M pc pc' Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n\ngoal (30 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 30 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt OutOfMemory)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (30 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 30 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (30 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 30 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = New Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n    Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = New Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt OutOfMemory)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n     ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_New_Exceptional_handle)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (30 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = New Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt OutOfMemory)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 30 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc'\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n\ngoal (29 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 29 subgoals...", "case (CFG_Getfield_Check_Normal C P C0 Main M pc F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Null)\\<^sub>\\<surd>\n\ngoal (29 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 29 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Null)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Null)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (29 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 29 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (29 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 29 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Getfield F Cl\\<close>\n    \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Null)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 1) \\<noteq> Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "by (fastforce intro: JVMCFG_reachable.CFG_Getfield_Check_Normal)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (29 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' F Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Putfield F Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 29 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n\ngoal (28 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         (\\<lambda>s.\n             cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         (\\<lambda>s.\n             cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 28 subgoals...", "case (CFG_Getfield_Check_Exceptional C P C0 Main M pc F Cl pc' ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) = Null)\\<^sub>\\<surd>\n\ngoal (28 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         (\\<lambda>s.\n             cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 28 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) = Null)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) = Null)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (28 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         (\\<lambda>s.\n             cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 28 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (28 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         (\\<lambda>s.\n             cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 28 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Getfield F Cl\\<close>\n    \\<open>pc' = (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of None \\<Rightarrow> None\n    | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\\<close> \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) = Null)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) = Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 1) = Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Getfield_Check_Exceptional)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (28 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 1) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         (\\<lambda>s.\n             cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 28 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal (27 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         pc' =\n         (case match_ex_table (PROG P) ClassCast pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             \\<not> cast_ok (PROG P) Cl (heap_of s)\n                     (stkAt s\n                       (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         pc' =\n         (case match_ex_table (PROG P) ClassCast pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             \\<not> cast_ok (PROG P) Cl (heap_of s)\n                     (stkAt s\n                       (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 27 subgoals...", "case (CFG_Getfield_Update C P C0 Main M pc F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let (D, fs) =\n                the (heap_of s\n                      (the_Addr (stkAt s (stkLength (P, C, M) pc - 1))))\n          in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n             Value (the (fs (F, Cl))))\n\ngoal (27 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         pc' =\n         (case match_ex_table (PROG P) ClassCast pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             \\<not> cast_ok (PROG P) Cl (heap_of s)\n                     (stkAt s\n                       (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 27 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let (D, fs) =\n                the (heap_of s\n                      (the_Addr (stkAt s (stkLength (P, C, M) pc - 1))))\n          in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n             Value (the (fs (F, Cl))))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let (D, fs) =\n                the (heap_of s\n                      (the_Addr (stkAt s (stkLength (P, C, M) pc - 1))))\n          in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n             Value (the (fs (F, Cl))))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (27 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         pc' =\n         (case match_ex_table (PROG P) ClassCast pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             \\<not> cast_ok (PROG P) Cl (heap_of s)\n                     (stkAt s\n                       (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 27 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (27 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         pc' =\n         (case match_ex_table (PROG P) ClassCast pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             \\<not> cast_ok (PROG P) Cl (heap_of s)\n                     (stkAt s\n                       (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 27 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Getfield F Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. let (D, fs) = the (heap_of s (the_Addr (stkAt s (stkLength (P, C, M) pc - 1))))\n    in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto> Value (the (fs (F, Cl))))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let (D, fs) =\n                the (heap_of s\n                      (the_Addr (stkAt s (stkLength (P, C, M) pc - 1))))\n          in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n             Value (the (fs (F, Cl))))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let (D, fs) =\n                the (heap_of s\n                      (the_Addr (stkAt s (stkLength (P, C, M) pc - 1))))\n          in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n             Value (the (fs (F, Cl))))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Getfield_Update)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (27 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let (D, fs) =\n                      the (heap_of s\n                            (the_Addr\n                              (stkAt s (stkLength (P, C, M) pc - 1))))\n                in s(Stack (stkLength (P, C, M) pc - 1) \\<mapsto>\n                   Value (the (fs (F, Cl))))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc Cl pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         pc' =\n         (case match_ex_table (PROG P) ClassCast pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             \\<not> cast_ok (PROG P) Cl (heap_of s)\n                     (stkAt s\n                       (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 27 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (26 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 26 subgoals...", "case (CFG_Getfield_Exceptional_prop C P C0 Main M pc F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (26 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 26 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional None Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (26 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 26 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (26 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 26 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Getfield F Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek (C, M, None, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Getfield_Exceptional_prop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (26 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 26 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (25 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 25 subgoals...", "case (CFG_Getfield_Exceptional_handle C P C0 Main M pc pc' F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (25 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 25 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (25 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 25 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (25 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 25 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Getfield F Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n    Value (Addr (addr_of_sys_xcpt NullPointer)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Getfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n     ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Getfield_Exceptional_handle)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (25 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Getfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' Cl ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Checkcast Cl;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 25 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc'\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n\ngoal (24 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc pc' Exc d ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         pc' = None \\<or>\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(the pc', d)\\<rfloor>;\n         ek =\n         (\\<lambda>s.\n             let v = stkAt s (stkLength (P, C, M) pc - 1);\n                 Cl = if v = Null then NullPointer\n                      else cname_of (heap_of s) (the_Addr v)\n             in case pc' of\n                None \\<Rightarrow>\n                  match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                  None\n                | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                    \\<exists>d.\n                       match_ex_table (PROG P) Cl pc\n                        (ex_table_of (PROG P) C M) =\n                       \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc pc' Exc d ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         pc' = None \\<or>\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(the pc', d)\\<rfloor>;\n         ek =\n         (\\<lambda>s.\n             let v = stkAt s (stkLength (P, C, M) pc - 1);\n                 Cl = if v = Null then NullPointer\n                      else cname_of (heap_of s) (the_Addr v)\n             in case pc' of\n                None \\<Rightarrow>\n                  match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                  None\n                | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                    \\<exists>d.\n                       match_ex_table (PROG P) Cl pc\n                        (ex_table_of (PROG P) C M) =\n                       \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 24 subgoals...", "case (CFG_Putfield_Check_Normal C P C0 Main M pc F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 2) \\<noteq> Null)\\<^sub>\\<surd>\n\ngoal (24 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc pc' Exc d ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         pc' = None \\<or>\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(the pc', d)\\<rfloor>;\n         ek =\n         (\\<lambda>s.\n             let v = stkAt s (stkLength (P, C, M) pc - 1);\n                 Cl = if v = Null then NullPointer\n                      else cname_of (heap_of s) (the_Addr v)\n             in case pc' of\n                None \\<Rightarrow>\n                  match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                  None\n                | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                    \\<exists>d.\n                       match_ex_table (PROG P) Cl pc\n                        (ex_table_of (PROG P) C M) =\n                       \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 24 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 2) \\<noteq> Null)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 2) \\<noteq> Null)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (24 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc pc' Exc d ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         pc' = None \\<or>\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(the pc', d)\\<rfloor>;\n         ek =\n         (\\<lambda>s.\n             let v = stkAt s (stkLength (P, C, M) pc - 1);\n                 Cl = if v = Null then NullPointer\n                      else cname_of (heap_of s) (the_Addr v)\n             in case pc' of\n                None \\<Rightarrow>\n                  match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                  None\n                | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                    \\<exists>d.\n                       match_ex_table (PROG P) Cl pc\n                        (ex_table_of (PROG P) C M) =\n                       \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 24 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (24 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc pc' Exc d ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         pc' = None \\<or>\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(the pc', d)\\<rfloor>;\n         ek =\n         (\\<lambda>s.\n             let v = stkAt s (stkLength (P, C, M) pc - 1);\n                 Cl = if v = Null then NullPointer\n                      else cname_of (heap_of s) (the_Addr v)\n             in case pc' of\n                None \\<Rightarrow>\n                  match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                  None\n                | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                    \\<exists>d.\n                       match_ex_table (PROG P) Cl pc\n                        (ex_table_of (PROG P) C M) =\n                       \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 24 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Putfield F Cl\\<close>\n    \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 2) \\<noteq> Null)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 2) \\<noteq> Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - 2) \\<noteq> Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "by (fastforce intro: JVMCFG_reachable.CFG_Putfield_Check_Normal)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (24 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc pc' Exc d ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         pc' = None \\<or>\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(the pc', d)\\<rfloor>;\n         ek =\n         (\\<lambda>s.\n             let v = stkAt s (stkLength (P, C, M) pc - 1);\n                 Cl = if v = Null then NullPointer\n                      else cname_of (heap_of s) (the_Addr v)\n             in case pc' of\n                None \\<Rightarrow>\n                  match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                  None\n                | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                    \\<exists>d.\n                       match_ex_table (PROG P) Cl pc\n                        (ex_table_of (PROG P) C M) =\n                       \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 24 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n\ngoal (23 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 23 subgoals...", "case (CFG_Putfield_Check_Exceptional C P C0 Main M pc F Cl pc' ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 2) = Null)\\<^sub>\\<surd>\n\ngoal (23 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 23 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 2) = Null)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 2) = Null)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (23 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 23 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (23 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 23 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Putfield F Cl\\<close>\n    \\<open>pc' = (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of None \\<Rightarrow> None\n    | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\\<close> \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 2) = Null)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 2) = Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - 2) = Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Putfield_Check_Exceptional)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (23 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - 2) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 23 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal (22 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 22 subgoals...", "case (CFG_Putfield_Update C P C0 Main M pc F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let v = stkAt s (stkLength (P, C, M) pc - 1);\n              r = stkAt s (stkLength (P, C, M) pc - 2); a = the_Addr r;\n              (D, fs) = the (heap_of s a);\n              h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n          in s(Heap \\<mapsto> Hp h')\n\ngoal (22 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 22 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let v = stkAt s (stkLength (P, C, M) pc - 1);\n              r = stkAt s (stkLength (P, C, M) pc - 2); a = the_Addr r;\n              (D, fs) = the (heap_of s a);\n              h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n          in s(Heap \\<mapsto> Hp h')", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let v = stkAt s (stkLength (P, C, M) pc - 1);\n              r = stkAt s (stkLength (P, C, M) pc - 2); a = the_Addr r;\n              (D, fs) = the (heap_of s a);\n              h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n          in s(Heap \\<mapsto> Hp h')\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (22 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 22 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (22 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 22 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Putfield F Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. let v = stkAt s (stkLength (P, C, M) pc - 1);\n    r = stkAt s (stkLength (P, C, M) pc - 2);\n    a = the_Addr r; (D, fs) = the (heap_of s a); h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n    in s(Heap \\<mapsto> Hp h')\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let v = stkAt s (stkLength (P, C, M) pc - 1);\n              r = stkAt s (stkLength (P, C, M) pc - 2); a = the_Addr r;\n              (D, fs) = the (heap_of s a);\n              h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n          in s(Heap \\<mapsto> Hp h')\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s.\n          let v = stkAt s (stkLength (P, C, M) pc - 1);\n              r = stkAt s (stkLength (P, C, M) pc - 2); a = the_Addr r;\n              (D, fs) = the (heap_of s a);\n              h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n          in s(Heap \\<mapsto> Hp h')\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Putfield_Update)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (22 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s.\n                let v = stkAt s (stkLength (P, C, M) pc - 1);\n                    r = stkAt s (stkLength (P, C, M) pc - 2);\n                    a = the_Addr r; (D, fs) = the (heap_of s a);\n                    h' = heap_of s(a \\<mapsto> (D, fs((F, Cl) \\<mapsto> v)))\n                in s(Heap \\<mapsto> Hp h')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         instrs_of (PROG P) C M ! pc = Throw;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 22 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (21 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 21 subgoals...", "case (CFG_Putfield_Exceptional_prop C P C0 Main M pc F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (21 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 21 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional None Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (21 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 21 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (21 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 21 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Putfield F Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek (C, M, None, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Putfield_Exceptional_prop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (21 subgoals):\n 1. \\<And>C P C0 Main M pc F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal))\nA total of 21 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (20 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc M' n pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc M' n pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 20 subgoals...", "case (CFG_Putfield_Exceptional_handle C P C0 Main M pc pc' F Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (20 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc M' n pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (20 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc M' n pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 20 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (20 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc M' n pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 20 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Putfield F Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n    Value (Addr (addr_of_sys_xcpt NullPointer)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Putfield F Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n     ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Putfield_Exceptional_handle)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (20 subgoals):\n 1. \\<And>C P C0 Main M pc pc' F Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Putfield F Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 10. \\<And>C P C0 Main M pc M' n pc' ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         pc' =\n         (case match_ex_table (PROG P) NullPointer pc\n                (ex_table_of (PROG P) C M) of\n          None \\<Rightarrow> None\n          | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n              \\<lfloor>pc''\\<rfloor>);\n         ek =\n         (\\<lambda>s.\n             stkAt s (stkLength (P, C, M) pc - Suc n) =\n             Null)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional pc' Enter))\nA total of 20 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc'\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n\ngoal (19 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 19 subgoals...", "case (CFG_Checkcast_Check_Normal C P C0 Main M pc Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  (\\<lambda>s.\n      cast_ok (PROG P) Cl (heap_of s)\n       (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n\ngoal (19 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  (\\<lambda>s.\n      cast_ok (PROG P) Cl (heap_of s)\n       (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  (\\<lambda>s.\n      cast_ok (PROG P) Cl (heap_of s)\n       (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (19 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 19 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (19 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 19 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Checkcast Cl\\<close>\n    \\<open>ek = (\\<lambda>s. cast_ok (PROG P) Cl (heap_of s) (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  (\\<lambda>s.\n      cast_ok (PROG P) Cl (heap_of s)\n       (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  (\\<lambda>s.\n      cast_ok (PROG P) Cl (heap_of s)\n       (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Checkcast_Check_Normal)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (19 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        (\\<lambda>s.\n            cast_ok (PROG P) Cl (heap_of s)\n             (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 9. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional None Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional None Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 19 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (18 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 18 subgoals...", "case (CFG_Checkcast_Check_Exceptional C P C0 Main M pc Cl pc' ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  pc' =\n  (case match_ex_table (PROG P) ClassCast pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      \\<not> cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n\ngoal (18 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  pc' =\n  (case match_ex_table (PROG P) ClassCast pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      \\<not> cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  pc' =\n  (case match_ex_table (PROG P) ClassCast pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      \\<not> cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (18 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 18 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (18 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 18 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Checkcast Cl\\<close>\n    \\<open>pc' = (case match_ex_table (PROG P) ClassCast pc (ex_table_of (PROG P) C M) of None \\<Rightarrow> None\n    | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\\<close>\n    \\<open>ek = (\\<lambda>s. \\<not> cast_ok (PROG P) Cl (heap_of s) (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  pc' =\n  (case match_ex_table (PROG P) ClassCast pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      \\<not> cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  pc' =\n  (case match_ex_table (PROG P) ClassCast pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      \\<not> cast_ok (PROG P) Cl (heap_of s)\n              (stkAt s (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Checkcast_Check_Exceptional)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (18 subgoals):\n 1. \\<And>C P C0 Main M pc Cl pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        pc' =\n        (case match_ex_table (PROG P) ClassCast pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            \\<not> cast_ok (PROG P) Cl (heap_of s)\n                    (stkAt s\n                      (stkLength (P, C, M) pc - 1)))\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 8. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s(Exception := None)\n                 (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                 Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 18 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal (17 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n        paramDefs ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n         PROG\n          P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                   is, xt) in D;\n         Q =\n         (\\<lambda>(s, ret).\n             let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                 C' = cname_of (heap_of s) (the_Addr r)\n             in D = fst (method (PROG P) C' M'));\n         paramDefs =\n         (\\<lambda>s. s Heap) #\n         (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n         rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n               [0..<n]);\n         ek =\n         Q:(C, M,\n            pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (D, M', None, Enter))\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n        paramDefs ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n         PROG\n          P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                   is, xt) in D;\n         Q =\n         (\\<lambda>(s, ret).\n             let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                 C' = cname_of (heap_of s) (the_Addr r)\n             in D = fst (method (PROG P) C' M'));\n         paramDefs =\n         (\\<lambda>s. s Heap) #\n         (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n         rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n               [0..<n]);\n         ek =\n         Q:(C, M,\n            pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (D, M', None, Enter))\nA total of 17 subgoals...", "case (CFG_Checkcast_Exceptional_prop C P C0 Main M pc Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt ClassCast)))\n\ngoal (17 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n        paramDefs ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n         PROG\n          P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                   is, xt) in D;\n         Q =\n         (\\<lambda>(s, ret).\n             let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                 C' = cname_of (heap_of s) (the_Addr r)\n             in D = fst (method (PROG P) C' M'));\n         paramDefs =\n         (\\<lambda>s. s Heap) #\n         (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n         rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n               [0..<n]);\n         ek =\n         Q:(C, M,\n            pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (D, M', None, Enter))\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt ClassCast)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt ClassCast)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional None Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (17 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n        paramDefs ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n         PROG\n          P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                   is, xt) in D;\n         Q =\n         (\\<lambda>(s, ret).\n             let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                 C' = cname_of (heap_of s) (the_Addr r)\n             in D = fst (method (PROG P) C' M'));\n         paramDefs =\n         (\\<lambda>s. s Heap) #\n         (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n         rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n               [0..<n]);\n         ek =\n         Q:(C, M,\n            pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (D, M', None, Enter))\nA total of 17 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (17 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n        paramDefs ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n         PROG\n          P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                   is, xt) in D;\n         Q =\n         (\\<lambda>(s, ret).\n             let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                 C' = cname_of (heap_of s) (the_Addr r)\n             in D = fst (method (PROG P) C' M'));\n         paramDefs =\n         (\\<lambda>s. s Heap) #\n         (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n         rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n               [0..<n]);\n         ek =\n         Q:(C, M,\n            pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (D, M', None, Enter))\nA total of 17 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Checkcast Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception \\<mapsto> Value (Addr (addr_of_sys_xcpt ClassCast)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt ClassCast)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek (C, M, None, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt ClassCast)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Checkcast_Exceptional_prop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (17 subgoals):\n 1. \\<And>C P C0 Main M pc Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 7. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n        paramDefs ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n         PROG\n          P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                   is, xt) in D;\n         Q =\n         (\\<lambda>(s, ret).\n             let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                 C' = cname_of (heap_of s) (the_Addr r)\n             in D = fst (method (PROG P) C' M'));\n         paramDefs =\n         (\\<lambda>s. s Heap) #\n         (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n         rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n               [0..<n]);\n         ek =\n         Q:(C, M,\n            pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (D, M', None, Enter))\nA total of 17 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (16 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return))\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return))\nA total of 16 subgoals...", "case (CFG_Checkcast_Exceptional_handle C P C0 Main M pc pc' Cl ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt ClassCast)))\n\ngoal (16 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return))\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt ClassCast)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt ClassCast)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (16 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return))\nA total of 16 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (16 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return))\nA total of 16 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Checkcast Cl\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n    Value (Addr (addr_of_sys_xcpt ClassCast)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt ClassCast)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Checkcast Cl\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt ClassCast)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n     ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Checkcast_Exceptional_handle)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (16 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Cl ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Checkcast Cl;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt ClassCast)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 6. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Normal);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return))\nA total of 16 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc'\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n\ngoal (15 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 10. \\<And>C P C0 Main M pc M' n ST LT ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n         ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 10. \\<And>C P C0 Main M pc M' n ST LT ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n         ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 15 subgoals...", "case (CFG_Throw_Check C P C0 Main M pc pc' Exc d ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  pc' = None \\<or>\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n\ngoal (15 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 10. \\<And>C P C0 Main M pc M' n ST LT ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n         ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  pc' = None \\<or>\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>", "obtain as where path_src: \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  pc' = None \\<or>\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (15 subgoals):\n 1. \\<And>C P C0 Main M pc pc' Exc d ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        pc' = None \\<or>\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(the pc', d)\\<rfloor>;\n        ek =\n        (\\<lambda>s.\n            let v = stkAt s (stkLength (P, C, M) pc - 1);\n                Cl = if v = Null then NullPointer\n                     else cname_of (heap_of s) (the_Addr v)\n            in case pc' of\n               None \\<Rightarrow>\n                 match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                 None\n               | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n                   \\<exists>d.\n                      match_ex_table (PROG P) Cl pc\n                       (ex_table_of (PROG P) C M) =\n                      \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 5. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 10. \\<And>C P C0 Main M pc M' n ST LT ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n         ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\nA total of 15 subgoals...", "from \\<open>pc' = None \\<or> match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) = \\<lfloor>(the pc', d)\\<rfloor>\\<close>"], ["proof (chain)\npicking this:\n  pc' = None \\<or>\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  pc' = None \\<or>\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "proof (elim disjE_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. pc' = None \\<Longrightarrow>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n 2. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "assume \"pc' = None\""], ["proof (state)\nthis:\n  pc' = None\n\ngoal (2 subgoals):\n 1. pc' = None \\<Longrightarrow>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n 2. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Throw\\<close>\n    \\<open>ek = (\\<lambda>s. let v = stkAt s (stkLength (P, C, M) pc - 1);\n           Cl = if v = Null then NullPointer else cname_of (heap_of s) (the_Addr v)\n       in case pc' of None \\<Rightarrow> match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n          | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n              \\<exists>d. match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n  pc' = None", "have \"(P, C0, Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>, Enter) -\n      (\\<lambda>s. (stkAt s (stkLength (P, C, M) pc - Suc 0) = Null \\<longrightarrow>\n        match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) = None) \\<and>\n        (stkAt s (stkLength (P, C, M) pc - Suc 0) \\<noteq> Null \\<longrightarrow>\n          match_ex_table (PROG P) (cname_of (heap_of s)\n           (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0)))) pc (ex_table_of (PROG P) C M) =\n      None))\\<^sub>\\<surd>\\<rightarrow> (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n  pc' = None\n\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                          Enter) -(\\<lambda>s.\n(stkAt s (stkLength (P, C, M) pc - Suc 0) = Null \\<longrightarrow>\n match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) =\n None) \\<and>\n(stkAt s (stkLength (P, C, M) pc - Suc 0) \\<noteq> Null \\<longrightarrow>\n match_ex_table (PROG P)\n  (cname_of (heap_of s)\n    (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\n  pc (ex_table_of (PROG P) C M) =\n None))\\<^sub>\\<surd>\\<rightarrow> (C, M, \\<lfloor>pc\\<rfloor>,\n                                    Exceptional None Enter)", "by -(erule JVMCFG_reachable.CFG_Throw_Check, simp_all)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                        Enter) -(\\<lambda>s.\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) =\n                                     Null \\<longrightarrow>\n                                     match_ex_table (PROG P) NullPointer pc\n(ex_table_of (PROG P) C M) =\n                                     None) \\<and>\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) \\<noteq>\n                                     Null \\<longrightarrow>\n                                     match_ex_table (PROG P)\n(cname_of (heap_of s) (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\npc (ex_table_of (PROG P) C M) =\n                                     None))\\<^sub>\\<surd>\\<rightarrow> (C,\n                                  M, \\<lfloor>pc\\<rfloor>,\n                                  Exceptional None Enter)\n\ngoal (2 subgoals):\n 1. pc' = None \\<Longrightarrow>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n 2. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "with path_src \\<open>pc' = None\\<close> \\<open>ek = (\\<lambda>s. let v = stkAt s (stkLength (P, C, M) pc - 1);\n           Cl = if v = Null then NullPointer else cname_of (heap_of s) (the_Addr v)\n       in case pc' of None \\<Rightarrow> match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n          | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n              \\<exists>d. match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  pc' = None\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n   (P, C0,\n    Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                        Enter) -(\\<lambda>s.\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) =\n                                     Null \\<longrightarrow>\n                                     match_ex_table (PROG P) NullPointer pc\n(ex_table_of (PROG P) C M) =\n                                     None) \\<and>\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) \\<noteq>\n                                     Null \\<longrightarrow>\n                                     match_ex_table (PROG P)\n(cname_of (heap_of s) (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\npc (ex_table_of (PROG P) C M) =\n                                     None))\\<^sub>\\<surd>\\<rightarrow> (C,\n                                  M, \\<lfloor>pc\\<rfloor>,\n                                  Exceptional None Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  pc' = None\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n   (P, C0,\n    Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                        Enter) -(\\<lambda>s.\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) =\n                                     Null \\<longrightarrow>\n                                     match_ex_table (PROG P) NullPointer pc\n(ex_table_of (PROG P) C M) =\n                                     None) \\<and>\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) \\<noteq>\n                                     Null \\<longrightarrow>\n                                     match_ex_table (PROG P)\n(cname_of (heap_of s) (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\npc (ex_table_of (PROG P) C M) =\n                                     None))\\<^sub>\\<surd>\\<rightarrow> (C,\n                                  M, \\<lfloor>pc\\<rfloor>,\n                                  Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Throw_Check)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (2 subgoals):\n 1. pc' = None \\<Longrightarrow>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n 2. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "with path_src \\<open>pc' = None\\<close>"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  pc' = None\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "show ?thesis"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  pc' = None\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "assume met: \"match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) = \\<lfloor>(the pc', d)\\<rfloor>\"\n      and pc': \"pc' \\<noteq> None\""], ["proof (state)\nthis:\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  pc' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Throw\\<close>\n    \\<open>ek = (\\<lambda>s. let v = stkAt s (stkLength (P, C, M) pc - 1);\n           Cl = if v = Null then NullPointer else cname_of (heap_of s) (the_Addr v)\n       in case pc' of None \\<Rightarrow> match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n          | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n              \\<exists>d. match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  pc' \\<noteq> None", "have \"(P, C0, Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>, Enter) -\n      (\\<lambda>s. (stkAt s (stkLength (P, C, M) pc - Suc 0) = Null \\<longrightarrow>\n                                    (\\<exists>d. match_ex_table (PROG P) NullPointer pc\n                                          (ex_table_of (PROG P) C M) =\n                                         \\<lfloor>(the pc', d)\\<rfloor>)) \\<and>\n                                   (stkAt s (stkLength (P, C, M) pc - Suc 0) \\<noteq> Null \\<longrightarrow>\n                                    (\\<exists>d. match_ex_table (PROG P)\n                                          (cname_of (heap_of s)\n                                            (the_Addr\n                                              (stkAt s (stkLength (P, C, M) pc - Suc 0))))\n                                          pc (ex_table_of (PROG P) C M) =\n                                         \\<lfloor>(the pc', d)\\<rfloor>)))\\<^sub>\\<surd>\\<rightarrow>\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>the pc'\\<rfloor> Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  pc' \\<noteq> None\n\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                          Enter) -(\\<lambda>s.\n(stkAt s (stkLength (P, C, M) pc - Suc 0) = Null \\<longrightarrow>\n (\\<exists>d.\n     match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) =\n     \\<lfloor>(the pc', d)\\<rfloor>)) \\<and>\n(stkAt s (stkLength (P, C, M) pc - Suc 0) \\<noteq> Null \\<longrightarrow>\n (\\<exists>d.\n     match_ex_table (PROG P)\n      (cname_of (heap_of s)\n        (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\n      pc (ex_table_of (PROG P) C M) =\n     \\<lfloor>(the pc',\n               d)\\<rfloor>)))\\<^sub>\\<surd>\\<rightarrow> (C, M,\n                    \\<lfloor>pc\\<rfloor>,\n                    Exceptional \\<lfloor>the pc'\\<rfloor> Enter)", "by -(rule JVMCFG_reachable.CFG_Throw_Check, simp_all)"], ["proof (state)\nthis:\n   (P, C0,\n    Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                        Enter) -(\\<lambda>s.\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) =\n                                     Null \\<longrightarrow>\n                                     (\\<exists>d.\n   match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) =\n   \\<lfloor>(the pc', d)\\<rfloor>)) \\<and>\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) \\<noteq>\n                                     Null \\<longrightarrow>\n                                     (\\<exists>d.\n   match_ex_table (PROG P)\n    (cname_of (heap_of s)\n      (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\n    pc (ex_table_of (PROG P) C M) =\n   \\<lfloor>(the pc',\n             d)\\<rfloor>)))\\<^sub>\\<surd>\\<rightarrow> (C, M,\n                  \\<lfloor>pc\\<rfloor>,\n                  Exceptional \\<lfloor>the pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "with met pc' path_src \\<open>ek = (\\<lambda>s. let v = stkAt s (stkLength (P, C, M) pc - 1);\n           Cl = if v = Null then NullPointer else cname_of (heap_of s) (the_Addr v)\n       in case pc' of None \\<Rightarrow> match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n          | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n              \\<exists>d. match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  pc' \\<noteq> None\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n   (P, C0,\n    Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                        Enter) -(\\<lambda>s.\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) =\n                                     Null \\<longrightarrow>\n                                     (\\<exists>d.\n   match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) =\n   \\<lfloor>(the pc', d)\\<rfloor>)) \\<and>\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) \\<noteq>\n                                     Null \\<longrightarrow>\n                                     (\\<exists>d.\n   match_ex_table (PROG P)\n    (cname_of (heap_of s)\n      (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\n    pc (ex_table_of (PROG P) C M) =\n   \\<lfloor>(the pc',\n             d)\\<rfloor>)))\\<^sub>\\<surd>\\<rightarrow> (C, M,\n                  \\<lfloor>pc\\<rfloor>,\n                  Exceptional \\<lfloor>the pc'\\<rfloor> Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\""], ["proof (prove)\nusing this:\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(the pc', d)\\<rfloor>\n  pc' \\<noteq> None\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  ek =\n  (\\<lambda>s.\n      let v = stkAt s (stkLength (P, C, M) pc - 1);\n          Cl = if v = Null then NullPointer\n               else cname_of (heap_of s) (the_Addr v)\n      in case pc' of\n         None \\<Rightarrow>\n           match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) = None\n         | \\<lfloor>pc''\\<rfloor> \\<Rightarrow>\n             \\<exists>d.\n                match_ex_table (PROG P) Cl pc (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc'', d)\\<rfloor>)\\<^sub>\\<surd>\n   (P, C0,\n    Main) \\<turnstile> (C, M, \\<lfloor>pc\\<rfloor>,\n                        Enter) -(\\<lambda>s.\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) =\n                                     Null \\<longrightarrow>\n                                     (\\<exists>d.\n   match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) =\n   \\<lfloor>(the pc', d)\\<rfloor>)) \\<and>\n                                    (stkAt s\n(stkLength (P, C, M) pc - Suc 0) \\<noteq>\n                                     Null \\<longrightarrow>\n                                     (\\<exists>d.\n   match_ex_table (PROG P)\n    (cname_of (heap_of s)\n      (the_Addr (stkAt s (stkLength (P, C, M) pc - Suc 0))))\n    pc (ex_table_of (PROG P) C M) =\n   \\<lfloor>(the pc',\n             d)\\<rfloor>)))\\<^sub>\\<surd>\\<rightarrow> (C, M,\n                  \\<lfloor>pc\\<rfloor>,\n                  Exceptional \\<lfloor>the pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Throw_Check)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n             \\<lfloor>(the pc', d)\\<rfloor>;\n     pc' \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                      (\\<exists>as.\n                          JVMCFG_Interpret.valid_path' P C0 Main\n                           (ClassMain P, MethodMain P, None, Enter) as\n                           (C, M, \\<lfloor>pc\\<rfloor>,\n                            Exceptional pc' Enter))", "with path_src"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "show ?thesis"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal (14 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 9. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', diff)\\<rfloor>;\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         ek =\n         (\\<lambda>s.\n             \\<exists>v d.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return))\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 9. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', diff)\\<rfloor>;\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         ek =\n         (\\<lambda>s.\n             \\<exists>v d.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return))\nA total of 14 subgoals...", "case (CFG_Throw_prop C P C0 Main M pc ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (stkAt s (stkLength (P, C, M) pc - 1)))\n\ngoal (14 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 9. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', diff)\\<rfloor>;\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         ek =\n         (\\<lambda>s.\n             \\<exists>v d.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return))\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (stkAt s (stkLength (P, C, M) pc - 1)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (stkAt s (stkLength (P, C, M) pc - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional None Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (14 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 9. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', diff)\\<rfloor>;\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         ek =\n         (\\<lambda>s.\n             \\<exists>v d.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return))\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (14 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 9. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', diff)\\<rfloor>;\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         ek =\n         (\\<lambda>s.\n             \\<exists>v d.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return))\nA total of 14 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Throw\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception \\<mapsto> Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (stkAt s (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek (C, M, None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (stkAt s (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Throw_prop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (14 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 4. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 9. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', diff)\\<rfloor>;\n         pc' \\<noteq> length (instrs_of (PROG P) C M);\n         ek =\n         (\\<lambda>s.\n             \\<exists>v d.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return))\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (13 subgoals):\n 1. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 8. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Exception := None,\n                  Stack (stkLength (P, C, M) pc' - 1) :=\n                    s Exception)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 8. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Exception := None,\n                  Stack (stkLength (P, C, M) pc' - 1) :=\n                    s Exception)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 13 subgoals...", "case (CFG_Throw_handle C P C0 Main M pc pc' ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (stkAt s (stkLength (P, C, M) pc - 1)))\n\ngoal (13 subgoals):\n 1. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 8. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Exception := None,\n                  Stack (stkLength (P, C, M) pc' - 1) :=\n                    s Exception)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (stkAt s (stkLength (P, C, M) pc - 1)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (stkAt s (stkLength (P, C, M) pc - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (13 subgoals):\n 1. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 8. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Exception := None,\n                  Stack (stkLength (P, C, M) pc' - 1) :=\n                    s Exception)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (13 subgoals):\n 1. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 8. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Exception := None,\n                  Stack (stkLength (P, C, M) pc' - 1) :=\n                    s Exception)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 13 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\\<close>\n    \\<open>pc' \\<noteq> length (instrs_of (PROG P) C M)\\<close> \\<open>instrs_of (PROG P) C M ! pc = Throw\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n    Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (stkAt s (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  instrs_of (PROG P) C M ! pc = Throw\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (stkAt s (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n     ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Throw_handle)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (13 subgoals):\n 1. \\<And>C P C0 Main M pc pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        instrs_of (PROG P) C M ! pc = Throw;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (stkAt s (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 3. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 8. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 10. \\<And>C P C0 Main M pc pc' M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>,\n              Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Exception := None,\n                  Stack (stkLength (P, C, M) pc' - 1) :=\n                    s Exception)\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                Exceptional \\<lfloor>pc'\\<rfloor>\n                                 nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc'\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n\ngoal (12 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 7. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             \\<exists>v.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 7. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             \\<exists>v.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 12 subgoals...", "case (CFG_Invoke_Check_NP_Normal C P C0 Main M pc M' n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq> Null)\\<^sub>\\<surd>\n\ngoal (12 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 7. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             \\<exists>v.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq> Null)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq> Null)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (12 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 7. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             \\<exists>v.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (12 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 7. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             \\<exists>v.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 12 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close> \n    \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq> Null)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq> Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq> Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_Check_NP_Normal)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (12 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) \\<noteq>\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n 2. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 7. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 9. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 10. \\<And>C P C0 Main M pc M' n ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n         instrs_of (PROG P) C M ! pc = Invoke M' n;\n         ek =\n         (\\<lambda>s.\n             \\<exists>v.\n                s Exception = \\<lfloor>v\\<rfloor> \\<and>\n                match_ex_table (PROG P)\n                 (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                 (ex_table_of (PROG P) C M) =\n                None)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>,\n                                nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal))\n\ngoal (11 subgoals):\n 1. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 6. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = instr.Return;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Stack 0 :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 6. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = instr.Return;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Stack 0 :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 11 subgoals...", "case (CFG_Invoke_Check_NP_Exceptional C P C0 Main M pc M' n pc' ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) = Null)\\<^sub>\\<surd>\n\ngoal (11 subgoals):\n 1. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 6. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = instr.Return;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Stack 0 :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) = Null)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) = Null)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (11 subgoals):\n 1. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 6. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = instr.Return;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Stack 0 :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (11 subgoals):\n 1. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 6. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = instr.Return;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Stack 0 :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 11 subgoals...", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close>\n    \\<open>pc' = (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of None \\<Rightarrow> None\n    | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\\<close>\n    \\<open>ek = (\\<lambda>s. stkAt s (stkLength (P, C, M) pc - Suc n) = Null)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) = Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  pc' =\n  (case match_ex_table (PROG P) NullPointer pc (ex_table_of (PROG P) C M) of\n   None \\<Rightarrow> None\n   | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow> \\<lfloor>pc''\\<rfloor>)\n  ek =\n  (\\<lambda>s.\n      stkAt s (stkLength (P, C, M) pc - Suc n) = Null)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_Check_NP_Exceptional)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (11 subgoals):\n 1. \\<And>C P C0 Main M pc M' n pc' ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        pc' =\n        (case match_ex_table (PROG P) NullPointer pc\n               (ex_table_of (PROG P) C M) of\n         None \\<Rightarrow> None\n         | \\<lfloor>(pc'', d)\\<rfloor> \\<Rightarrow>\n             \\<lfloor>pc''\\<rfloor>);\n        ek =\n        (\\<lambda>s.\n            stkAt s (stkLength (P, C, M) pc - Suc n) =\n            Null)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional pc' Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 6. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 8. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 9. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>C P C0 Main M pc ek.\n        \\<lbrakk>C \\<noteq> ClassMain P;\n          (P, C0,\n           Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n      Enter);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n         instrs_of (PROG P) C M ! pc = instr.Return;\n         ek =\n         \\<Up>\\<lambda>s. s\n                 (Stack 0 :=\n                    s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return))\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional pc' Enter))\n\ngoal (10 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 5. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n        \\<lbrakk> (P, C0,\n                   Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n              nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, nodeType.Return);\n          (P, C0,\n           Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                               Normal) -Q':(C', M',\n      pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M,\n                            None, Enter);\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C, M, None, Enter));\n         Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n         stateUpdate =\n         (\\<lambda>s s'. s'\n             (Heap := s Heap, Exception := s Exception,\n              Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n         ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C', M', \\<lfloor>pc'\\<rfloor>,\n                                nodeType.Return))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 5. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n        \\<lbrakk> (P, C0,\n                   Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n              nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, nodeType.Return);\n          (P, C0,\n           Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                               Normal) -Q':(C', M',\n      pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M,\n                            None, Enter);\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C, M, None, Enter));\n         Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n         stateUpdate =\n         (\\<lambda>s s'. s'\n             (Heap := s Heap, Exception := s Exception,\n              Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n         ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C', M', \\<lfloor>pc'\\<rfloor>,\n                                nodeType.Return))", "case (CFG_Invoke_NP_prop C P C0 Main M pc M' n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (10 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 5. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n        \\<lbrakk> (P, C0,\n                   Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n              nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, nodeType.Return);\n          (P, C0,\n           Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                               Normal) -Q':(C', M',\n      pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M,\n                            None, Enter);\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C, M, None, Enter));\n         Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n         stateUpdate =\n         (\\<lambda>s s'. s'\n             (Heap := s Heap, Exception := s Exception,\n              Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n         ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C', M', \\<lfloor>pc'\\<rfloor>,\n                                nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional None Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (10 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 5. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n        \\<lbrakk> (P, C0,\n                   Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n              nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, nodeType.Return);\n          (P, C0,\n           Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                               Normal) -Q':(C', M',\n      pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M,\n                            None, Enter);\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C, M, None, Enter));\n         Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n         stateUpdate =\n         (\\<lambda>s s'. s'\n             (Heap := s Heap, Exception := s Exception,\n              Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n         ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C', M', \\<lfloor>pc'\\<rfloor>,\n                                nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (10 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 5. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n        \\<lbrakk> (P, C0,\n                   Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n              nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, nodeType.Return);\n          (P, C0,\n           Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                               Normal) -Q':(C', M',\n      pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M,\n                            None, Enter);\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C, M, None, Enter));\n         Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n         stateUpdate =\n         (\\<lambda>s s'. s'\n             (Heap := s Heap, Exception := s Exception,\n              Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n         ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C', M', \\<lfloor>pc'\\<rfloor>,\n                                nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek (C, M, None, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional None Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n          Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_NP_prop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (10 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional None Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional None Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 5. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 7. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 8. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 10. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n        \\<lbrakk> (P, C0,\n                   Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n              nodeType.Return);\n         \\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, nodeType.Return);\n          (P, C0,\n           Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                               Normal) -Q':(C', M',\n      pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M,\n                            None, Enter);\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n         (\\<exists>as.\n             JVMCFG_Interpret.valid_path' P C0 Main\n              (ClassMain P, MethodMain P, None, Enter) as\n              (C, M, None, Enter));\n         Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n         stateUpdate =\n         (\\<lambda>s s'. s'\n             (Heap := s Heap, Exception := s Exception,\n              Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n         ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C, M, None, nodeType.Return)) \\<and>\n                          (\\<exists>as.\n                              JVMCFG_Interpret.valid_path' P C0 Main\n                               (ClassMain P, MethodMain P, None, Enter) as\n                               (C', M', \\<lfloor>pc'\\<rfloor>,\n                                nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)\n   ek (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Exceptional None Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (9 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 4. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 4. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Invoke_NP_handle C P C0 Main M pc pc' M' n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (9 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 4. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (9 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 4. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (9 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 4. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n    Value (Addr (addr_of_sys_xcpt NullPointer)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nEnter)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s(Exception := None)(Stack (stkLength (P, C, M) pc' - 1) \n          \\<mapsto> Value (Addr (addr_of_sys_xcpt NullPointer)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n     ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_NP_handle)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (9 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> Enter);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s(Exception := None)\n                (Stack (stkLength (P, C, M) pc' - 1) \\<mapsto>\n                Value (Addr (addr_of_sys_xcpt NullPointer)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 4. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 6. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 7. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 9. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Enter) ek\n   (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc'\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n\ngoal (8 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 3. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 3. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Invoke_Call C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 \"is\" xt D Q paramDefs ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n = Class D'\n  PROG\n   P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n            xt) in D\n  Q =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D = fst (method (PROG P) C' M'))\n  paramDefs =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n        [0..<n])\n  ek = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\n\ngoal (8 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 3. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n = Class D'\n  PROG\n   P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n            xt) in D\n  Q =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D = fst (method (PROG P) C' M'))\n  paramDefs =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n        [0..<n])\n  ek = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n = Class D'\n  PROG\n   P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n            xt) in D\n  Q =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D = fst (method (PROG P) C' M'))\n  paramDefs =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n        [0..<n])\n  ek = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (8 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 3. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (8 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 3. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close> \\<open>TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\\<close>\n    \\<open>ST ! n = Class D'\\<close> \\<open>PROG P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is, xt) in D\\<close>\n    \\<open>Q = (\\<lambda>(s, ret). let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n              C' = cname_of (heap_of s) (the_Addr r) in D = fst (method (PROG P) C' M'))\\<close>\n    \\<open>paramDefs = (\\<lambda>s. s Heap) # (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n    rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i))) [0..<n])\\<close>\n    \\<open>ek = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n = Class D'\n  PROG\n   P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n            xt) in D\n  Q =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D = fst (method (PROG P) C' M'))\n  paramDefs =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n        [0..<n])\n  ek = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek (D, M', None, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n = Class D'\n  PROG\n   P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n            xt) in D\n  Q =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in D = fst (method (PROG P) C' M'))\n  paramDefs =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n        [0..<n])\n  ek = Q:(C, M, pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n     (D, M', None, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_Call)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (D, M', None, Enter)\n\ngoal (8 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\\<^sub>0 is xt D Q\n       paramDefs ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M': Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in D;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C, M) pc - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in D = fst (method (PROG P) C' M'));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C, M) pc - Suc n))) #\n        rev (map (\\<lambda>i s. s (Stack (stkLength (P, C, M) pc - Suc i)))\n              [0..<n]);\n        ek =\n        Q:(C, M,\n           pc)\\<hookrightarrow>\\<^bsub>(D, M')\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (D, M', None, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 3. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 5. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 6. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 8. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (D, M', None, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (D, M', None, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as (D, M', None, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (D, M', None, Enter))\n\ngoal (7 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 2. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 2. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Invoke_False C P C0 Main M pc M' n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (7 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 2. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (7 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 2. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (7 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 2. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close> \\<open>ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek = (\\<lambda>s. False)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek (C, M, \\<lfloor>pc\\<rfloor>, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek = (\\<lambda>s. False)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n     (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_False)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (7 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Normal);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Normal);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n 2. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 4. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 5. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 7. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Normal) ek\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return))\n\ngoal (6 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Invoke_Return_Check_Normal C P C0 Main M pc M' n ST LT ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n \\<noteq> NT\n  ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n \\<noteq> NT\n  ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n \\<noteq> NT\n  ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (6 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (6 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close> \\<open>TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\\<close>\n    \\<open>ST ! n \\<noteq> NT\\<close> \\<open>ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n \\<noteq> NT\n  ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Return) ek (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ST ! n \\<noteq> NT\n  ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n     (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_Return_Check_Normal)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (6 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ST LT ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        TYPING P C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>; ST ! n \\<noteq> NT;\n        ek = (\\<lambda>s. s Exception = None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 3. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 4. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 6. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>Suc pc\\<rfloor>, Enter))\n\ngoal (5 subgoals):\n 1. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Invoke_Return_Check_Exceptional C P C0 Main M pc M' n Exc pc' diff ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(pc', diff)\\<rfloor>\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  ek =\n  (\\<lambda>s.\n      \\<exists>v d.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(pc', diff)\\<rfloor>\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  ek =\n  (\\<lambda>s.\n      \\<exists>v d.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(pc', diff)\\<rfloor>\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  ek =\n  (\\<lambda>s.\n      \\<exists>v d.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (5 subgoals):\n 1. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (5 subgoals):\n 1. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close>\n    \\<open>match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) = \\<lfloor>(pc', diff)\\<rfloor>\\<close>\n    \\<open>pc' \\<noteq> length (instrs_of (PROG P) C M)\\<close>\n    \\<open>ek = (\\<lambda>s. \\<exists>v d. s Exception = \\<lfloor>v\\<rfloor> \\<and>\n             match_ex_table (PROG P) (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n              (ex_table_of (PROG P) C M) = \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(pc', diff)\\<rfloor>\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  ek =\n  (\\<lambda>s.\n      \\<exists>v d.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Return) ek (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n  \\<lfloor>(pc', diff)\\<rfloor>\n  pc' \\<noteq> length (instrs_of (PROG P) C M)\n  ek =\n  (\\<lambda>s.\n      \\<exists>v d.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n     (C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_Return_Check_Exceptional)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n\ngoal (5 subgoals):\n 1. \\<And>C P C0 Main M pc M' n Exc pc' diff ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =\n        \\<lfloor>(pc', diff)\\<rfloor>;\n        pc' \\<noteq> length (instrs_of (PROG P) C M);\n        ek =\n        (\\<lambda>s.\n            \\<exists>v d.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               \\<lfloor>(pc', d)\\<rfloor>)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return))\n 2. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 3. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 5. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return))\n\ngoal (4 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Invoke_Return_Exceptional_handle C P C0 Main M pc pc' M' n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nnodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>,\n       Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s\n          (Exception := None,\n           Stack (stkLength (P, C, M) pc' - 1) := s Exception)\n\ngoal (4 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nnodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>,\n       Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s\n          (Exception := None,\n           Stack (stkLength (P, C, M) pc' - 1) := s Exception)", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nnodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>,\n       Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s\n          (Exception := None,\n           Stack (stkLength (P, C, M) pc' - 1) := s Exception)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor>\n           nodeType.Return) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n\ngoal (4 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n\ngoal (4 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Exception := None, Stack (stkLength (P, C, M) pc' - 1) := s Exception)\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nnodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s\n          (Exception := None,\n           Stack (stkLength (P, C, M) pc' - 1) := s Exception)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Exceptional \\<lfloor>pc'\\<rfloor> Return) ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     Exceptional \\<lfloor>pc'\\<rfloor>\nnodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  \\<Up>\\<lambda>s. s\n          (Exception := None,\n           Stack (stkLength (P, C, M) pc' - 1) := s Exception)\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (C, M, \\<lfloor>pc\\<rfloor>,\n      Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n     ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_Return_Exceptional_handle)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n   ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (4 subgoals):\n 1. \\<And>C P C0 Main M pc pc' M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>,\n             Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Exception := None,\n                 Stack (stkLength (P, C, M) pc' - 1) :=\n                   s Exception)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               Exceptional \\<lfloor>pc'\\<rfloor>\n                                nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n 2. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 4. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n   ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n  vp_snoc P C0 Main as\n   (C, M, \\<lfloor>pc\\<rfloor>,\n    Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)\n   ek (C, M, \\<lfloor>pc'\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>,\n          Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc'\\<rfloor>, Enter))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>,\n        Exceptional \\<lfloor>pc'\\<rfloor> nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc'\\<rfloor>, Enter))\n\ngoal (3 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Invoke_Return_Exceptional_prop C P C0 Main M pc M' n ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      \\<exists>v.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         None)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      \\<exists>v.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         None)\\<^sub>\\<surd>", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      \\<exists>v.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         None)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (3 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (3 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = Invoke M' n\\<close>\n    \\<open>ek = (\\<lambda>s. \\<exists>v. s Exception = \\<lfloor>v\\<rfloor> \\<and>\n           match_ex_table (PROG P) (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n            (ex_table_of (PROG P) C M) = None)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      \\<exists>v.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Return) ek (C, M, None, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n                                     nodeType.Return)\n  instrs_of (PROG P) C M ! pc = Invoke M' n\n  ek =\n  (\\<lambda>s.\n      \\<exists>v.\n         s Exception = \\<lfloor>v\\<rfloor> \\<and>\n         match_ex_table (PROG P)\n          (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n          (ex_table_of (PROG P) C M) =\n         None)\\<^sub>\\<surd>\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Invoke_Return_Exceptional_prop)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, None, nodeType.Return)\n\ngoal (3 subgoals):\n 1. \\<And>C P C0 Main M pc M' n ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return);\n        instrs_of (PROG P) C M ! pc = Invoke M' n;\n        ek =\n        (\\<lambda>s.\n            \\<exists>v.\n               s Exception = \\<lfloor>v\\<rfloor> \\<and>\n               match_ex_table (PROG P)\n                (cname_of (heap_of s) (the_Addr (the_Value v))) pc\n                (ex_table_of (PROG P) C M) =\n               None)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>,\n                               nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 3. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return) ek\n   (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (2 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Return C P C0 Main M pc ek)"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = instr.Return\n  ek = \\<Up>\\<lambda>s. s(Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\n\ngoal (2 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = instr.Return\n  ek = \\<Up>\\<lambda>s. s(Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n    (ClassMain P, MethodMain P, None, Enter) as (C, M, \\<lfloor>pc\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = instr.Return\n  ek = \\<Up>\\<lambda>s. s(Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (2 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (2 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with \\<open>C \\<noteq> ClassMain P\\<close> \\<open>(P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\\<close>\n    \\<open>instrs_of (PROG P) C M ! pc = instr.Return\\<close>\n    \\<open>ek = \\<Up>\\<lambda>s. s(Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<close>"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = instr.Return\n  ek = \\<Up>\\<lambda>s. s(Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)", "have \"vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek (C, M, None, Return)\""], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  instrs_of (PROG P) C M ! pc = instr.Return\n  ek = \\<Up>\\<lambda>s. s(Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n     (C, M, None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.CFG_Return)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, None, nodeType.Return)\n\ngoal (2 subgoals):\n 1. \\<And>C P C0 Main M pc ek.\n       \\<lbrakk>C \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C, M, \\<lfloor>pc\\<rfloor>,\n     Enter);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, \\<lfloor>pc\\<rfloor>, Enter);\n        instrs_of (PROG P) C M ! pc = instr.Return;\n        ek =\n        \\<Up>\\<lambda>s. s\n                (Stack 0 := s (Stack (stkLength (P, C, M) pc - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return))\n 2. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, None, nodeType.Return)", "show ?case"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C, M, \\<lfloor>pc\\<rfloor>, Enter)\n  vp_snoc P C0 Main as (C, M, \\<lfloor>pc\\<rfloor>, Enter) ek\n   (C, M, None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, \\<lfloor>pc\\<rfloor>, Enter)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return))\n\ngoal (1 subgoal):\n 1. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case (CFG_Return_from_Method P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek)"], ["proof (state)\nthis:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter))\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n\ngoal (1 subgoal):\n 1. \\<And>P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.\n       \\<lbrakk> (P, C0,\n                  Main) \\<turnstile> \\<Rightarrow>(C, M, None,\n             nodeType.Return);\n        \\<exists>as.\n           JVMCFG_Interpret.valid_path' P C0 Main\n            (ClassMain P, MethodMain P, None, Enter) as\n            (C, M, None, nodeType.Return);\n         (P, C0,\n          Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                              Normal) -Q':(C', M',\n     pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None,\n                           Enter);\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n        (\\<exists>as.\n            JVMCFG_Interpret.valid_path' P C0 Main\n             (ClassMain P, MethodMain P, None, Enter) as\n             (C, M, None, Enter));\n        Q = (\\<lambda>(s, ret). ret = (C', M', pc'));\n        stateUpdate =\n        (\\<lambda>s s'. s'\n            (Heap := s Heap, Exception := s Exception,\n             Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)));\n        ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "from \\<open>(P, C0, Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>, Normal) -Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\\<close>"], ["proof (chain)\npicking this:\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)", "show ?case"], ["proof (prove)\nusing this:\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C' = ClassMain P; M' = MethodMain P; pc' = 0; M = Main;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))\n 2. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case Main_Call"], ["proof (state)\nthis:\n  C' = ClassMain P\n  M' = MethodMain P\n  pc' = 0\n  M = Main\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n               is_, xt_) in C\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C, Main)\\<^esub>initParams_\n\ngoal (2 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C' = ClassMain P; M' = MethodMain P; pc' = 0; M = Main;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))\n 2. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with CFG_Return_from_Method"], ["proof (chain)\npicking this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter))\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' = ClassMain P\n  M' = MethodMain P\n  pc' = 0\n  M = Main\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n               is_, xt_) in C\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C, Main)\\<^esub>initParams_", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter))\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' = ClassMain P\n  M' = MethodMain P\n  pc' = 0\n  M = Main\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n               is_, xt_) in C\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C, Main)\\<^esub>initParams_\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>,\n          Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (2 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C' = ClassMain P; M' = MethodMain P; pc' = 0; M = Main;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))\n 2. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (2 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C' = ClassMain P; M' = MethodMain P; pc' = 0; M = Main;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))\n 2. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with Main_Call"], ["proof (chain)\npicking this:\n  C' = ClassMain P\n  M' = MethodMain P\n  pc' = 0\n  M = Main\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n               is_, xt_) in C\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C, Main)\\<^esub>initParams_\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n      (\\<lambda>s. False)\\<^sub>\\<surd> (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Return)\""], ["proof (prove)\nusing this:\n  C' = ClassMain P\n  M' = MethodMain P\n  pc' = 0\n  M = Main\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n               is_, xt_) in C\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C, Main)\\<^esub>initParams_\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n     (\\<lambda>s. False)\\<^sub>\\<surd>\n     (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)", "by (fastforce intro: Main_Call_LFalse)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (2 subgoals):\n 1. \\<And>T mxs mxl\\<^sub>0 is xt initParams.\n       \\<lbrakk>C' = ClassMain P; M' = MethodMain P; pc' = 0; M = Main;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n     \\<lfloor>0\\<rfloor>, Normal);\n        PROG\n         P \\<turnstile> C0 sees Main: []\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    is, xt) in C;\n        initParams =\n        [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>];\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        \\<lambda>(s, ret).\n           True:(ClassMain P, MethodMain P,\n                 0)\\<hookrightarrow>\\<^bsub>(C,\n       Main)\\<^esub>initParams\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))\n 2. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)", "show ?thesis"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))", "using Main_Call CFG_Return_from_Method"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n  vp_snoc P C0 Main as\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, nodeType.Return)\n  C' = ClassMain P\n  M' = MethodMain P\n  pc' = 0\n  M = Main\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n                                     \\<lfloor>0\\<rfloor>, Normal)\n  PROG\n   P \\<turnstile> C0 sees Main: []\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_,\n               is_, xt_) in C\n  initParams_ =\n  [\\<lambda>s. s Heap, \\<lambda>s. \\<lfloor>Value Null\\<rfloor>]\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  \\<lambda>(s, ret).\n     True:(ClassMain P, MethodMain P,\n           0)\\<hookrightarrow>\\<^bsub>(C, Main)\\<^esub>initParams_\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter))\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))\n\ngoal (1 subgoal):\n 1. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "case CFG_Invoke_Call"], ["proof (state)\nthis:\n  C' \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  instrs_of (PROG P) C' M' ! pc' = Invoke M n_\n  TYPING P C' M' ! pc' = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M: Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C', M') pc' - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in C = fst (method (PROG P) C' M))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C', M') pc' - Suc i)))\n        [0..<n_])\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  Q_:(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs_\n\ngoal (1 subgoal):\n 1. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with CFG_Return_from_Method"], ["proof (chain)\npicking this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter))\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  instrs_of (PROG P) C' M' ! pc' = Invoke M n_\n  TYPING P C' M' ! pc' = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M: Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C', M') pc' - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in C = fst (method (PROG P) C' M))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C', M') pc' - Suc i)))\n        [0..<n_])\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  Q_:(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs_", "obtain as where \"JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\""], ["proof (prove)\nusing this:\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter))\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n  C' \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  instrs_of (PROG P) C' M' ! pc' = Invoke M n_\n  TYPING P C' M' ! pc' = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M: Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C', M') pc' - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in C = fst (method (PROG P) C' M))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C', M') pc' - Suc i)))\n        [0..<n_])\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  Q_:(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs_\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C', M', \\<lfloor>pc'\\<rfloor>, Normal) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "moreover"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "with CFG_Invoke_Call"], ["proof (chain)\npicking this:\n  C' \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  instrs_of (PROG P) C' M' ! pc' = Invoke M n_\n  TYPING P C' M' ! pc' = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M: Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C', M') pc' - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in C = fst (method (PROG P) C' M))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C', M') pc' - Suc i)))\n        [0..<n_])\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  Q_:(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs_\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C', M', \\<lfloor>pc'\\<rfloor>, Normal)", "have \"vp_snoc P C0 Main as (C', M', \\<lfloor>pc'\\<rfloor>, Normal) (\\<lambda>s. False)\\<^sub>\\<surd> (C', M', \\<lfloor>pc'\\<rfloor>, Return)\""], ["proof (prove)\nusing this:\n  C' \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  instrs_of (PROG P) C' M' ! pc' = Invoke M n_\n  TYPING P C' M' ! pc' = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M: Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C', M') pc' - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in C = fst (method (PROG P) C' M))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C', M') pc' - Suc i)))\n        [0..<n_])\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  Q_:(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs_\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n\ngoal (1 subgoal):\n 1. vp_snoc P C0 Main as (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n     (\\<lambda>s. False)\\<^sub>\\<surd>\n     (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)", "by (fastforce intro: CFG_Invoke_False)"], ["proof (state)\nthis:\n  vp_snoc P C0 Main as (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<And>n ST LT D' Ts T mxs mxl\\<^sub>0 is xt Q paramDefs.\n       \\<lbrakk>C' \\<noteq> ClassMain P;\n         (P, C0,\n          Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>,\n     Normal);\n        instrs_of (PROG P) C' M' ! pc' = Invoke M n;\n        TYPING P C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n        ST ! n = Class D';\n        PROG\n         P \\<turnstile> D' sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, is,\n                 xt) in C;\n        Q =\n        (\\<lambda>(s, ret).\n            let r = stkAt s (stkLength (P, C', M') pc' - Suc n);\n                C' = cname_of (heap_of s) (the_Addr r)\n            in C = fst (method (PROG P) C' M));\n        paramDefs =\n        (\\<lambda>s. s Heap) #\n        (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n))) #\n        rev (map (\\<lambda>i s.\n                     s (Stack (stkLength (P, C', M') pc' - Suc i)))\n              [0..<n]);\n        Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n        Q:(C', M',\n           pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C, M, None, nodeType.Return)) \\<and>\n                         (\\<exists>as.\n                             JVMCFG_Interpret.valid_path' P C0 Main\n                              (ClassMain P, MethodMain P, None, Enter) as\n                              (C', M', \\<lfloor>pc'\\<rfloor>,\n                               nodeType.Return))", "ultimately"], ["proof (chain)\npicking this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)", "show ?thesis"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))", "using CFG_Invoke_Call CFG_Return_from_Method"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' P C0 Main\n   (ClassMain P, MethodMain P, None, Enter) as\n   (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  vp_snoc P C0 Main as (C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n   (\\<lambda>s. False)\\<^sub>\\<surd>\n   (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return)\n  C' \\<noteq> ClassMain P\n   (P, C0,\n    Main) \\<turnstile> \\<Rightarrow>(C', M', \\<lfloor>pc'\\<rfloor>, Normal)\n  instrs_of (PROG P) C' M' ! pc' = Invoke M n_\n  TYPING P C' M' ! pc' = \\<lfloor>(ST_, LT_)\\<rfloor>\n  ST_ ! n_ = Class D'_\n  PROG\n   P \\<turnstile> D'_ sees M: Ts_\\<rightarrow>T_ = (mxs_, mxl\\<^sub>0_, is_,\n              xt_) in C\n  Q_ =\n  (\\<lambda>(s, ret).\n      let r = stkAt s (stkLength (P, C', M') pc' - Suc n_);\n          C' = cname_of (heap_of s) (the_Addr r)\n      in C = fst (method (PROG P) C' M))\n  paramDefs_ =\n  (\\<lambda>s. s Heap) #\n  (\\<lambda>s. s (Stack (stkLength (P, C', M') pc' - Suc n_))) #\n  rev (map (\\<lambda>i s. s (Stack (stkLength (P, C', M') pc' - Suc i)))\n        [0..<n_])\n  Q':(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>ps =\n  Q_:(C', M', pc')\\<hookrightarrow>\\<^bsub>(C, M)\\<^esub>paramDefs_\n   (P, C0, Main) \\<turnstile> \\<Rightarrow>(C, M, None, nodeType.Return)\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' P C0 Main\n      (ClassMain P, MethodMain P, None, Enter) as\n      (C, M, None, nodeType.Return)\n   (P, C0,\n    Main) \\<turnstile> (C', M', \\<lfloor>pc'\\<rfloor>,\n                        Normal) -Q':(C', M',\n                                     pc')\\<hookrightarrow>\\<^bsub>(C,\n                             M)\\<^esub>ps\\<rightarrow> (C, M, None, Enter)\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, Normal)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as (C, M, None, Enter))\n  Q = (\\<lambda>(s, ret). ret = (C', M', pc'))\n  stateUpdate =\n  (\\<lambda>s s'. s'\n      (Heap := s Heap, Exception := s Exception,\n       Stack (stkLength (P, C', M') (Suc pc') - 1) := s (Stack 0)))\n  ek = Q\\<hookleftarrow>\\<^bsub>(C, M)\\<^esub>stateUpdate\n\ngoal (1 subgoal):\n 1. (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C, M, None, nodeType.Return)) \\<and>\n    (\\<exists>as.\n        JVMCFG_Interpret.valid_path' P C0 Main\n         (ClassMain P, MethodMain P, None, Enter) as\n         (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C, M, None, nodeType.Return)) \\<and>\n  (\\<exists>as.\n      JVMCFG_Interpret.valid_path' P C0 Main\n       (ClassMain P, MethodMain P, None, Enter) as\n       (C', M', \\<lfloor>pc'\\<rfloor>, nodeType.Return))\n\ngoal:\nNo subgoals!", "qed"], ["", "declare JVMCFG_Interpret.vp_snocI []"], ["", "declare JVMCFG_Interpret.valid_node_def [simp del]\n  valid_edge_def [simp del]\n  JVMCFG_Interpret.intra_path_def [simp del]"], ["", "definition EP :: jvm_prog\n  where \"EP = (''C'', Object, [],\n  [(''M'', [], Void, 1::nat, 0::nat, [Push Unit, instr.Return], [])]) # SystemClasses\""], ["", "definition Phi_EP :: ty\\<^sub>P\n  where \"Phi_EP C M = (if C = ''C'' \\<and> M = ''M''\n      then [\\<lfloor>([],[OK (Class ''C'')])\\<rfloor>,\\<lfloor>([Void],[OK (Class ''C'')])\\<rfloor>] else [])\""], ["", "lemma distinct_classes'':\n  \"''C'' \\<noteq> Object\"\n  \"''C'' \\<noteq> NullPointer\"\n  \"''C'' \\<noteq> OutOfMemory\"\n  \"''C'' \\<noteq> ClassCast\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (''C'' \\<noteq> Object &&& ''C'' \\<noteq> NullPointer) &&&\n    ''C'' \\<noteq> OutOfMemory &&& ''C'' \\<noteq> ClassCast", "by (simp_all add: Object_def NullPointer_def OutOfMemory_def ClassCast_def)"], ["", "lemmas distinct_classes =\n  distinct_classes distinct_classes'' distinct_classes'' [symmetric]"], ["", "declare distinct_classes [simp add]"], ["", "lemma i_max_2D: \"i < Suc (Suc 0) \\<Longrightarrow> i = 0 \\<or> i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Suc (Suc 0) \\<Longrightarrow> i = 0 \\<or> i = 1", "by auto"], ["", "lemma EP_wf: \"wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP", "unfolding wf_jvm_prog_phi_def wf_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_syscls EP \\<and>\n    (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_syscls EP\n 2. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "show \"wf_syscls EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_syscls EP", "by (simp add: EP_def wf_syscls_def SystemClasses_def sys_xcpts_def\n      ObjectC_def NullPointerC_def OutOfMemoryC_def ClassCastC_def)"], ["proof (state)\nthis:\n  wf_syscls EP\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "have distinct_EP: \"distinct_fst EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auxiliary.distinct_fst EP", "by (auto simp: EP_def SystemClasses_def ObjectC_def NullPointerC_def OutOfMemoryC_def\n      ClassCastC_def)"], ["proof (state)\nthis:\n  Auxiliary.distinct_fst EP\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "moreover"], ["proof (state)\nthis:\n  Auxiliary.distinct_fst EP\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "have classes_wf:\n    \"\\<forall>c\\<in>set EP. wf_cdecl\n    (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt). wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M)) EP c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set EP.\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set EP \\<Longrightarrow>\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set EP \\<Longrightarrow>\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "assume C_in_EP: \"C \\<in> set EP\""], ["proof (state)\nthis:\n  C \\<in> set EP\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set EP \\<Longrightarrow>\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "show \"wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt). wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M)) EP C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "proof (cases \"C \\<in> set SystemClasses\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C\n 2. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "case True"], ["proof (state)\nthis:\n  C \\<in> set SystemClasses\n\ngoal (2 subgoals):\n 1. C \\<in> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C\n 2. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "thus ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> set SystemClasses\n\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "by (auto simp: wf_cdecl_def SystemClasses_def ObjectC_def NullPointerC_def\n          OutOfMemoryC_def ClassCastC_def EP_def class_def)"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n   EP C\n\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "case False"], ["proof (state)\nthis:\n  C \\<notin> set SystemClasses\n\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "with C_in_EP"], ["proof (chain)\npicking this:\n  C \\<in> set EP\n  C \\<notin> set SystemClasses", "have \"C = (''C'', the (class EP ''C''))\""], ["proof (prove)\nusing this:\n  C \\<in> set EP\n  C \\<notin> set SystemClasses\n\ngoal (1 subgoal):\n 1. C = (''C'', the (class EP ''C''))", "by (auto simp: EP_def SystemClasses_def class_def)"], ["proof (state)\nthis:\n  C = (''C'', the (class EP ''C''))\n\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "thus ?thesis"], ["proof (prove)\nusing this:\n  C = (''C'', the (class EP ''C''))\n\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "by (auto dest!: i_max_2D elim: Methods.cases\n          simp: wf_cdecl_def class_def EP_def wf_mdecl_def wt_method_def Phi_EP_def\n          wt_start_def check_types_def states_def JVM_SemiType.sl_def SystemClasses_def\n          stk_esl_def upto_esl_def loc_sl_def SemiType.esl_def ObjectC_def\n          SemiType.sup_def Err.sl_def Err.le_def err_def Listn.sl_def Method_def\n          Err.esl_def Opt.esl_def Product.esl_def relevant_entries_def)"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n   EP C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n   EP C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set EP.\n     wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n          wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n      EP c\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "ultimately"], ["proof (chain)\npicking this:\n  Auxiliary.distinct_fst EP\n  \\<forall>c\\<in>set EP.\n     wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n          wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n      EP c", "show \"(\\<forall>c\\<in>set EP. wf_cdecl\n    (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt). wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M)) EP c) \\<and>\n    distinct_fst EP\""], ["proof (prove)\nusing this:\n  Auxiliary.distinct_fst EP\n  \\<forall>c\\<in>set EP.\n     wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n          wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n      EP c\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    Auxiliary.distinct_fst EP", "by simp"], ["proof (state)\nthis:\n  (\\<forall>c\\<in>set EP.\n      wf_cdecl\n       (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n           wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n       EP c) \\<and>\n  Auxiliary.distinct_fst EP\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "proof (cases \"(EP, Phi_EP) \\<in> wf_jvmprog\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "case True"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "thus ?thesis"], ["proof (prove)\nusing this:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (1 subgoal):\n 1. PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "by (simp add: Abs_wf_jvmprog_inverse)"], ["proof (state)\nthis:\n  PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "case False"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "with EP_wf"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP", "by (simp add: wf_jvmprog_def)"], ["proof (state)\nthis:\n  PROG (Abs_wf_jvmprog (EP, Phi_EP)) = EP\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "proof (cases \"(EP, Phi_EP) \\<in> wf_jvmprog\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "case True"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "thus ?thesis"], ["proof (prove)\nusing this:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (1 subgoal):\n 1. TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "by (simp add: Abs_wf_jvmprog_inverse)"], ["proof (state)\nthis:\n  TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "case False"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "with EP_wf"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP", "by (simp add: wf_jvmprog_def)"], ["proof (state)\nthis:\n  TYPING (Abs_wf_jvmprog (EP, Phi_EP)) = Phi_EP\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma method_in_EP_is_M:\n  \"EP \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl, is, xt) in D\n  \\<Longrightarrow> C = ''C'' \\<and> M = ''M'' \\<and> Ts = [] \\<and> T = Void \\<and> mxs = 1 \\<and> mxl = 0 \\<and>\n  is = [Push Unit, instr.Return] \\<and> xt = [] \\<and> D = ''C''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EP \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl, is,\n            xt) in D \\<Longrightarrow>\n    C = ''C'' \\<and>\n    M = ''M'' \\<and>\n    Ts = [] \\<and>\n    T = Void \\<and>\n    mxs = 1 \\<and>\n    mxl = 0 \\<and>\n    is = [Push Unit, instr.Return] \\<and> xt = [] \\<and> D = ''C''", "by (fastforce elim: Methods.cases \n    simp: class_def SystemClasses_def ObjectC_def NullPointerC_def OutOfMemoryC_def ClassCastC_def\n    if_split_eq1 EP_def Method_def)"], ["", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> is \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       is \\<noteq> []", "using EP_wf"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       is \\<noteq> []", "by (fastforce dest: mdecl_visible simp: wf_jvm_prog_phi_def EP_def)"], ["", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> \n  Suc 0 < length is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       Suc 0 < length is", "using EP_wf"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       Suc 0 < length is", "by (fastforce dest: mdecl_visible simp: wf_jvm_prog_phi_def EP_def)"], ["", "lemma C_sees_M_in_EP [simp]:\n  \"EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0, [Push Unit, instr.Return], []) in ''C''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                       [Push Unit, instr.Return], []) in ''C''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                       [Push Unit, instr.Return], []) in ''C''", "have \"EP \\<turnstile> ''C'' sees_methods [''M'' \\<mapsto> (([], Void, 1, 0, [Push Unit, instr.Return], []), ''C'')]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EP \\<turnstile> ''C'' sees_methods [''M'' \\<mapsto>\n  (([], Void, 1, 0, [Push Unit, instr.Return], []), ''C'')]", "by (fastforce intro: Methods.intros simp: class_def SystemClasses_def ObjectC_def EP_def)"], ["proof (state)\nthis:\n  EP \\<turnstile> ''C'' sees_methods [''M'' \\<mapsto>\n(([], Void, 1, 0, [Push Unit, instr.Return], []), ''C'')]\n\ngoal (1 subgoal):\n 1. EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                       [Push Unit, instr.Return], []) in ''C''", "thus ?thesis"], ["proof (prove)\nusing this:\n  EP \\<turnstile> ''C'' sees_methods [''M'' \\<mapsto>\n(([], Void, 1, 0, [Push Unit, instr.Return], []), ''C'')]\n\ngoal (1 subgoal):\n 1. EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                       [Push Unit, instr.Return], []) in ''C''", "by (fastforce simp: Method_def)"], ["proof (state)\nthis:\n  EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                     [Push Unit, instr.Return], []) in ''C''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma instrs_of_EP_C_M [simp]:\n  \"instrs_of EP ''C'' ''M'' = [Push Unit, instr.Return]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. instrs_of EP ''C'' ''M'' = [Push Unit, instr.Return]", "unfolding method_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (snd (snd (snd (snd (THE (D, Ts, T, m).\n                                     EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D)))))) =\n    [Push Unit, instr.Return]", "by (rule theI2 [where P = \"\\<lambda>(D, Ts, T, m). EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D\"])\n(auto dest: method_in_EP_is_M)"], ["", "lemma ClassMain_not_C [simp]: \"ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<noteq> ''C''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<noteq> ''C''", "by (fastforce intro: no_Call_in_ClassMain [where P=\"Abs_wf_jvmprog (EP, Phi_EP)\"] C_sees_M_in_EP)"], ["", "lemma method_entry [dest!]: \"(Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \\<turnstile> \\<Rightarrow>(C, M, None, Enter)\n  \\<Longrightarrow> (C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<and> M = MethodMain (Abs_wf_jvmprog (EP, Phi_EP)))\n  \\<or> (C = ''C'' \\<and> M = ''M'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n      ''M'') \\<turnstile> \\<Rightarrow>(C, M, None, Enter) \\<Longrightarrow>\n    C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<and>\n    M = MethodMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<or>\n    C = ''C'' \\<and> M = ''M''", "by (fastforce elim: reachable.cases elim!: JVMCFG.cases dest!: method_in_EP_is_M)"], ["", "lemma valid_node_in_EP_D:\n  assumes vn: \"JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M'' n\"\n  shows \"n \\<in> {\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Return),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Enter),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Normal),\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Return),\n  (''C'', ''M'', None, Enter),\n  (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n  (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n  (''C'', ''M'', None, Return)\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "using vn"], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M'' n\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "proof (cases rule: JVMCFG_Interpret.valid_node_cases')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        sourcenode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "let ?prog = \"Abs_wf_jvmprog (EP, Phi_EP)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        sourcenode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "case (Source e)"], ["proof (state)\nthis:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e\n  sourcenode e = n\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        sourcenode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "then"], ["proof (chain)\npicking this:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e\n  sourcenode e = n", "obtain C M pc nt ek C' M' pc' nt'\n    where [simp]: \"e = ((C, M, pc, nt), ek, (C', M', pc', nt'))\"\n    and [simp]: \"n = (C, M, pc, nt)\"\n    and edge: \"(?prog, ''C'', ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\""], ["proof (prove)\nusing this:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e\n  sourcenode e = n\n\ngoal (1 subgoal):\n 1. (\\<And>C M pc nt ek C' M' pc' nt'.\n        \\<lbrakk>e = ((C, M, pc, nt), ek, C', M', pc', nt');\n         n = (C, M, pc, nt);\n          (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n           ''M'') \\<turnstile> (C, M, pc,\n                                nt) -ek\\<rightarrow> (C', M', pc',\n                nt')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e) (fastforce simp: valid_edge_def)"], ["proof (state)\nthis:\n  e = ((C, M, pc, nt), ek, C', M', pc', nt')\n  n = (C, M, pc, nt)\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        sourcenode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "from edge"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')", "have src_reachable: \"(?prog, ''C'', ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n\ngoal (1 subgoal):\n 1.  (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n      ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)", "by -(drule sourcenode_reachable)"], ["proof (state)\nthis:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        sourcenode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "proof (cases \"C = ClassMain ?prog\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "case True"], ["proof (state)\nthis:\n  C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (2 subgoals):\n 1. C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "with src_reachable"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))", "have \"M = MethodMain ?prog\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. M = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))", "by (fastforce dest: ClassMain_imp_MethodMain)"], ["proof (state)\nthis:\n  M = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (2 subgoals):\n 1. C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "with True edge"], ["proof (chain)\npicking this:\n  C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  M = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))", "show ?thesis"], ["proof (prove)\nusing this:\n  C = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  M = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by clarsimp (erule JVMCFG.cases, simp_all)"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal (1 subgoal):\n 1. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "case False"], ["proof (state)\nthis:\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "with src_reachable"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))", "obtain T Ts mb where \"EP \\<turnstile> C sees M:Ts\\<rightarrow>T = mb in C\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mb.\n        EP \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: method_of_reachable_node_exists)"], ["proof (state)\nthis:\n  EP \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C\n\ngoal (1 subgoal):\n 1. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "hence [simp]: \"C = ''C''\"\n      and [simp]: \"M = ''M''\"\n      and [simp]: \"Ts = []\"\n      and [simp]: \"T = Void\"\n      and [simp]: \"mb = (1, 0, [Push Unit, instr.Return], [])\""], ["proof (prove)\nusing this:\n  EP \\<turnstile> C sees M: Ts\\<rightarrow>T = mb in C\n\ngoal (1 subgoal):\n 1. (C = ''C'' &&& M = ''M'') &&&\n    Ts = [] &&& T = Void &&& mb = (1, 0, [Push Unit, instr.Return], [])", "by (cases mb, fastforce dest: method_in_EP_is_M)+"], ["proof (state)\nthis:\n  C = ''C''\n  M = ''M''\n  Ts = []\n  T = Void\n  mb = (1, 0, [Push Unit, instr.Return], [])\n\ngoal (1 subgoal):\n 1. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "from src_reachable False"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))", "have \"pc \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C, M, pc, nt)\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. pc \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}", "by (fastforce dest: instr_of_reachable_node_typable)"], ["proof (state)\nthis:\n  pc \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\n\ngoal (1 subgoal):\n 1. C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "proof (cases pc)"], ["proof (state)\ngoal (2 subgoals):\n 1. pc = None \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>a.\n       pc = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case None"], ["proof (state)\nthis:\n  pc = None\n\ngoal (2 subgoals):\n 1. pc = None \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>a.\n       pc = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with edge False"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n  pc = None", "show ?thesis"], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n  pc = None\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by clarsimp (erule JVMCFG.cases, simp_all)"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       pc = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       pc = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case (Some pc')"], ["proof (state)\nthis:\n  pc = \\<lfloor>pc'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       pc = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "proof (cases pc')"], ["proof (state)\ngoal (2 subgoals):\n 1. pc' = 0 \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>nat.\n       pc' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case 0"], ["proof (state)\nthis:\n  pc' = 0\n\ngoal (2 subgoals):\n 1. pc' = 0 \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>nat.\n       pc' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with Some False edge"], ["proof (chain)\npicking this:\n  pc = \\<lfloor>pc'\\<rfloor>\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc'__, nt')\n  pc' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  pc = \\<lfloor>pc'\\<rfloor>\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc'__, nt')\n  pc' = 0\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by clarsimp (erule JVMCFG.cases, fastforce+)"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case (Suc n)"], ["proof (state)\nthis:\n  pc' = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with \\<open>pc \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\\<close> Some"], ["proof (chain)\npicking this:\n  pc \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\n  pc = \\<lfloor>pc'\\<rfloor>\n  pc' = Suc n", "have \"pc = \\<lfloor>1\\<rfloor>\""], ["proof (prove)\nusing this:\n  pc \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\n  pc = \\<lfloor>pc'\\<rfloor>\n  pc' = Suc n\n\ngoal (1 subgoal):\n 1. pc = \\<lfloor>1\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  pc = \\<lfloor>1\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with False edge"], ["proof (chain)\npicking this:\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc'__, nt')\n  pc = \\<lfloor>1\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc'__, nt')\n  pc = \\<lfloor>1\\<rfloor>\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by clarsimp (erule JVMCFG.cases, fastforce+)"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "let ?prog = \"Abs_wf_jvmprog (EP, Phi_EP)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "case (Target e)"], ["proof (state)\nthis:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e\n  targetnode e = n\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "then"], ["proof (chain)\npicking this:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e\n  targetnode e = n", "obtain C M pc nt ek C' M' pc' nt'\n    where [simp]: \"e = ((C, M, pc, nt), ek, (C', M', pc', nt'))\"\n    and [simp]: \"n = (C', M', pc', nt')\"\n    and edge: \"(?prog, ''C'', ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\""], ["proof (prove)\nusing this:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e\n  targetnode e = n\n\ngoal (1 subgoal):\n 1. (\\<And>C M pc nt ek C' M' pc' nt'.\n        \\<lbrakk>e = ((C, M, pc, nt), ek, C', M', pc', nt');\n         n = (C', M', pc', nt');\n          (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n           ''M'') \\<turnstile> (C, M, pc,\n                                nt) -ek\\<rightarrow> (C', M', pc',\n                nt')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e) (fastforce simp: valid_edge_def)"], ["proof (state)\nthis:\n  e = ((C, M, pc, nt), ek, C', M', pc', nt')\n  n = (C', M', pc', nt')\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "from edge"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')", "have trg_reachable: \"(?prog, ''C'', ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n\ngoal (1 subgoal):\n 1.  (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n      ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')", "by -(drule targetnode_reachable)"], ["proof (state)\nthis:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') e;\n        targetnode e = n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   None, nodeType.Return),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Enter),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, Normal),\n                                  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                                   \\<lfloor>0\\<rfloor>, nodeType.Return),\n                                  (''C'', ''M'', None, Enter),\n                                  (''C'', ''M'', \\<lfloor>0\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', \\<lfloor>1\\<rfloor>,\n                                   Enter),\n                                  (''C'', ''M'', None, nodeType.Return)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "proof (cases \"C' = ClassMain ?prog\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "case True"], ["proof (state)\nthis:\n  C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (2 subgoals):\n 1. C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "with trg_reachable"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\n  C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))", "have \"M' = MethodMain ?prog\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\n  C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. M' = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))", "by (fastforce dest: ClassMain_imp_MethodMain)"], ["proof (state)\nthis:\n  M' = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (2 subgoals):\n 1. C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "with True edge"], ["proof (chain)\npicking this:\n  C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  M' = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))", "show ?thesis"], ["proof (prove)\nusing this:\n  C' = ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  M' = MethodMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by -(clarsimp, (erule JVMCFG.cases, simp_all))+"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "case False"], ["proof (state)\nthis:\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "with trg_reachable"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))", "obtain T Ts mb where \"EP \\<turnstile> C' sees M':Ts\\<rightarrow>T = mb in C'\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mb.\n        EP \\<turnstile> C' sees M': Ts\\<rightarrow>T = mb in C' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: method_of_reachable_node_exists)"], ["proof (state)\nthis:\n  EP \\<turnstile> C' sees M': Ts\\<rightarrow>T = mb in C'\n\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "hence [simp]: \"C' = ''C''\"\n      and [simp]: \"M' = ''M''\"\n      and [simp]: \"Ts = []\"\n      and [simp]: \"T = Void\"\n      and [simp]: \"mb = (1, 0, [Push Unit, instr.Return], [])\""], ["proof (prove)\nusing this:\n  EP \\<turnstile> C' sees M': Ts\\<rightarrow>T = mb in C'\n\ngoal (1 subgoal):\n 1. (C' = ''C'' &&& M' = ''M'') &&&\n    Ts = [] &&& T = Void &&& mb = (1, 0, [Push Unit, instr.Return], [])", "by (cases mb, fastforce dest: method_in_EP_is_M)+"], ["proof (state)\nthis:\n  C' = ''C''\n  M' = ''M''\n  Ts = []\n  T = Void\n  mb = (1, 0, [Push Unit, instr.Return], [])\n\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "from trg_reachable False"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))", "have \"pc' \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(C', M', pc', nt')\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n\ngoal (1 subgoal):\n 1. pc' \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}", "by (fastforce dest: instr_of_reachable_node_typable)"], ["proof (state)\nthis:\n  pc' \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\n\ngoal (1 subgoal):\n 1. C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP)) \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "proof (cases pc')"], ["proof (state)\ngoal (2 subgoals):\n 1. pc' = None \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>a.\n       pc' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case None"], ["proof (state)\nthis:\n  pc' = None\n\ngoal (2 subgoals):\n 1. pc' = None \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>a.\n       pc' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with edge False"], ["proof (chain)\npicking this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n  pc' = None", "show ?thesis"], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n  pc' = None\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by clarsimp (erule JVMCFG.cases, simp_all)"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       pc' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       pc' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case (Some pc'')"], ["proof (state)\nthis:\n  pc' = \\<lfloor>pc''\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       pc' = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "proof (cases pc'')"], ["proof (state)\ngoal (2 subgoals):\n 1. pc'' = 0 \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>nat.\n       pc'' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case 0"], ["proof (state)\nthis:\n  pc'' = 0\n\ngoal (2 subgoals):\n 1. pc'' = 0 \\<Longrightarrow>\n    n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}\n 2. \\<And>nat.\n       pc'' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with Some False edge"], ["proof (chain)\npicking this:\n  pc' = \\<lfloor>pc''\\<rfloor>\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  pc'' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  pc' = \\<lfloor>pc''\\<rfloor>\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  pc'' = 0\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by -(clarsimp, (erule JVMCFG.cases, fastforce+))+"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc'' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc'' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "case (Suc n)"], ["proof (state)\nthis:\n  pc'' = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc'' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with \\<open>pc' \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\\<close> Some"], ["proof (chain)\npicking this:\n  pc' \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\n  pc' = \\<lfloor>pc''\\<rfloor>\n  pc'' = Suc n", "have \"pc' = \\<lfloor>1\\<rfloor>\""], ["proof (prove)\nusing this:\n  pc' \\<in> {None, \\<lfloor>0\\<rfloor>, \\<lfloor>1\\<rfloor>}\n  pc' = \\<lfloor>pc''\\<rfloor>\n  pc'' = Suc n\n\ngoal (1 subgoal):\n 1. pc' = \\<lfloor>1\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  pc' = \\<lfloor>1\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       pc'' = Suc nat \\<Longrightarrow>\n       n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n                 nodeType.Return),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Enter),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, Normal),\n                (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n                 \\<lfloor>0\\<rfloor>, nodeType.Return),\n                (''C'', ''M'', None, Enter),\n                (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n                (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n                (''C'', ''M'', None, nodeType.Return)}", "with False edge"], ["proof (chain)\npicking this:\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  pc' = \\<lfloor>1\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  C' \\<noteq> ClassMain (Abs_wf_jvmprog (EP, Phi_EP))\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> (C, M, pc, nt) -ek\\<rightarrow> (C', M', pc', nt')\n  pc' = \\<lfloor>1\\<rfloor>\n\ngoal (1 subgoal):\n 1. n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n              nodeType.Return),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Enter),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              Normal),\n             (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n              nodeType.Return),\n             (''C'', ''M'', None, Enter),\n             (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n             (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n             (''C'', ''M'', None, nodeType.Return)}", "by -(clarsimp, (erule JVMCFG.cases, fastforce+))+"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n            nodeType.Return),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Enter),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            Normal),\n           (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n            nodeType.Return),\n           (''C'', ''M'', None, Enter),\n           (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n           (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n           (''C'', ''M'', None, nodeType.Return)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Main_Entry_valid [simp]:\n  \"JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n  (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)", "have \"valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n    ((ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n      Enter),\n    (\\<lambda>s. False)\\<^sub>\\<surd>,\n    (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None,\n      Return))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n      (\\<lambda>s. False)\\<^sub>\\<surd>,\n      ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (auto simp: valid_edge_def intro: JVMCFG_reachable.intros)"], ["proof (state)\nthis:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   ((ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n     MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n    (\\<lambda>s. False)\\<^sub>\\<surd>,\n    ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   ((ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n     MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter),\n    (\\<lambda>s. False)\\<^sub>\\<surd>,\n    ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)", "by (fastforce simp: JVMCFG_Interpret.valid_node_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_0_Enter_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n \\<lfloor>0\\<rfloor>, Enter)", "by (rule reachable_step [where n=\"(ClassMain P, MethodMain P, None, Enter)\"])\n(fastforce intro: JVMCFG_reachable.intros)+"], ["", "lemma main_0_Normal_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n \\<lfloor>0\\<rfloor>, Normal)", "by (rule reachable_step [where n=\"(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Enter)\"], simp)\n(fastforce intro: JVMCFG_reachable.intros)"], ["", "lemma main_0_Return_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P,\n \\<lfloor>0\\<rfloor>, nodeType.Return)", "by (rule reachable_step [where n=\"(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Normal)\"], simp)\n(fastforce intro: JVMCFG_reachable.intros)"], ["", "lemma Exit_reachable [simp]: \"(P, C0, Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, None, Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  (P, C0,\n      Main) \\<turnstile> \\<Rightarrow>(ClassMain P, MethodMain P, None,\n nodeType.Return)", "by (rule reachable_step [where n=\"(ClassMain P, MethodMain P, \\<lfloor>0\\<rfloor>, Return)\"], simp)\n(fastforce intro: JVMCFG_reachable.intros)"], ["", "definition\n  \"cfg_wf_prog =\n    {(P, C0, Main). (\\<forall>n. JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n         (\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n                         (get_return_edges P) n as (ClassMain P, MethodMain P, None, Return)))}\""], ["", "typedef cfg_wf_prog = cfg_wf_prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> cfg_wf_prog", "unfolding cfg_wf_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {(P, C0, Main).\n                \\<forall>n.\n                   JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                   (\\<exists>as.\n                       JVMCFG_Interpret.valid_path' P C0 Main n as\n                        (ClassMain P, MethodMain P, None, nodeType.Return))}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?prog = \"(Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_main0 = \"((ClassMain (fst ?prog), MethodMain (fst ?prog), None, Enter),\n    (\\<lambda>s. False)\\<^sub>\\<surd>,\n    (ClassMain (fst ?prog), MethodMain (fst ?prog), None, Return))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_main1 = \"((ClassMain (fst ?prog), MethodMain (fst ?prog), None, Enter),\n    (\\<lambda>s. True)\\<^sub>\\<surd>,\n    (ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Enter))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_main2 = \"((ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Enter),\n    \\<Up>id,\n    (ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Normal))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_main3 = \"((ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Normal),\n    (\\<lambda>s. False)\\<^sub>\\<surd>,\n    (ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Return))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_main4 = \"((ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Return),\n    \\<Up>id,\n    (ClassMain (fst ?prog), MethodMain (fst ?prog), None, Return))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_call = \"((ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Normal),\n    ((\\<lambda>(s, ret). True):(ClassMain (fst ?prog),\n      MethodMain (fst ?prog), 0)\\<hookrightarrow>\\<^bsub>(''C'', ''M'')\\<^esub>[(\\<lambda>s. s Heap),(\\<lambda>s. \\<lfloor>Value Null\\<rfloor>)]),\n    (''C'', ''M'', None, Enter))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_C0 = \"((''C'', ''M'', None, Enter),\n    (\\<lambda>s. False)\\<^sub>\\<surd>,\n    (''C'', ''M'', None, Return))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_C1 = \"((''C'', ''M'', None, Enter),\n    (\\<lambda>s. True)\\<^sub>\\<surd>,\n    (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_C2 = \"((''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n    \\<Up>(\\<lambda>s. s(Stack 0 \\<mapsto> Value Unit)),\n    (''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_C3 = \"((''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n    \\<Up>(\\<lambda>s. s(Stack 0 := s (Stack 0))),\n    (''C'', ''M'', None, Return))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "let ?edge_return = \"((''C'', ''M'', None, Return),\n    (\\<lambda>(s, ret). ret = (ClassMain (fst ?prog),\n      MethodMain (fst ?prog), 0))\\<hookleftarrow>\\<^bsub>(''C'',''M'')\\<^esub>(\\<lambda>s s'. s'(Heap := s Heap,\n                            Exception := s Exception,\n                            Stack 0 := s (Stack 0))),\n    (ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Return))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "have [simp]:\n    \"(Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', None, Enter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n      ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', None, Enter)", "by (rule reachable_step [where n=\"(ClassMain (fst ?prog), MethodMain (fst ?prog), \\<lfloor>0\\<rfloor>, Normal)\"]\n      , simp)\n  (fastforce intro: Main_Call C_sees_M_in_EP)"], ["proof (state)\nthis:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', None, Enter)\n\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "hence [simp]:\n    \"(Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', None, nodeType.Return)\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', None, Enter)\n\ngoal (1 subgoal):\n 1.  (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n      ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', None, nodeType.Return)", "by (rule reachable_step [where n=\"(''C'', ''M'', None, Enter)\"])\n  (fastforce intro: JVMCFG_reachable.intros)"], ["proof (state)\nthis:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "have [simp]:\n    \"(Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n      ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', \\<lfloor>0\\<rfloor>,\n  Enter)", "by (rule reachable_step [where n=\"(''C'', ''M'', None, Enter)\"], simp)\n  (fastforce intro: JVMCFG_reachable.intros)"], ["proof (state)\nthis:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', \\<lfloor>0\\<rfloor>,\nEnter)\n\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "hence [simp]:\n    \"(Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter)\""], ["proof (prove)\nusing this:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', \\<lfloor>0\\<rfloor>,\nEnter)\n\ngoal (1 subgoal):\n 1.  (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n      ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'',\n  \\<lfloor>Suc 0\\<rfloor>, Enter)", "by (fastforce intro: reachable_step [where n=\"(''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter)\"] CFG_Push\n      simp: ClassMain_not_C [symmetric])"], ["proof (state)\nthis:\n   (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n    ''M'') \\<turnstile> \\<Rightarrow>(''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>,\nEnter)\n\ngoal (1 subgoal):\n 1. ?x \\<in> {(P, C0, Main).\n              \\<forall>n.\n                 JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVMCFG_Interpret.valid_path' P C0 Main n as\n                      (ClassMain P, MethodMain P, None, nodeType.Return))}", "show \"?prog \\<in> {(P, C0, Main).\n          \\<forall>n. CFG.valid_node sourcenode targetnode (valid_edge (P, C0, Main)) n \\<longrightarrow>\n              (\\<exists>as. CFG.valid_path' sourcenode targetnode kind (valid_edge (P, C0, Main))\n                     (get_return_edges P) n as\n                     (ClassMain P, MethodMain P, None, nodeType.Return))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n    \\<in> {(P, C0, Main).\n           \\<forall>n.\n              JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n              (\\<exists>as.\n                  JVMCFG_Interpret.valid_path' P C0 Main n as\n                   (ClassMain P, MethodMain P, None, nodeType.Return))}", "proof (auto dest!: valid_node_in_EP_D)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 8. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 9. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, Enter)\n          [?edge_main0]\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n     [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n        Enter),\n       (\\<lambda>s. False)\\<^sub>\\<surd>,\n       ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_Interpret.intra_path_vp JVMCFG_reachable.intros\n        simp: JVMCFG_Interpret.intra_path_def intra_kind_def valid_edge_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n      Enter),\n     (\\<lambda>s. False)\\<^sub>\\<surd>,\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (9 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 8. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 9. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \" \\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, Enter)\n          as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n      Enter),\n     (\\<lambda>s. False)\\<^sub>\\<surd>,\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, Enter)\n      as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n          MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (8 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 8. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 8. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\n      [] (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n     [] (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_Interpret.intra_path_vp simp: JVMCFG_Interpret.intra_path_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n   [] (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (8 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 8. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\n          as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n   [] (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n      as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n          MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (7 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           \\<lfloor>0\\<rfloor>, Enter)\n      [?edge_main2, ?edge_main3, ?edge_main4]\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Enter)\n     [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, Enter),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       \\<lfloor>0\\<rfloor>, Normal),\n      ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, Normal),\n       (\\<lambda>s. False)\\<^sub>\\<surd>,\n       ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       \\<lfloor>0\\<rfloor>, nodeType.Return),\n      ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, nodeType.Return),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_Interpret.intra_path_vp JVMCFG_reachable.intros\n        simp: JVMCFG_Interpret.intra_path_def intra_kind_def valid_edge_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Enter)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, Enter),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, Normal),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, Normal),\n     (\\<lambda>s. False)\\<^sub>\\<surd>,\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (7 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 7. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           \\<lfloor>0\\<rfloor>, Enter)\n          as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Enter)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, Enter),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, Normal),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, Normal),\n     (\\<lambda>s. False)\\<^sub>\\<surd>,\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Enter)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Enter)\n      as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n          MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (6 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           \\<lfloor>0\\<rfloor>, Normal)\n      [?edge_main3, ?edge_main4]\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Normal)\n     [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, Normal),\n       (\\<lambda>s. False)\\<^sub>\\<surd>,\n       ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       \\<lfloor>0\\<rfloor>, nodeType.Return),\n      ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, nodeType.Return),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_Interpret.intra_path_vp JVMCFG_reachable.intros\n        simp: JVMCFG_Interpret.intra_path_def intra_kind_def valid_edge_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Normal)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, Normal),\n     (\\<lambda>s. False)\\<^sub>\\<surd>,\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (6 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 6. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           \\<lfloor>0\\<rfloor>, Normal)\n          as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>, Normal)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, Normal),\n     (\\<lambda>s. False)\\<^sub>\\<surd>,\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         Normal)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n       Normal)\n      as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n          MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (5 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           \\<lfloor>0\\<rfloor>, nodeType.Return)\n      [?edge_main4]\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n      nodeType.Return)\n     [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, nodeType.Return),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_Interpret.intra_path_vp JVMCFG_reachable.intros\n        simp: JVMCFG_Interpret.intra_path_def intra_kind_def valid_edge_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n    nodeType.Return)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (5 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 5. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP)))\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           \\<lfloor>0\\<rfloor>, nodeType.Return)\n          as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n    nodeType.Return)\n   [((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M''\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n         nodeType.Return)\n        as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n            MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), \\<lfloor>0\\<rfloor>,\n       nodeType.Return)\n      as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n          MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (4 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', None, Enter)\n      [?edge_C0, ?edge_return, ?edge_main4]\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (''C'', ''M'', None, Enter)\n     [((''C'', ''M'', None, Enter), (\\<lambda>s. False)\\<^sub>\\<surd>,\n       ''C'', ''M'', None, nodeType.Return),\n      ((''C'', ''M'', None, nodeType.Return),\n       \\<lambda>(s, ret).\n          ret =\n          (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           0)\\<hookleftarrow>\\<^bsub>(''C'',\n''M'')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack 0 := s (Stack 0)),\n       ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       \\<lfloor>0\\<rfloor>, nodeType.Return),\n      ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, nodeType.Return),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.intros C_sees_M_in_EP\n        simp: JVMCFG_Interpret.vp_def valid_edge_def stkLength_def JVMCFG_Interpret.valid_path_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', None, Enter)\n   [((''C'', ''M'', None, Enter), (\\<lambda>s. False)\\<^sub>\\<surd>, ''C'',\n     ''M'', None, nodeType.Return),\n    ((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (4 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 4. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', None, Enter) as\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', None, Enter)\n   [((''C'', ''M'', None, Enter), (\\<lambda>s. False)\\<^sub>\\<surd>, ''C'',\n     ''M'', None, nodeType.Return),\n    ((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (''C'', ''M'', None, Enter) as\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (3 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter)\n      [?edge_C2, ?edge_C3, ?edge_return, ?edge_main4]\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter)\n     [((''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n       \\<Up>\\<lambda>s. s(Stack 0 \\<mapsto> Value Unit), ''C'', ''M'',\n       \\<lfloor>1\\<rfloor>, Enter),\n      ((''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n       \\<Up>\\<lambda>s. s(Stack 0 := s (Stack 0)), ''C'', ''M'', None,\n       nodeType.Return),\n      ((''C'', ''M'', None, nodeType.Return),\n       \\<lambda>(s, ret).\n          ret =\n          (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           0)\\<hookleftarrow>\\<^bsub>(''C'',\n''M'')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack 0 := s (Stack 0)),\n       ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       \\<lfloor>0\\<rfloor>, nodeType.Return),\n      ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, nodeType.Return),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: Main_Return_to_Exit CFG_Return_from_Method Main_Call\n        C_sees_M_in_EP CFG_Return CFG_Push\n        simp: JVMCFG_Interpret.vp_def valid_edge_def stkLength_def Phi_EP_def\n        ClassMain_not_C [symmetric] JVMCFG_Interpret.valid_path_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter)\n   [((''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n     \\<Up>\\<lambda>s. s(Stack 0 \\<mapsto> Value Unit), ''C'', ''M'',\n     \\<lfloor>1\\<rfloor>, Enter),\n    ((''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n     \\<Up>\\<lambda>s. s(Stack 0 := s (Stack 0)), ''C'', ''M'', None,\n     nodeType.Return),\n    ((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (3 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 3. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter)\n   [((''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter),\n     \\<Up>\\<lambda>s. s(Stack 0 \\<mapsto> Value Unit), ''C'', ''M'',\n     \\<lfloor>1\\<rfloor>, Enter),\n    ((''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n     \\<Up>\\<lambda>s. s(Stack 0 := s (Stack 0)), ''C'', ''M'', None,\n     nodeType.Return),\n    ((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (''C'', ''M'', \\<lfloor>0\\<rfloor>, Enter) as\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter)\n      [?edge_C3, ?edge_return, ?edge_main4]\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter)\n     [((''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n       \\<Up>\\<lambda>s. s(Stack 0 := s (Stack 0)), ''C'', ''M'', None,\n       nodeType.Return),\n      ((''C'', ''M'', None, nodeType.Return),\n       \\<lambda>(s, ret).\n          ret =\n          (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           0)\\<hookleftarrow>\\<^bsub>(''C'',\n''M'')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack 0 := s (Stack 0)),\n       ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       \\<lfloor>0\\<rfloor>, nodeType.Return),\n      ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, nodeType.Return),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.intros C_sees_M_in_EP\n        simp: JVMCFG_Interpret.vp_def valid_edge_def stkLength_def Phi_EP_def\n        ClassMain_not_C [symmetric] JVMCFG_Interpret.valid_path_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter)\n   [((''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n     \\<Up>\\<lambda>s. s(Stack 0 := s (Stack 0)), ''C'', ''M'', None,\n     nodeType.Return),\n    ((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n 2. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n          (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n           None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter)\n   [((''C'', ''M'', \\<lfloor>1\\<rfloor>, Enter),\n     \\<Up>\\<lambda>s. s(Stack 0 := s (Stack 0)), ''C'', ''M'', None,\n     nodeType.Return),\n    ((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (''C'', ''M'', \\<lfloor>Suc 0\\<rfloor>, Enter) as\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "have \"CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', None, nodeType.Return)\n          [?edge_return, ?edge_main4]\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n     (''C'', ''M'', None, nodeType.Return)\n     [((''C'', ''M'', None, nodeType.Return),\n       \\<lambda>(s, ret).\n          ret =\n          (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n           0)\\<hookleftarrow>\\<^bsub>(''C'',\n''M'')\\<^esub>\\<lambda>s s'. s'\n                 (Heap := s Heap, Exception := s Exception,\n                  Stack 0 := s (Stack 0)),\n       ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       \\<lfloor>0\\<rfloor>, nodeType.Return),\n      ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n        \\<lfloor>0\\<rfloor>, nodeType.Return),\n       \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n       MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n       nodeType.Return)]\n     (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n      MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by (fastforce intro: JVMCFG_reachable.intros C_sees_M_in_EP\n        simp: JVMCFG_Interpret.vp_def valid_edge_def JVMCFG_Interpret.valid_path_def stkLength_def)"], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', None, nodeType.Return)\n   [((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n          (valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M''))\n          (get_return_edges (Abs_wf_jvmprog (EP, Phi_EP))) (''C'', ''M'', None, nodeType.Return)\n          as (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)), MethodMain (Abs_wf_jvmprog (EP, Phi_EP)),\n              None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n   (''C'', ''M'', None, nodeType.Return)\n   [((''C'', ''M'', None, nodeType.Return),\n     \\<lambda>(s, ret).\n        ret =\n        (ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n         0)\\<hookleftarrow>\\<^bsub>(''C'',\n                                    ''M'')\\<^esub>\\<lambda>s s'. s'\n               (Heap := s Heap, Exception := s Exception,\n                Stack 0 := s (Stack 0)),\n     ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     \\<lfloor>0\\<rfloor>, nodeType.Return),\n    ((ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n      \\<lfloor>0\\<rfloor>, nodeType.Return),\n     \\<Up>id, ClassMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')),\n     MethodMain (fst (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')), None,\n     nodeType.Return)]\n   (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n    MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C''\n        ''M'' (''C'', ''M'', None, nodeType.Return) as\n        (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n         MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (Abs_wf_jvmprog (EP, Phi_EP)) ''C'' ''M''\n      (''C'', ''M'', None, nodeType.Return) as\n      (ClassMain (Abs_wf_jvmprog (EP, Phi_EP)),\n       MethodMain (Abs_wf_jvmprog (EP, Phi_EP)), None, nodeType.Return)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n  \\<in> {(P, C0, Main).\n         \\<forall>n.\n            JVMCFG_Interpret.valid_node P C0 Main n \\<longrightarrow>\n            (\\<exists>as.\n                JVMCFG_Interpret.valid_path' P C0 Main n as\n                 (ClassMain P, MethodMain P, None, nodeType.Return))}\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation lift_to_cfg_wf_prog :: \"(jvm_method \\<Rightarrow> 'a) \\<Rightarrow> (cfg_wf_prog \\<Rightarrow> 'a)\"\n  (\"_\\<^bsub>CFG\\<^esub>\")\n  where \"f\\<^bsub>CFG\\<^esub> \\<equiv> (\\<lambda>P. f (Rep_cfg_wf_prog P))\""], ["", "lemma valid_edge_CFG_def: \"valid_edge\\<^bsub>CFG\\<^esub> P = valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge\\<^bsub>CFG\\<^esub> P =\n    valid_edge\n     (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P),\n      snd (snd\\<^bsub>CFG\\<^esub> P))", "by (cases P) (clarsimp simp: Abs_cfg_wf_prog_inverse)"], ["", "interpretation JVMCFG_Postdomination:\n  Postdomination \"sourcenode\" \"targetnode\" \"kind\" \"valid_edge\\<^bsub>CFG\\<^esub> P\"\n  \"(ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\"\n  \"(\\<lambda>(C, M, pc, type). (C, M))\" \"get_return_edges (fst\\<^bsub>CFG\\<^esub> P)\"\n  \"((ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P)),[],[]) # procs (PROG (fst\\<^bsub>CFG\\<^esub> P))\"\n  \"(ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P))\"\n  \"(ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Return)\"\n  for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind\n     (valid_edge\\<^bsub>CFG\\<^esub> P)\n     (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n      MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n     (\\<lambda>(C, M, pc, type). (C, M))\n     (get_return_edges (fst\\<^bsub>CFG\\<^esub> P))\n     (((ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n        MethodMain (fst\\<^bsub>CFG\\<^esub> P)),\n       [], []) #\n      procs (PROG (fst\\<^bsub>CFG\\<^esub> P)))\n     (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n      MethodMain (fst\\<^bsub>CFG\\<^esub> P))\n     (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n      MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)", "unfolding valid_edge_CFG_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind\n     (valid_edge\n       (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P),\n        snd (snd\\<^bsub>CFG\\<^esub> P)))\n     (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n      MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n     (\\<lambda>(C, M, pc, type). (C, M))\n     (get_return_edges (fst\\<^bsub>CFG\\<^esub> P))\n     (((ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n        MethodMain (fst\\<^bsub>CFG\\<^esub> P)),\n       [], []) #\n      procs (PROG (fst\\<^bsub>CFG\\<^esub> P)))\n     (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n      MethodMain (fst\\<^bsub>CFG\\<^esub> P))\n     (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n      MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n           as n\n 2. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 3. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n           as n\n 2. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 3. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "obtain P' C0 Main where [simp]: \"fst\\<^bsub>CFG\\<^esub> P = P'\" and [simp]: \"fst (snd\\<^bsub>CFG\\<^esub> P) = C0\"\n    and [simp]: \"snd (snd\\<^bsub>CFG\\<^esub> P) = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P' C0 Main.\n        \\<lbrakk>fst\\<^bsub>CFG\\<^esub> P = P';\n         fst (snd\\<^bsub>CFG\\<^esub> P) = C0;\n         snd (snd\\<^bsub>CFG\\<^esub> P) = Main\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases P) clarsimp"], ["proof (state)\nthis:\n  fst\\<^bsub>CFG\\<^esub> P = P'\n  fst (snd\\<^bsub>CFG\\<^esub> P) = C0\n  snd (snd\\<^bsub>CFG\\<^esub> P) = Main\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n           as n\n 2. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 3. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"CFG.valid_node sourcenode targetnode\n    (valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P))) n\""], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n           as n\n 2. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 3. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n    (valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P)))\n    (get_return_edges (fst\\<^bsub>CFG\\<^esub> P))\n    (ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter) as n\""], ["proof (prove)\nusing this:\n  JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n         MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n        as n", "by (auto dest: sourcenode_reachable targetnode_reachable valid_Entry_path\n      simp: JVMCFG_Interpret.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n      (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n      (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n       MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, Enter)\n      as n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 2. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 2. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 2. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "obtain P' C0 Main where [simp]: \"fst\\<^bsub>CFG\\<^esub> P = P'\" and [simp]: \"fst (snd\\<^bsub>CFG\\<^esub> P) = C0\"\n    and [simp]: \"snd (snd\\<^bsub>CFG\\<^esub> P) = Main\"\n    and \"(P', C0, Main) \\<in> cfg_wf_prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P' C0 Main.\n        \\<lbrakk>fst\\<^bsub>CFG\\<^esub> P = P';\n         fst (snd\\<^bsub>CFG\\<^esub> P) = C0;\n         snd (snd\\<^bsub>CFG\\<^esub> P) = Main;\n         (P', C0, Main) \\<in> cfg_wf_prog\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases P) (clarsimp simp: Abs_cfg_wf_prog_inverse)"], ["proof (state)\nthis:\n  fst\\<^bsub>CFG\\<^esub> P = P'\n  fst (snd\\<^bsub>CFG\\<^esub> P) = C0\n  snd (snd\\<^bsub>CFG\\<^esub> P) = Main\n  (P', C0, Main) \\<in> cfg_wf_prog\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 2. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"CFG.valid_node sourcenode targetnode\n    (valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P))) n\""], ["proof (state)\nthis:\n  JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n           (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n           n as\n           (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n 2. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>(P', C0, Main) \\<in> cfg_wf_prog\\<close>"], ["proof (chain)\npicking this:\n  (P', C0, Main) \\<in> cfg_wf_prog\n  JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n", "show \"\\<exists>as. CFG.valid_path' sourcenode targetnode kind\n    (valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P)))\n    (get_return_edges (fst\\<^bsub>CFG\\<^esub> P)) n as\n    (ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\""], ["proof (prove)\nusing this:\n  (P', C0, Main) \\<in> cfg_wf_prog\n  JVMCFG_Interpret.valid_node (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n        (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n\n        as (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n            MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)", "by (cases n) (fastforce simp: cfg_wf_prog_def)"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVMCFG_Interpret.valid_path' (fst\\<^bsub>CFG\\<^esub> P)\n      (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n as\n      (ClassMain (fst\\<^bsub>CFG\\<^esub> P),\n       MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return)\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "obtain P' C0 Main where [simp]: \"fst\\<^bsub>CFG\\<^esub> P = P'\" and [simp]: \"fst (snd\\<^bsub>CFG\\<^esub> P) = C0\"\n    and [simp]: \"snd (snd\\<^bsub>CFG\\<^esub> P) = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P' C0 Main.\n        \\<lbrakk>fst\\<^bsub>CFG\\<^esub> P = P';\n         fst (snd\\<^bsub>CFG\\<^esub> P) = C0;\n         snd (snd\\<^bsub>CFG\\<^esub> P) = Main\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases P) clarsimp"], ["proof (state)\nthis:\n  fst\\<^bsub>CFG\\<^esub> P = P'\n  fst (snd\\<^bsub>CFG\\<^esub> P) = C0\n  snd (snd\\<^bsub>CFG\\<^esub> P) = Main\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"CFGExit.method_exit sourcenode kind\n    (valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P)))\n    (ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return) n\"\n    and \"CFGExit.method_exit sourcenode kind\n    (valid_edge (fst\\<^bsub>CFG\\<^esub> P, fst (snd\\<^bsub>CFG\\<^esub> P), snd (snd\\<^bsub>CFG\\<^esub> P)))\n    (ClassMain (fst\\<^bsub>CFG\\<^esub> P), MethodMain (fst\\<^bsub>CFG\\<^esub> P), None, nodeType.Return) n'\"\n    and \"(\\<lambda>(C, M, pc, type). (C, M)) n = (\\<lambda>(C, M, pc, type). (C, M)) n'\""], ["proof (state)\nthis:\n  JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n\n  JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n'\n  (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n  (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n                 (fst (snd\\<^bsub>CFG\\<^esub> P))\n                 (snd (snd\\<^bsub>CFG\\<^esub> P)) n;\n        JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n         (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P))\n         n';\n        (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n        (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus \"n = n'\""], ["proof (prove)\nusing this:\n  JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n\n  JVMCFG_Exit_Interpret.method_exit (fst\\<^bsub>CFG\\<^esub> P)\n   (fst (snd\\<^bsub>CFG\\<^esub> P)) (snd (snd\\<^bsub>CFG\\<^esub> P)) n'\n  (case n of (C, M, pc, type) \\<Rightarrow> (C, M)) =\n  (case n' of (C, M, pc, type) \\<Rightarrow> (C, M))\n\ngoal (1 subgoal):\n 1. n = n'", "by (auto simp: JVMCFG_Exit_Interpret.method_exit_def valid_edge_def)\n  (fastforce elim: JVMCFG.cases)+"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}