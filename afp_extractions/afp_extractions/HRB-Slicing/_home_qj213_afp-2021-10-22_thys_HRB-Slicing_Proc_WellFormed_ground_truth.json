{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/Proc/WellFormed.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma Proc_CFG_Call_target_fst_cmd_Skip:\n  \"\\<lbrakk>labels prog l' c; prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\\<rbrakk> \n  \\<Longrightarrow> fst_cmd c = Skip\"", "lemma Proc_CFG_Call_source_fst_cmd_Call:\n  \"\\<lbrakk>labels prog l c; prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk> \n  \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\"", "lemma PCFG_CallEdge_THE_rets:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\n\\<Longrightarrow> (THE rets'. \\<exists>p' es' n. prog \\<turnstile> n -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n') = rets\"", "lemma in_procs_THE_in_procs_cmd:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\"", "lemma ParamDefs_Main_Return_target:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> ParamDefs wfp (Main,n') = rets\"", "lemma ParamDefs_Proc_Return_target:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamDefs wfp (p,n') = rets\"", "lemma ParamDefs_Main_IEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> ParamDefs wfp (Main,n') = []\"", "lemma ParamDefs_Proc_IEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamDefs wfp (p,n') = []\"", "lemma ParamDefs_Main_CEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n  \\<Longrightarrow> ParamDefs wfp (Main,n') = []\"", "lemma ParamDefs_Proc_CEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n''\"\n  shows \"ParamDefs wfp (p,n') = []\"", "lemma assumes \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n  and \"(p, ins, outs) \\<in> set (lift_procs wfp)\"\n  shows ParamDefs_length:\"length (ParamDefs wfp (targetnode a)) = length outs\"\n  (is ?length)\n  and Return_update:\"f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\"\n  (is ?update)", "lemma rhs_interpret_eq: \n  \"\\<lbrakk>state_check cf e v'; \\<forall>V \\<in> fv e. cf V = cf' V\\<rbrakk> \n   \\<Longrightarrow> state_check cf' e v'\"", "lemma PCFG_CallEdge_THE_es:\n  \"prog \\<turnstile> n -CEdge(p,es,rets)\\<rightarrow>\\<^sub>p n'\n\\<Longrightarrow> (THE es'. \\<exists>p' rets' n'. prog \\<turnstile> n -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n') = es\"", "lemma ParamUses_Main_Return_target:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n' \\<rbrakk>\n  \\<Longrightarrow> ParamUses wfp (Main,n) = map fv es\"", "lemma ParamUses_Proc_Return_target:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamUses wfp (p,n) = map fv es\"", "lemma ParamUses_Main_IEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> ParamUses wfp (Main,n) = []\"", "lemma ParamUses_Proc_IEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamUses wfp (p,n) = []\"", "lemma ParamUses_Main_CEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n\\<rbrakk>\n  \\<Longrightarrow> ParamUses wfp (Main,n) = []\"", "lemma ParamUses_Proc_CEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n\"\n  shows \"ParamUses wfp (p,n) = []\"", "lemma lhs_fst_cmd:\"lhs (fst_cmd c) = lhs c\"", "lemma Proc_CFG_Call_source_empty_lhs:\n  assumes \"prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows \"lhs (label prog l) = {}\"", "lemma in_procs_THE_in_procs_ins:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE ins'. \\<exists>c' outs'. (p,ins',outs',c') \\<in> set procs) = ins\"", "lemma Entry_Def_empty:\"Def wfp (Main, Entry) = {}\"", "lemma Exit_Def_empty:\"Def wfp (Main, Exit) = {}\"", "lemma rhs_fst_cmd:\"rhs (fst_cmd c) = rhs c\"", "lemma Proc_CFG_Call_target_empty_rhs:\n  assumes \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\"\n  shows \"rhs (label prog l') = {}\"", "lemma in_procs_THE_in_procs_outs:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE outs'. \\<exists>c' ins'. (p,ins',outs',c') \\<in> set procs) = outs\"", "lemma Entry_Use_empty:\"Use wfp (Main, Entry) = {}\"", "lemma Exit_Use_empty:\"Use wfp (Main, Exit) = {}\"", "lemmas transfers_simps = ProcCFG.transfer.simps[simplified]", "lemma Proc_CFG_edge_no_lhs_equal:\n  assumes \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\" and \"V \\<notin> lhs (label prog l)\"\n  shows \"state_val (CFG.transfer (lift_procs wfp) et (cf#cfs)) V = fst cf V\"", "lemma Proc_CFG_edge_uses_only_rhs:\n  assumes \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\" and \"CFG.pred et s\"\n  and \"CFG.pred et s'\" and \"\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\"\n  shows \"\\<forall>V\\<in>lhs (label prog l). \n    state_val (CFG.transfer (lift_procs wfp) et s) V =\n    state_val (CFG.transfer (lift_procs wfp) et s') V\"", "lemma Proc_CFG_edge_rhs_pred_eq:\n  assumes \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\" and \"CFG.pred et s\"\n  and \"\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\"\n  and \"length s = length s'\"\n  shows \"CFG.pred et s'\""], "translations": [["", "lemma Proc_CFG_Call_target_fst_cmd_Skip:\n  \"\\<lbrakk>labels prog l' c; prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\\<rbrakk> \n  \\<Longrightarrow> fst_cmd c = Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>labels prog l' c;\n     prog \\<turnstile> n -CEdge\n                           (p, es,\n                            rets)\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n    \\<Longrightarrow> fst_cmd c = Skip", "proof(induct arbitrary:n rule:labels.induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          l\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; c\\<^sub>2) = Skip\n 4. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 7. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 8. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 9. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "case (Labels_Seq1 c\\<^sub>1 l c c\\<^sub>2)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c\n  c\\<^sub>1 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (9 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          l\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; c\\<^sub>2) = Skip\n 4. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 7. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 8. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 9. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "note IH = \\<open>\\<And>n. c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow> fst_cmd c = Skip\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n\ngoal (9 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          l\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; c\\<^sub>2) = Skip\n 4. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 7. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 8. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 9. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from \\<open>c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\\<close> \\<open>labels c\\<^sub>1 l c\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n  labels c\\<^sub>1 l c", "have \"c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n  labels c\\<^sub>1 l c\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n -CEdge\n                               (p, es, rets)\\<rightarrow>\\<^sub>p Label l", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n     labels c\\<^sub>1 l c\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n -CEdge\n           (p, es, rets)\\<rightarrow>\\<^sub>p Label l", "apply(erule Proc_CFG.cases,auto dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>labels c\\<^sub>1 l c; n = n \\<oplus> #:c\\<^sub>1;\n        Label l = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(case_tac n')(auto dest:label_less_num_inner_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (9 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          l\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; c\\<^sub>2) = Skip\n 4. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 7. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 8. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 9. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from IH[OF this]"], ["proof (chain)\npicking this:\n  fst_cmd c = Skip", "show ?case"], ["proof (prove)\nusing this:\n  fst_cmd c = Skip\n\ngoal (1 subgoal):\n 1. fst_cmd (c;; c\\<^sub>2) = Skip", "by simp"], ["proof (state)\nthis:\n  fst_cmd (c;; c\\<^sub>2) = Skip\n\ngoal (8 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 7. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 8. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 7. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 8. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "case (Labels_Seq2 c\\<^sub>2 l c c\\<^sub>1)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l c\n  c\\<^sub>2 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    (l + #:c\\<^sub>1)\n\ngoal (8 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 7. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 8. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "note IH = \\<open>\\<And>n. c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow> fst_cmd c = Skip\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n\ngoal (8 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 7. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 8. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from \\<open>c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1)\\<close> \\<open>labels c\\<^sub>2 l c\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    (l + #:c\\<^sub>1)\n  labels c\\<^sub>2 l c", "obtain nx where \"c\\<^sub>2 \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    (l + #:c\\<^sub>1)\n  labels c\\<^sub>2 l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> nx -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label\n                           l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -CEdge\n      (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label\n                       (l + #:c\\<^sub>1);\n     labels c\\<^sub>2 l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = prog; n = Entry;\n        CEdge (p, es, rets) = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        Label (l + #:c\\<^sub>1) = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = prog; n = Entry;\n        CEdge (p, es, rets) = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        Label (l + #:c\\<^sub>1) = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -CEdge\n      (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                thesis;\n     labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = Skip; n = Label 0;\n     CEdge (p, es, rets) = IEdge \\<Up>id;\n     Label (l + #:c\\<^sub>1) = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = V:=e; n = Label 0;\n        CEdge (p, es, rets) = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        Label (l + #:c\\<^sub>1) = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = V:=e; n = Label 1;\n        CEdge (p, es, rets) = IEdge \\<Up>id;\n        Label (l + #:c\\<^sub>1) = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n = n;\n        CEdge (p, es, rets) = et; Label (l + #:c\\<^sub>1) = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n = n;\n        CEdge (p, es, rets) = et;\n        Label (l + #:c\\<^sub>1) = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n = n \\<oplus> #:c\\<^sub>1'; CEdge (p, es, rets) = et;\n        Label (l + #:c\\<^sub>1) = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n        n = Label 0;\n        CEdge (p, es, rets) =\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        Label (l + #:c\\<^sub>1) = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> nx -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                    thesis;\n         labels c\\<^sub>2 l c;\n         c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n         n = Label 0;\n         CEdge (p, es, rets) =\n         IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n         Label (l + #:c\\<^sub>1) = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto dest:Proc_CFG_targetlabel_less_num_nodes Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> #:c\\<^sub>1;\n        Label (l + #:c\\<^sub>1) = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n') auto"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> nx -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (8 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + #:c\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 6. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 7. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 8. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from IH[OF this]"], ["proof (chain)\npicking this:\n  fst_cmd c = Skip", "show ?case"], ["proof (prove)\nusing this:\n  fst_cmd c = Skip\n\ngoal (1 subgoal):\n 1. fst_cmd c = Skip", "by simp"], ["proof (state)\nthis:\n  fst_cmd c = Skip\n\ngoal (7 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 6. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 7. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 6. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 7. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "case (Labels_CondTrue c\\<^sub>1 l c b c\\<^sub>2)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c\n  c\\<^sub>1 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -CEdge\n                                  (p, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label (l + 1)\n\ngoal (7 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 6. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 7. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "note IH = \\<open>\\<And>n. c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow> fst_cmd c = Skip\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n\ngoal (7 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 6. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 7. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<close> \\<open>labels c\\<^sub>1 l c\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -CEdge\n                                  (p, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label (l + 1)\n  labels c\\<^sub>1 l c", "obtain nx where \"c\\<^sub>1 \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -CEdge\n                                  (p, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label (l + 1)\n  labels c\\<^sub>1 l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> nx -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label\n                           l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -CEdge\n      (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label (l + 1);\n     labels c\\<^sub>1 l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; n = n \\<oplus> Suc 0;\n        Label (Suc l) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; n = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc l) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; n = n \\<oplus> Suc 0;\n        Label (Suc l) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; n = n \\<oplus> Suc 0;\n        Label (Suc l) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; n = n \\<oplus> Suc 0;\n        Label (Suc l) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; n = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc l) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; n = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc l) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n')(auto dest:label_less_num_inner_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> nx -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (7 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 5. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 6. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 7. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from IH[OF this]"], ["proof (chain)\npicking this:\n  fst_cmd c = Skip", "show ?case"], ["proof (prove)\nusing this:\n  fst_cmd c = Skip\n\ngoal (1 subgoal):\n 1. fst_cmd c = Skip", "by simp"], ["proof (state)\nthis:\n  fst_cmd c = Skip\n\ngoal (6 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 5. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 6. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 5. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 6. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "case (Labels_CondFalse c\\<^sub>2 l c b c\\<^sub>1)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l c\n  c\\<^sub>2 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -CEdge\n                                  (p, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label\n                         (l + #:c\\<^sub>1 + 1)\n\ngoal (6 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 5. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 6. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "note IH = \\<open>\\<And>n. c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow> fst_cmd c = Skip\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> ?n -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p Label\n                     l \\<Longrightarrow>\n  fst_cmd c = Skip\n\ngoal (6 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 5. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 6. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<close> \n    \\<open>labels c\\<^sub>2 l c\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -CEdge\n                                  (p, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label\n                         (l + #:c\\<^sub>1 + 1)\n  labels c\\<^sub>2 l c", "obtain nx where \"c\\<^sub>2 \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -CEdge\n                                  (p, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label\n                         (l + #:c\\<^sub>1 + 1)\n  labels c\\<^sub>2 l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> nx -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label\n                           l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -CEdge\n      (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1);\n     labels c\\<^sub>2 l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> Suc 0;\n        Label (Suc (l + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc (l + #:c\\<^sub>1)) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> Suc 0;\n        Label (Suc (l + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> Suc 0;\n        Label (Suc (l + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> Suc 0;\n        Label (Suc (l + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc (l + #:c\\<^sub>1)) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; n = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc (l + #:c\\<^sub>1)) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n') auto"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> nx -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (6 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + #:c\\<^sub>1 + 1)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd c = Skip\n 4. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 5. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 6. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from IH[OF this]"], ["proof (chain)\npicking this:\n  fst_cmd c = Skip", "show ?case"], ["proof (prove)\nusing this:\n  fst_cmd c = Skip\n\ngoal (1 subgoal):\n 1. fst_cmd c = Skip", "by simp"], ["proof (state)\nthis:\n  fst_cmd c = Skip\n\ngoal (5 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 4. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 5. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 4. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 5. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "case (Labels_WhileBody c' l c b)"], ["proof (state)\nthis:\n  labels c' l c\n  c' \\<turnstile> ?n -CEdge\n                       (p, es,\n                        rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n  fst_cmd c = Skip\n  while (b) c' \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label (l + 2)\n\ngoal (5 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 4. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 5. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "note IH = \\<open>\\<And>n. c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow> fst_cmd c = Skip\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> ?n -CEdge\n                       (p, es,\n                        rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n  fst_cmd c = Skip\n\ngoal (5 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 4. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 5. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from \\<open>while (b) c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<close> \\<open>labels c' l c\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label (l + 2)\n  labels c' l c", "obtain nx where \"c' \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p Label (l + 2)\n  labels c' l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> nx -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label\n                          (l + 2);\n     labels c' l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n                   thesis;\n        labels c' l c; n = n \\<oplus> 2;\n        Label (Suc (Suc l)) = n' \\<oplus> 2;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n') auto"], ["proof (state)\nthis:\n  c' \\<turnstile> nx -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (5 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>c' l c b n.\n       \\<lbrakk>labels c' l c;\n        \\<And>n.\n           c' \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l \\<Longrightarrow>\n           fst_cmd c = Skip;\n        while (b) c' \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label (l + 2)\\<rbrakk>\n       \\<Longrightarrow> fst_cmd (c;; while (b) c') = Skip\n 4. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 5. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from IH[OF this]"], ["proof (chain)\npicking this:\n  fst_cmd c = Skip", "show ?case"], ["proof (prove)\nusing this:\n  fst_cmd c = Skip\n\ngoal (1 subgoal):\n 1. fst_cmd (c;; while (b) c') = Skip", "by simp"], ["proof (state)\nthis:\n  fst_cmd (c;; while (b) c') = Skip\n\ngoal (4 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 4. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 4. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "case (Labels_Call px esx retsx)"], ["proof (state)\nthis:\n  Call px esx\n   retsx \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label 1\n\ngoal (4 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 4. \\<And>pa esa retsa n.\n       Call pa esa\n        retsa \\<turnstile> n -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "from \\<open>Call px esx retsx \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label 1\\<close>"], ["proof (chain)\npicking this:\n  Call px esx\n   retsx \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label 1", "show ?case"], ["proof (prove)\nusing this:\n  Call px esx\n   retsx \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. fst_cmd Skip = Skip", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  fst_cmd Skip = Skip\n\ngoal (3 subgoals):\n 1. \\<And>c n.\n       c \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n       fst_cmd c = Skip\n 2. \\<And>V e n.\n       V:=e \\<turnstile> n -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p Label\n                    1 \\<Longrightarrow>\n       fst_cmd Skip = Skip\n 3. \\<And>b c' n.\n       while (b) c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p Label 1 \\<Longrightarrow>\n       fst_cmd Skip = Skip", "qed(auto dest:Proc_CFG_Call_Labels)"], ["", "lemma Proc_CFG_Call_source_fst_cmd_Call:\n  \"\\<lbrakk>labels prog l c; prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk> \n  \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>labels prog l c;\n     prog \\<turnstile> Label\n                        l -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets", "proof(induct arbitrary:n' rule:labels.induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>c n'.\n       c \\<turnstile> Label\n                       0 -CEdge\n                           (p, es,\n                            rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>V e n'.\n       V:=e \\<turnstile> Label\n                          1 -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 3. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 4. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 6. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 7. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 8. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 9. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_Base c n')"], ["proof (state)\nthis:\n  c \\<turnstile> Label 0 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (9 subgoals):\n 1. \\<And>c n'.\n       c \\<turnstile> Label\n                       0 -CEdge\n                           (p, es,\n                            rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>V e n'.\n       V:=e \\<turnstile> Label\n                          1 -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 3. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 4. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 6. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 7. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 8. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 9. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>c \\<turnstile> Label 0 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label 0 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  c \\<turnstile> Label 0 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd c = Call p es rets", "by(induct c \"Label 0\" \"CEdge (p, es, rets)\" n' rule:Proc_CFG.induct) auto"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (8 subgoals):\n 1. \\<And>V e n'.\n       V:=e \\<turnstile> Label\n                          1 -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 6. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 7. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 8. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>V e n'.\n       V:=e \\<turnstile> Label\n                          1 -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 6. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 7. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 8. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_LAss V e n')"], ["proof (state)\nthis:\n  V:=e \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (8 subgoals):\n 1. \\<And>V e n'.\n       V:=e \\<turnstile> Label\n                          1 -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 3. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 6. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 7. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 8. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>V:=e \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  V:=e \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd Skip = Call p es rets", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd Skip = Call p es rets\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 2. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 6. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 7. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 2. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 6. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 7. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_Seq1 c\\<^sub>1 l c c\\<^sub>2)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c\n  c\\<^sub>1 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 2. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 6. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 7. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "note IH = \\<open>\\<And>n'. c\\<^sub>1 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \n    \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 2. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 6. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 7. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>c\\<^sub>1;; c\\<^sub>2 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>labels c\\<^sub>1 l c\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>1 l c", "have \"c\\<^sub>1 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>1 l c\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> Label\n                            l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> Label\n                                     l -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     labels c\\<^sub>1 l c\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> Label\n        l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "apply(erule Proc_CFG.cases,auto dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>labels c\\<^sub>1 l c; Label l = n \\<oplus> #:c\\<^sub>1;\n        n' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(case_tac n)(auto dest:label_less_num_inner_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label\n                          l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 l c c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; c\\<^sub>2) = Call p es rets\n 2. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 5. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 6. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 7. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd (c;; c\\<^sub>2) = Call p es rets", "by simp"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd (c;; c\\<^sub>2) = Call p es rets\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 5. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 6. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 5. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 6. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_Seq2 c\\<^sub>2 l c c\\<^sub>1)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l c\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          (l +\n                           #:c\\<^sub>1) -CEdge\n    (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 5. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 6. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "note IH = \\<open>\\<And>n'. c\\<^sub>2 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n    \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 5. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 6. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>c\\<^sub>1;; c\\<^sub>2 \\<turnstile> Label (l + #:c\\<^sub>1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>labels c\\<^sub>2 l c\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          (l +\n                           #:c\\<^sub>1) -CEdge\n    (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>2 l c", "obtain nx where \"c\\<^sub>2 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          (l +\n                           #:c\\<^sub>1) -CEdge\n    (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>2 l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> Label\n  l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label\n                             (l +\n                              #:c\\<^sub>1) -CEdge\n       (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     labels c\\<^sub>2 l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = prog;\n        Label (l + #:c\\<^sub>1) = Entry;\n        CEdge (p, es, rets) = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = prog;\n        Label (l + #:c\\<^sub>1) = Entry;\n        CEdge (p, es, rets) = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> Label\n  l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = Skip;\n     Label (l + #:c\\<^sub>1) = Label 0; CEdge (p, es, rets) = IEdge \\<Up>id;\n     n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = V:=e;\n        Label (l + #:c\\<^sub>1) = Label 0;\n        CEdge (p, es, rets) = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c; c\\<^sub>1;; c\\<^sub>2 = V:=e;\n        Label (l + #:c\\<^sub>1) = Label 1;\n        CEdge (p, es, rets) = IEdge \\<Up>id; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        Label (l + #:c\\<^sub>1) = n; CEdge (p, es, rets) = et; n' = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        Label (l + #:c\\<^sub>1) = n; CEdge (p, es, rets) = et;\n        n' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        Label (l + #:c\\<^sub>1) = n \\<oplus> #:c\\<^sub>1';\n        CEdge (p, es, rets) = et; n' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n        Label (l + #:c\\<^sub>1) = Label 0;\n        CEdge (p, es, rets) =\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> Label\n      l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                    thesis;\n         labels c\\<^sub>2 l c;\n         c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n         Label (l + #:c\\<^sub>1) = Label 0;\n         CEdge (p, es, rets) =\n         IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n         n' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (l + #:c\\<^sub>1) = n \\<oplus> #:c\\<^sub>1;\n        n' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n) auto"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 l c c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                (l +\n                                 #:c\\<^sub>1) -CEdge\n          (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 4. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 5. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 6. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd c = Call p es rets", "by simp"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 4. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 5. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 4. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 5. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_CondTrue c\\<^sub>1 l c b c\\<^sub>2)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c\n  c\\<^sub>1 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               (l +\n                                1) -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 4. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 5. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "note IH = \\<open>\\<And>n'. c\\<^sub>1 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \n    \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 4. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 5. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> Label (l + 1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>labels c\\<^sub>1 l c\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               (l +\n                                1) -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>1 l c", "obtain nx where \"c\\<^sub>1 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               (l +\n                                1) -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>1 l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> Label\n  l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> Label\n                                  (l +\n                                   1) -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     labels c\\<^sub>1 l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; Label (Suc l) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; Label (Suc l) = n \\<oplus> Suc #:c\\<^sub>1;\n        n' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; Label (Suc l) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; Label (Suc l) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; Label (Suc l) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; Label (Suc l) = n \\<oplus> Suc #:c\\<^sub>1;\n        n' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>1 l c; Label (Suc l) = n \\<oplus> Suc #:c\\<^sub>1;\n        n' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n)(auto dest:label_less_num_inner_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label\n                          l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 l c b c\\<^sub>2 n'.\n       \\<lbrakk>labels c\\<^sub>1 l c;\n        \\<And>n'.\n           c\\<^sub>1 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 3. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 4. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 5. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd c = Call p es rets", "by simp"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 3. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 4. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 3. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 4. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_CondFalse c\\<^sub>2 l c b c\\<^sub>1)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l c\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               (l + #:c\\<^sub>1 +\n                                1) -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 3. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 4. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "note IH = \\<open>\\<And>n'. c\\<^sub>2 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \n    \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge\n                              (p, es,\n                               rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 3. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 4. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> Label  (l + #:c\\<^sub>1 + 1)-CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \n    \\<open>labels c\\<^sub>2 l c\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               (l + #:c\\<^sub>1 +\n                                1) -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>2 l c", "obtain nx where \"c\\<^sub>2 \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               (l + #:c\\<^sub>1 +\n                                1) -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c\\<^sub>2 l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> Label\n                                l -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> Label\n  l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> Label\n                                  (l + #:c\\<^sub>1 +\n                                   1) -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     labels c\\<^sub>2 l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (Suc (l + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (Suc (l + #:c\\<^sub>1)) = n \\<oplus> Suc #:c\\<^sub>1;\n        n' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (Suc (l + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (Suc (l + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (Suc (l + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (Suc (l + #:c\\<^sub>1)) = n \\<oplus> Suc #:c\\<^sub>1;\n        n' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c\\<^sub>2 l c;\n        Label (Suc (l + #:c\\<^sub>1)) = n \\<oplus> Suc #:c\\<^sub>1;\n        n' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n) auto"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> Label\n                          l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 l c b c\\<^sub>1 n'.\n       \\<lbrakk>labels c\\<^sub>2 l c;\n        \\<And>n'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     (l + #:c\\<^sub>1 +\n1) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\n 2. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 3. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 4. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd c = Call p es rets", "by simp"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (3 subgoals):\n 1. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 2. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 3. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 2. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 3. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_WhileBody c' l c b)"], ["proof (state)\nthis:\n  labels c' l c\n  c' \\<turnstile> Label\n                   l -CEdge\n                       (p, es,\n                        rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n  while (b) c' \\<turnstile> Label\n                             (l +\n                              2) -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (3 subgoals):\n 1. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 2. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 3. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "note IH = \\<open>\\<And>n'. c' \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n' \n    \\<Longrightarrow> \\<exists>p es rets. fst_cmd c = Call p es rets\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> Label\n                   l -CEdge\n                       (p, es,\n                        rets)\\<rightarrow>\\<^sub>p ?n' \\<Longrightarrow>\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (3 subgoals):\n 1. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 2. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 3. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>while (b) c' \\<turnstile> Label (l + 2) -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>labels c' l c\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> Label\n                             (l +\n                              2) -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c' l c", "obtain nx where \"c' \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> Label\n                             (l +\n                              2) -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  labels c' l c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> Label\n                         l -CEdge\n                             (p, es,\n                              rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> Label\n                                 l -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> Label\n                                (l +\n                                 2) -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n     labels c' l c\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    l -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        labels c' l c; Label (Suc (Suc l)) = n \\<oplus> 2;\n        n' = n' \\<oplus> 2;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n) auto"], ["proof (state)\nthis:\n  c' \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p nx\n\ngoal (3 subgoals):\n 1. \\<And>c' l c b n'.\n       \\<lbrakk>labels c' l c;\n        \\<And>n'.\n           c' \\<turnstile> Label\n                            l -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           \\<exists>p es rets. fst_cmd c = Call p es rets;\n        while (b) c' \\<turnstile> Label\n                                   (l +\n                                    2) -CEdge\n   (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p es rets.\n                            fst_cmd (c;; while (b) c') = Call p es rets\n 2. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 3. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>p es rets. fst_cmd c = Call p es rets\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd (c;; while (b) c') = Call p es rets", "by simp"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd (c;; while (b) c') = Call p es rets\n\ngoal (2 subgoals):\n 1. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_WhileExit b c' n')"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> Label\n                             1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (2 subgoals):\n 1. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "have \"while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while (b) c' \\<turnstile> Label\n                               1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit", "by(rule Proc_CFG_WhileFalseSkip)"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (2 subgoals):\n 1. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "with \\<open>while (b) c' \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> Label\n                             1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit", "have False"], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> Label\n                             1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Proc_CFG_Call_Intra_edge_not_same_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>b c' n'.\n       while (b) c' \\<turnstile> Label\n                                  1 -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets\n 2. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd Skip = Call p es rets", "by simp"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd Skip = Call p es rets\n\ngoal (1 subgoal):\n 1. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "case (Labels_Call px esx retsx)"], ["proof (state)\nthis:\n  Call px esx\n   retsx \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. \\<And>pa esa retsa n'.\n       Call pa esa\n        retsa \\<turnstile> Label\n                            1 -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n       \\<exists>p es rets. fst_cmd Skip = Call p es rets", "from \\<open>Call px esx retsx \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  Call px esx\n   retsx \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  Call px esx\n   retsx \\<turnstile> Label 1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd Skip = Call p es rets", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd Skip = Call p es rets\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition of \\<open>Def\\<close> and \\<open>Use\\<close> sets\\<close>"], ["", "subsubsection \\<open>\\<open>ParamDefs\\<close>\\<close>"], ["", "lemma PCFG_CallEdge_THE_rets:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\n\\<Longrightarrow> (THE rets'. \\<exists>p' es' n. prog \\<turnstile> n -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n') = rets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    (THE rets'.\n        \\<exists>p' es' n.\n           prog \\<turnstile> n -CEdge\n                                 (p', es', rets')\\<rightarrow>\\<^sub>p n') =\n    rets", "by(fastforce intro:the_equality dest:Proc_CFG_Call_nodes_eq')"], ["", "definition ParamDefs_proc :: \"cmd \\<Rightarrow> label \\<Rightarrow> vname list\"\n  where \"ParamDefs_proc c n \\<equiv> \n  if (\\<exists>n' p' es' rets'. c \\<turnstile> n' -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n) then \n     (THE rets'. \\<exists>p' es' n'. c \\<turnstile> n' -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n)\n  else []\""], ["", "lemma in_procs_THE_in_procs_cmd:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_formed procs; (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> (THE c'.\n                          \\<exists>ins' outs'.\n                             (p, ins', outs', c') \\<in> set procs) =\n                      c", "by(fastforce intro:the_equality)"], ["", "definition ParamDefs :: \"wf_prog \\<Rightarrow> node \\<Rightarrow> vname list\"\n  where \"ParamDefs wfp n \\<equiv> let (prog,procs) = Rep_wf_prog wfp; (p,l) = n in\n  (if (p = Main) then ParamDefs_proc prog l\n   else (if (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs)\n         then ParamDefs_proc (THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) l\n         else []))\""], ["", "lemma ParamDefs_Main_Return_target:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> ParamDefs wfp (Main,n') = rets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n     prog \\<turnstile> n -CEdge\n                           (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> ParamDefs wfp (Main, n') = rets", "by(fastforce dest:PCFG_CallEdge_THE_rets simp:ParamDefs_def ParamDefs_proc_def)"], ["", "lemma ParamDefs_Proc_Return_target:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamDefs wfp (p,n') = rets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "with \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have \"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "from \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have \"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets", "by(fastforce dest:PCFG_CallEdge_THE_rets simp:ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  ParamDefs wfp (p, n') = rets\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ParamDefs_Main_IEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> ParamDefs wfp (Main,n') = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n     prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> ParamDefs wfp (Main, n') = []", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_target \n            simp:ParamDefs_def ParamDefs_proc_def)"], ["", "lemma ParamDefs_Proc_IEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamDefs wfp (p,n') = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "with \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have \"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "from \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have \"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_target \n                simp:ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  ParamDefs wfp (p, n') = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ParamDefs_Main_CEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n  \\<Longrightarrow> ParamDefs wfp (Main,n') = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n     prog \\<turnstile> n' -CEdge\n                            (p', es, rets)\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n    \\<Longrightarrow> ParamDefs wfp (Main, n') = []", "by(fastforce dest:Proc_CFG_Call_targetnode_no_Call_sourcenode\n            simp:ParamDefs_def ParamDefs_proc_def)"], ["", "lemma ParamDefs_Proc_CEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n''\"\n  shows \"ParamDefs wfp (p,n') = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "with \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have \"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "from \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have \"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "by(fastforce dest:Proc_CFG_Call_targetnode_no_Call_sourcenode\n                simp:ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  ParamDefs wfp (p, n') = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n  and \"(p, ins, outs) \\<in> set (lift_procs wfp)\"\n  shows ParamDefs_length:\"length (ParamDefs wfp (targetnode a)) = length outs\"\n  (is ?length)\n  and Return_update:\"f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\"\n  (is ?update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ParamDefs wfp (targetnode a)) = length outs &&&\n    f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. length (ParamDefs wfp (targetnode a)) = length outs\n 2. f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "from Rep_wf_prog[of wfp]"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp \\<in> wf_prog", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp \\<in> wf_prog\n\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:wf_prog_def)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (2 subgoals):\n 1. length (ParamDefs wfp (targetnode a)) = length outs\n 2. f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "hence \"wf prog procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. WellFormProgs.wf prog procs", "by(rule wf_wf_prog)"], ["proof (state)\nthis:\n  WellFormProgs.wf prog procs\n\ngoal (2 subgoals):\n 1. length (ParamDefs wfp (targetnode a)) = length outs\n 2. f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "hence wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n\ngoal (1 subgoal):\n 1. well_formed procs", "by fastforce"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (2 subgoals):\n 1. length (ParamDefs wfp (targetnode a)) = length outs\n 2. f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "from assms"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set (lift_procs wfp)", "have \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (2 subgoals):\n 1. length (ParamDefs wfp (targetnode a)) = length outs\n 2. f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "from this \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> wf"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  well_formed procs", "have \"?length \\<and> ?update\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  well_formed procs\n\ngoal (1 subgoal):\n 1. length (ParamDefs wfp (targetnode a)) = length outs \\<and>\n    f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>l pa es rets l' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 8. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "case (MainReturn l p' es rets l' insx outsx cx)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', insx, outsx, cx) \\<in> set procs\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outsx) =\n  kind a\n  (Main, Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>l pa es rets l' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 8. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "from \\<open>\\<lambda>cf. snd cf = (Main, Label l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outsx) =\n      kind a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outsx) =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"p' = p\" \n      and f':\"f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outsx))\""], ["proof (prove)\nusing this:\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outsx) =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. p' = p &&& f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outsx))", "by simp_all"], ["proof (state)\nthis:\n  p' = p\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outsx))\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>l pa es rets l' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 8. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "with \\<open>well_formed procs\\<close> \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close>\n      \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p', insx, outsx, cx) \\<in> set procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  p' = p\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outsx))", "have [simp]:\"outsx = outs\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p', insx, outsx, cx) \\<in> set procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  p' = p\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outsx))\n\ngoal (1 subgoal):\n 1. outsx = outs", "by fastforce"], ["proof (state)\nthis:\n  outsx = outs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>l pa es rets l' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 8. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs prog [] p'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] p'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>l pa es rets l' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 8. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "with \\<open>wf prog procs\\<close> \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close> \n      \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', insx, outsx, cx) \\<in> set procs\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog [] p'", "have \"length rets = length outs\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', insx, outsx, cx) \\<in> set procs\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog [] p'\n\ngoal (1 subgoal):\n 1. length rets = length outs", "by fastforce"], ["proof (state)\nthis:\n  length rets = length outs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>l pa es rets l' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 8. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"ParamDefs wfp (Main,Label l') = rets\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (Main, Label l') = rets", "by(fastforce intro:ParamDefs_Main_Return_target)"], ["proof (state)\nthis:\n  ParamDefs wfp (Main, Label l') = rets\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>l pa es rets l' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 8. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "with \\<open>(Main, Label l') = targetnode a\\<close> f' \\<open>length rets = length outs\\<close>"], ["proof (chain)\npicking this:\n  (Main, Label l') = targetnode a\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outsx))\n  length rets = length outs\n  ParamDefs wfp (Main, Label l') = rets", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, Label l') = targetnode a\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outsx))\n  length rets = length outs\n  ParamDefs wfp (Main, Label l') = rets\n\ngoal (1 subgoal):\n 1. length (ParamDefs wfp (targetnode a)) = length outs \\<and>\n    f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "by simp"], ["proof (state)\nthis:\n  length (ParamDefs wfp (targetnode a)) = length outs \\<and>\n  f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "case (ProcReturn px insx outsx cx l p' es rets l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs') =\n  kind a\n  (px, Label l') = targetnode a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "from \\<open>\\<lambda>cf. snd cf = (px, Label l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outs') =\n      kind a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs') =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"p' = p\" and f':\"f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outs'))\""], ["proof (prove)\nusing this:\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outs') =\n  kind a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. p' = p &&& f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outs'))", "by simp_all"], ["proof (state)\nthis:\n  p' = p\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outs'))\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "with \\<open>well_formed procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  p' = p\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outs'))", "have [simp]:\"outs' = outs\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  p' = p\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outs'))\n\ngoal (1 subgoal):\n 1. outs' = outs", "by fastforce"], ["proof (state)\nthis:\n  outs' = outs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "from \\<open>cx \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs cx [] p'\""], ["proof (prove)\nusing this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs cx [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs cx [] p'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "with \\<open>containsCall procs prog ps px\\<close> \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p'", "have \"containsCall procs prog (ps@[px]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [px]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "with \\<open>wf prog procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n      \\<open>cx \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'", "have \"length rets = length outs\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. length rets = length outs", "by fastforce"], ["proof (state)\nthis:\n  length rets = length outs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "from \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close>\n      \\<open>cx \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"ParamDefs wfp (px,Label l') = rets\""], ["proof (prove)\nusing this:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (px, Label l') = rets", "by(fastforce intro:ParamDefs_Proc_Return_target simp:set_conv_nth)"], ["proof (state)\nthis:\n  ParamDefs wfp (px, Label l') = rets\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 7. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "with \\<open>(px, Label l') = targetnode a\\<close> f' \\<open>length rets = length outs\\<close>"], ["proof (chain)\npicking this:\n  (px, Label l') = targetnode a\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outs'))\n  length rets = length outs\n  ParamDefs wfp (px, Label l') = rets", "show ?thesis"], ["proof (prove)\nusing this:\n  (px, Label l') = targetnode a\n  f' = (\\<lambda>cf cf'. cf'(rets [:=] map cf outs'))\n  length rets = length outs\n  ParamDefs wfp (px, Label l') = rets\n\ngoal (1 subgoal):\n 1. length (ParamDefs wfp (targetnode a)) = length outs \\<and>\n    f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "by simp"], ["proof (state)\nthis:\n  length (ParamDefs wfp (targetnode a)) = length outs \\<and>\n  f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 2. \\<And>pa ins outsa c n n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 3. \\<And>l pa es rets n' ins outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outsa, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 4. \\<And>pa ins outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)\n 6. \\<And>pa ins outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) =\n                         length outs \\<and>\n                         f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=]\n                         map cf outs)", "qed auto"], ["proof (state)\nthis:\n  length (ParamDefs wfp (targetnode a)) = length outs \\<and>\n  f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\n\ngoal (2 subgoals):\n 1. length (ParamDefs wfp (targetnode a)) = length outs\n 2. f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "thus \"?length\" and \"?update\""], ["proof (prove)\nusing this:\n  length (ParamDefs wfp (targetnode a)) = length outs \\<and>\n  f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\n\ngoal (1 subgoal):\n 1. length (ParamDefs wfp (targetnode a)) = length outs &&&\n    f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "by simp_all"], ["proof (state)\nthis:\n  length (ParamDefs wfp (targetnode a)) = length outs\n  f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\\<open>ParamUses\\<close>\\<close>"], ["", "fun fv :: \"expr \\<Rightarrow> vname set\"\nwhere\n  \"fv (Val v)       = {}\"\n  | \"fv (Var V)       = {V}\"\n  | \"fv (e1 \\<guillemotleft>bop\\<guillemotright> e2) = (fv e1 \\<union> fv e2)\""], ["", "lemma rhs_interpret_eq: \n  \"\\<lbrakk>state_check cf e v'; \\<forall>V \\<in> fv e. cf V = cf' V\\<rbrakk> \n   \\<Longrightarrow> state_check cf' e v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>state_check cf e v'; \\<forall>V\\<in>fv e. cf V = cf' V\\<rbrakk>\n    \\<Longrightarrow> state_check cf' e v'", "proof(induct e arbitrary:v')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x v'.\n       \\<lbrakk>state_check cf (Val x) v';\n        \\<forall>V\\<in>fv (Val x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Val x) v'\n 2. \\<And>x v'.\n       \\<lbrakk>state_check cf (Var x) v';\n        \\<forall>V\\<in>fv (Var x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Var x) v'\n 3. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "case (Val v)"], ["proof (state)\nthis:\n  state_check cf (Val v) v'\n  \\<forall>V\\<in>fv (Val v). cf V = cf' V\n\ngoal (3 subgoals):\n 1. \\<And>x v'.\n       \\<lbrakk>state_check cf (Val x) v';\n        \\<forall>V\\<in>fv (Val x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Val x) v'\n 2. \\<And>x v'.\n       \\<lbrakk>state_check cf (Var x) v';\n        \\<forall>V\\<in>fv (Var x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Var x) v'\n 3. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "from \\<open>state_check cf (Val v) v'\\<close>"], ["proof (chain)\npicking this:\n  state_check cf (Val v) v'", "have \"v' = Some v\""], ["proof (prove)\nusing this:\n  state_check cf (Val v) v'\n\ngoal (1 subgoal):\n 1. v' = Some v", "by(fastforce elim:interpret.cases)"], ["proof (state)\nthis:\n  v' = Some v\n\ngoal (3 subgoals):\n 1. \\<And>x v'.\n       \\<lbrakk>state_check cf (Val x) v';\n        \\<forall>V\\<in>fv (Val x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Val x) v'\n 2. \\<And>x v'.\n       \\<lbrakk>state_check cf (Var x) v';\n        \\<forall>V\\<in>fv (Var x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Var x) v'\n 3. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "thus ?case"], ["proof (prove)\nusing this:\n  v' = Some v\n\ngoal (1 subgoal):\n 1. state_check cf' (Val v) v'", "by simp"], ["proof (state)\nthis:\n  state_check cf' (Val v) v'\n\ngoal (2 subgoals):\n 1. \\<And>x v'.\n       \\<lbrakk>state_check cf (Var x) v';\n        \\<forall>V\\<in>fv (Var x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Var x) v'\n 2. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x v'.\n       \\<lbrakk>state_check cf (Var x) v';\n        \\<forall>V\\<in>fv (Var x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Var x) v'\n 2. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "case (Var V)"], ["proof (state)\nthis:\n  state_check cf (Var V) v'\n  \\<forall>V\\<in>fv (Var V). cf V = cf' V\n\ngoal (2 subgoals):\n 1. \\<And>x v'.\n       \\<lbrakk>state_check cf (Var x) v';\n        \\<forall>V\\<in>fv (Var x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Var x) v'\n 2. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "hence \"cf' (V) = v'\""], ["proof (prove)\nusing this:\n  state_check cf (Var V) v'\n  \\<forall>V\\<in>fv (Var V). cf V = cf' V\n\ngoal (1 subgoal):\n 1. cf' V = v'", "by(fastforce elim:interpret.cases)"], ["proof (state)\nthis:\n  cf' V = v'\n\ngoal (2 subgoals):\n 1. \\<And>x v'.\n       \\<lbrakk>state_check cf (Var x) v';\n        \\<forall>V\\<in>fv (Var x). cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf' (Var x) v'\n 2. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "thus ?case"], ["proof (prove)\nusing this:\n  cf' V = v'\n\ngoal (1 subgoal):\n 1. state_check cf' (Var V) v'", "by simp"], ["proof (state)\nthis:\n  state_check cf' (Var V) v'\n\ngoal (1 subgoal):\n 1. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "case (BinOp b1 bop b2)"], ["proof (state)\nthis:\n  \\<lbrakk>state_check cf b1 ?v';\n   \\<forall>V\\<in>fv b1. cf V = cf' V\\<rbrakk>\n  \\<Longrightarrow> state_check cf' b1 ?v'\n  \\<lbrakk>state_check cf b2 ?v';\n   \\<forall>V\\<in>fv b2. cf V = cf' V\\<rbrakk>\n  \\<Longrightarrow> state_check cf' b2 ?v'\n  state_check cf (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n  \\<forall>V\\<in>fv (b1 \\<guillemotleft>bop\\<guillemotright> b2).\n     cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "note IH1 = \\<open>\\<And>v'. \\<lbrakk>state_check cf b1 v'; \\<forall>V\\<in>fv b1. cf V = cf' V\\<rbrakk>\n    \\<Longrightarrow> state_check cf' b1 v'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>state_check cf b1 ?v';\n   \\<forall>V\\<in>fv b1. cf V = cf' V\\<rbrakk>\n  \\<Longrightarrow> state_check cf' b1 ?v'\n\ngoal (1 subgoal):\n 1. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "note IH2 = \\<open>\\<And>v'. \\<lbrakk>state_check cf b2 v'; \\<forall>V\\<in>fv b2. cf V = cf' V\\<rbrakk>\n    \\<Longrightarrow> state_check cf' b2 v'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>state_check cf b2 ?v';\n   \\<forall>V\\<in>fv b2. cf V = cf' V\\<rbrakk>\n  \\<Longrightarrow> state_check cf' b2 ?v'\n\ngoal (1 subgoal):\n 1. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "from \\<open>\\<forall>V \\<in> fv (b1 \\<guillemotleft>bop\\<guillemotright> b2). cf V = cf' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>fv (b1 \\<guillemotleft>bop\\<guillemotright> b2).\n     cf V = cf' V", "have \"\\<forall>V \\<in> fv b1. cf V = cf' V\"\n    and \"\\<forall>V \\<in> fv b2. cf V = cf' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>fv (b1 \\<guillemotleft>bop\\<guillemotright> b2).\n     cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>fv b1. cf V = cf' V &&&\n    \\<forall>V\\<in>fv b2. cf V = cf' V", "by simp_all"], ["proof (state)\nthis:\n  \\<forall>V\\<in>fv b1. cf V = cf' V\n  \\<forall>V\\<in>fv b2. cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "from \\<open>state_check cf (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\\<close>"], ["proof (chain)\npicking this:\n  state_check cf (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "have \"((state_check cf b1 None \\<and> v' = None) \\<or> \n          (state_check cf b2 None \\<and> v' = None)) \\<or>\n    (\\<exists>v\\<^sub>1 v\\<^sub>2. state_check cf b1 (Some v\\<^sub>1) \\<and> state_check cf b2 (Some v\\<^sub>2) \\<and>\n    binop bop v\\<^sub>1 v\\<^sub>2 = v')\""], ["proof (prove)\nusing this:\n  state_check cf (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n\ngoal (1 subgoal):\n 1. (state_check cf b1 None \\<and> v' = None \\<or>\n     state_check cf b2 None \\<and> v' = None) \\<or>\n    (\\<exists>v\\<^sub>1 v\\<^sub>2.\n        state_check cf b1 (Some v\\<^sub>1) \\<and>\n        state_check cf b2 (Some v\\<^sub>2) \\<and>\n        binop bop v\\<^sub>1 v\\<^sub>2 = v')", "apply(cases \"interpret b1 cf\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>state_check cf (b1 \\<guillemotleft>bop\\<guillemotright> b2)\n                 v';\n        state_check cf b1 (Some a)\\<rbrakk>\n       \\<Longrightarrow> (state_check cf b1 None \\<and> v' = None \\<or>\n                          state_check cf b2 None \\<and> v' = None) \\<or>\n                         (\\<exists>v\\<^sub>1 v\\<^sub>2.\n                             state_check cf b1 (Some v\\<^sub>1) \\<and>\n                             state_check cf b2 (Some v\\<^sub>2) \\<and>\n                             binop bop v\\<^sub>1 v\\<^sub>2 = v')", "apply(cases \"interpret b2 cf\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>state_check cf (b1 \\<guillemotleft>bop\\<guillemotright> b2)\n                 v';\n        state_check cf b1 (Some a); state_check cf b2 (Some aa)\\<rbrakk>\n       \\<Longrightarrow> (state_check cf b1 None \\<and> v' = None \\<or>\n                          state_check cf b2 None \\<and> v' = None) \\<or>\n                         (\\<exists>v\\<^sub>1 v\\<^sub>2.\n                             state_check cf b1 (Some v\\<^sub>1) \\<and>\n                             state_check cf b2 (Some v\\<^sub>2) \\<and>\n                             binop bop v\\<^sub>1 v\\<^sub>2 = v')", "by(case_tac \"binop bop a aa\",simp+)"], ["proof (state)\nthis:\n  (state_check cf b1 None \\<and> v' = None \\<or>\n   state_check cf b2 None \\<and> v' = None) \\<or>\n  (\\<exists>v\\<^sub>1 v\\<^sub>2.\n      state_check cf b1 (Some v\\<^sub>1) \\<and>\n      state_check cf b2 (Some v\\<^sub>2) \\<and>\n      binop bop v\\<^sub>1 v\\<^sub>2 = v')\n\ngoal (1 subgoal):\n 1. \\<And>e1 x2a e2 v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>state_check cf e1 v';\n                    \\<forall>V\\<in>fv e1. cf V = cf' V\\<rbrakk>\n                   \\<Longrightarrow> state_check cf' e1 v';\n        \\<And>v'.\n           \\<lbrakk>state_check cf e2 v';\n            \\<forall>V\\<in>fv e2. cf V = cf' V\\<rbrakk>\n           \\<Longrightarrow> state_check cf' e2 v';\n        state_check cf (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v';\n        \\<forall>V\\<in>fv (e1 \\<guillemotleft>x2a\\<guillemotright> e2).\n           cf V = cf' V\\<rbrakk>\n       \\<Longrightarrow> state_check cf'\n                          (e1 \\<guillemotleft>x2a\\<guillemotright> e2) v'", "thus ?case"], ["proof (prove)\nusing this:\n  (state_check cf b1 None \\<and> v' = None \\<or>\n   state_check cf b2 None \\<and> v' = None) \\<or>\n  (\\<exists>v\\<^sub>1 v\\<^sub>2.\n      state_check cf b1 (Some v\\<^sub>1) \\<and>\n      state_check cf b2 (Some v\\<^sub>2) \\<and>\n      binop bop v\\<^sub>1 v\\<^sub>2 = v')\n\ngoal (1 subgoal):\n 1. state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (state_check cf b1 None \\<and> v' = None \\<or>\n     state_check cf b2 None \\<and> v' = None) \\<or>\n    (\\<exists>v\\<^sub>1 v\\<^sub>2.\n        state_check cf b1 (Some v\\<^sub>1) \\<and>\n        state_check cf b2 (Some v\\<^sub>2) \\<and>\n        binop bop v\\<^sub>1 v\\<^sub>2 = v') \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. state_check cf b1 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 3. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "assume \"state_check cf b1 None \\<and> v' = None\""], ["proof (state)\nthis:\n  state_check cf b1 None \\<and> v' = None\n\ngoal (3 subgoals):\n 1. state_check cf b1 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 3. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "hence check:\"state_check cf b1 None\" and \"v' = None\""], ["proof (prove)\nusing this:\n  state_check cf b1 None \\<and> v' = None\n\ngoal (1 subgoal):\n 1. state_check cf b1 None &&& v' = None", "by simp_all"], ["proof (state)\nthis:\n  state_check cf b1 None\n  v' = None\n\ngoal (3 subgoals):\n 1. state_check cf b1 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 3. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "from IH1[OF check \\<open>\\<forall>V \\<in> fv b1. cf V = cf' V\\<close>]"], ["proof (chain)\npicking this:\n  state_check cf' b1 None", "have \"state_check cf' b1 None\""], ["proof (prove)\nusing this:\n  state_check cf' b1 None\n\ngoal (1 subgoal):\n 1. state_check cf' b1 None", "."], ["proof (state)\nthis:\n  state_check cf' b1 None\n\ngoal (3 subgoals):\n 1. state_check cf b1 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 3. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "with \\<open>v' = None\\<close>"], ["proof (chain)\npicking this:\n  v' = None\n  state_check cf' b1 None", "show ?case"], ["proof (prove)\nusing this:\n  v' = None\n  state_check cf' b1 None\n\ngoal (1 subgoal):\n 1. state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "by simp"], ["proof (state)\nthis:\n  state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n\ngoal (2 subgoals):\n 1. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "assume \"state_check cf b2 None \\<and> v' = None\""], ["proof (state)\nthis:\n  state_check cf b2 None \\<and> v' = None\n\ngoal (2 subgoals):\n 1. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "hence check:\"state_check cf b2 None\" and \"v' = None\""], ["proof (prove)\nusing this:\n  state_check cf b2 None \\<and> v' = None\n\ngoal (1 subgoal):\n 1. state_check cf b2 None &&& v' = None", "by simp_all"], ["proof (state)\nthis:\n  state_check cf b2 None\n  v' = None\n\ngoal (2 subgoals):\n 1. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "from IH2[OF check \\<open>\\<forall>V \\<in> fv b2. cf V = cf' V\\<close>]"], ["proof (chain)\npicking this:\n  state_check cf' b2 None", "have \"state_check cf' b2 None\""], ["proof (prove)\nusing this:\n  state_check cf' b2 None\n\ngoal (1 subgoal):\n 1. state_check cf' b2 None", "."], ["proof (state)\nthis:\n  state_check cf' b2 None\n\ngoal (2 subgoals):\n 1. state_check cf b2 None \\<and> v' = None \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n 2. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "with \\<open>v' = None\\<close>"], ["proof (chain)\npicking this:\n  v' = None\n  state_check cf' b2 None", "show ?case"], ["proof (prove)\nusing this:\n  v' = None\n  state_check cf' b2 None\n\ngoal (1 subgoal):\n 1. state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "by(cases \"interpret b1 cf'\") simp+"], ["proof (state)\nthis:\n  state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "assume \"\\<exists>v\\<^sub>1 v\\<^sub>2. state_check cf b1 (Some v\\<^sub>1) \\<and>\n      state_check cf b2 (Some v\\<^sub>2) \\<and> binop bop v\\<^sub>1 v\\<^sub>2 = v'\""], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1 v\\<^sub>2.\n     state_check cf b1 (Some v\\<^sub>1) \\<and>\n     state_check cf b2 (Some v\\<^sub>2) \\<and>\n     binop bop v\\<^sub>1 v\\<^sub>2 = v'\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<^sub>1 v\\<^sub>2.\n     state_check cf b1 (Some v\\<^sub>1) \\<and>\n     state_check cf b2 (Some v\\<^sub>2) \\<and>\n     binop bop v\\<^sub>1 v\\<^sub>2 = v'", "obtain v\\<^sub>1 v\\<^sub>2 where \"state_check cf b1 (Some v\\<^sub>1)\"\n      and \"state_check cf b2 (Some v\\<^sub>2)\" and \"binop bop v\\<^sub>1 v\\<^sub>2 = v'\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<^sub>1 v\\<^sub>2.\n     state_check cf b1 (Some v\\<^sub>1) \\<and>\n     state_check cf b2 (Some v\\<^sub>2) \\<and>\n     binop bop v\\<^sub>1 v\\<^sub>2 = v'\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1 v\\<^sub>2.\n        \\<lbrakk>state_check cf b1 (Some v\\<^sub>1);\n         state_check cf b2 (Some v\\<^sub>2);\n         binop bop v\\<^sub>1 v\\<^sub>2 = v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  state_check cf b1 (Some v\\<^sub>1)\n  state_check cf b2 (Some v\\<^sub>2)\n  binop bop v\\<^sub>1 v\\<^sub>2 = v'\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "from \\<open>\\<forall>V \\<in> fv (b1 \\<guillemotleft>bop\\<guillemotright> b2). cf V = cf' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>fv (b1 \\<guillemotleft>bop\\<guillemotright> b2).\n     cf V = cf' V", "have \"\\<forall>V \\<in> fv b1. cf V = cf' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>fv (b1 \\<guillemotleft>bop\\<guillemotright> b2).\n     cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>fv b1. cf V = cf' V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>fv b1. cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "from IH1[OF \\<open>state_check cf b1 (Some v\\<^sub>1)\\<close> this]"], ["proof (chain)\npicking this:\n  state_check cf' b1 (Some v\\<^sub>1)", "have \"interpret b1 cf' = Some v\\<^sub>1\""], ["proof (prove)\nusing this:\n  state_check cf' b1 (Some v\\<^sub>1)\n\ngoal (1 subgoal):\n 1. state_check cf' b1 (Some v\\<^sub>1)", "."], ["proof (state)\nthis:\n  state_check cf' b1 (Some v\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "from \\<open>\\<forall>V \\<in> fv (b1 \\<guillemotleft>bop\\<guillemotright> b2). cf V = cf' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>fv (b1 \\<guillemotleft>bop\\<guillemotright> b2).\n     cf V = cf' V", "have \"\\<forall>V \\<in> fv b2. cf V = cf' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>fv (b1 \\<guillemotleft>bop\\<guillemotright> b2).\n     cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>fv b2. cf V = cf' V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>fv b2. cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "from IH2[OF \\<open>state_check cf b2 (Some v\\<^sub>2)\\<close> this]"], ["proof (chain)\npicking this:\n  state_check cf' b2 (Some v\\<^sub>2)", "have \"interpret b2 cf' = Some v\\<^sub>2\""], ["proof (prove)\nusing this:\n  state_check cf' b2 (Some v\\<^sub>2)\n\ngoal (1 subgoal):\n 1. state_check cf' b2 (Some v\\<^sub>2)", "."], ["proof (state)\nthis:\n  state_check cf' b2 (Some v\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 v\\<^sub>2.\n       state_check cf b1 (Some v\\<^sub>1) \\<and>\n       state_check cf b2 (Some v\\<^sub>2) \\<and>\n       binop bop v\\<^sub>1 v\\<^sub>2 = v' \\<Longrightarrow>\n    state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "with \\<open>interpret b1 cf' = Some v\\<^sub>1\\<close> \\<open>binop bop v\\<^sub>1 v\\<^sub>2 = v'\\<close>"], ["proof (chain)\npicking this:\n  state_check cf' b1 (Some v\\<^sub>1)\n  binop bop v\\<^sub>1 v\\<^sub>2 = v'\n  state_check cf' b2 (Some v\\<^sub>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  state_check cf' b1 (Some v\\<^sub>1)\n  binop bop v\\<^sub>1 v\\<^sub>2 = v'\n  state_check cf' b2 (Some v\\<^sub>2)\n\ngoal (1 subgoal):\n 1. state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'", "by(cases v') simp+"], ["proof (state)\nthis:\n  state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_check cf' (b1 \\<guillemotleft>bop\\<guillemotright> b2) v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PCFG_CallEdge_THE_es:\n  \"prog \\<turnstile> n -CEdge(p,es,rets)\\<rightarrow>\\<^sub>p n'\n\\<Longrightarrow> (THE es'. \\<exists>p' rets' n'. prog \\<turnstile> n -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n') = es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    (THE es'.\n        \\<exists>p' rets' n'.\n           prog \\<turnstile> n -CEdge\n                                 (p', es', rets')\\<rightarrow>\\<^sub>p n') =\n    es", "by(fastforce intro:the_equality dest:Proc_CFG_Call_nodes_eq)"], ["", "definition ParamUses_proc :: \"cmd \\<Rightarrow> label \\<Rightarrow> vname set list\"\n  where \"ParamUses_proc c n \\<equiv>\n  if (\\<exists>n' p' es' rets'. c \\<turnstile> n -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n') then \n  (map fv (THE es'. \\<exists>p' rets' n'. c \\<turnstile> n -CEdge(p',es',rets')\\<rightarrow>\\<^sub>p n'))\n  else []\""], ["", "definition ParamUses :: \"wf_prog \\<Rightarrow> node \\<Rightarrow> vname set list\"\n  where \"ParamUses wfp n \\<equiv> let (prog,procs) = Rep_wf_prog wfp; (p,l) = n in\n  (if (p = Main) then ParamUses_proc prog l\n   else (if (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs)\n         then ParamUses_proc (THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) l\n         else []))\""], ["", "lemma ParamUses_Main_Return_target:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n' \\<rbrakk>\n  \\<Longrightarrow> ParamUses wfp (Main,n) = map fv es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n     prog \\<turnstile> n -CEdge\n                           (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> ParamUses wfp (Main, n) = map fv es", "by(fastforce dest:PCFG_CallEdge_THE_es simp:ParamUses_def ParamUses_proc_def)"], ["", "lemma ParamUses_Proc_Return_target:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamUses wfp (p,n) = map fv es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "with \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have \"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "from \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have \"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = map fv es", "by(fastforce dest:PCFG_CallEdge_THE_es simp:ParamUses_def ParamUses_proc_def)"], ["proof (state)\nthis:\n  ParamUses wfp (p, n) = map fv es\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ParamUses_Main_IEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> ParamUses wfp (Main,n) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n     prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> ParamUses wfp (Main, n) = []", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_source\n            simp:ParamUses_def ParamUses_proc_def)"], ["", "lemma ParamUses_Proc_IEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\"\n  shows \"ParamUses wfp (p,n) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "with \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have \"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "from \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have \"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_source\n                simp:ParamUses_def ParamUses_proc_def)"], ["proof (state)\nthis:\n  ParamUses wfp (p, n) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ParamUses_Main_CEdge_Nil:\n  \"\\<lbrakk>Rep_wf_prog wfp = (prog,procs); prog \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n\\<rbrakk>\n  \\<Longrightarrow> ParamUses wfp (Main,n) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rep_wf_prog wfp = (prog, procs);\n     prog \\<turnstile> n' -CEdge\n                            (p', es, rets)\\<rightarrow>\\<^sub>p n\\<rbrakk>\n    \\<Longrightarrow> ParamUses wfp (Main, n) = []", "by(fastforce dest:Proc_CFG_Call_targetnode_no_Call_sourcenode\n            simp:ParamUses_def ParamUses_proc_def)"], ["", "lemma ParamUses_Proc_CEdge_Nil:\n  assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c \\<turnstile> n' -CEdge(p',es,rets)\\<rightarrow>\\<^sub>p n\"\n  shows \"ParamUses wfp (p,n) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)", "have \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "with \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have \"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "from \\<open>well_formed procs\\<close> \n    \\<open>(p,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have \"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> Main\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "by(fastforce dest:Proc_CFG_Call_targetnode_no_Call_sourcenode\n                simp:ParamUses_def ParamUses_proc_def)"], ["proof (state)\nthis:\n  ParamUses wfp (p, n) = []\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\\<open>Def\\<close>\\<close>"], ["", "fun lhs :: \"cmd \\<Rightarrow> vname set\"\nwhere\n  \"lhs Skip                = {}\"\n  | \"lhs (V:=e)              = {V}\"\n  | \"lhs (c\\<^sub>1;;c\\<^sub>2)            = lhs c\\<^sub>1\"\n  | \"lhs (if (b) c\\<^sub>1 else c\\<^sub>2) = {}\"\n  | \"lhs (while (b) c)       = {}\"\n  | \"lhs (Call p es rets)    = {}\""], ["", "lemma lhs_fst_cmd:\"lhs (fst_cmd c) = lhs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs (fst_cmd c) = lhs c", "by(induct c) auto"], ["", "lemma Proc_CFG_Call_source_empty_lhs:\n  assumes \"prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows \"lhs (label prog l) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "from \\<open>prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"l < #:prog\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(rule Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "then"], ["proof (chain)\npicking this:\n  l < #:prog", "obtain c' where \"labels prog l c'\""], ["proof (prove)\nusing this:\n  l < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>c'. labels prog l c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels prog l c'\n\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "hence \"label prog l = c'\""], ["proof (prove)\nusing this:\n  labels prog l c'\n\ngoal (1 subgoal):\n 1. label prog l = c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label prog l = c'\n\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "from \\<open>labels prog l c'\\<close> \\<open>prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  labels prog l c'\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"\\<exists>p es rets. fst_cmd c' = Call p es rets\""], ["proof (prove)\nusing this:\n  labels prog l c'\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets. fst_cmd c' = Call p es rets", "by(rule Proc_CFG_Call_source_fst_cmd_Call)"], ["proof (state)\nthis:\n  \\<exists>p es rets. fst_cmd c' = Call p es rets\n\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "with lhs_fst_cmd[of c']"], ["proof (chain)\npicking this:\n  lhs (fst_cmd c') = lhs c'\n  \\<exists>p es rets. fst_cmd c' = Call p es rets", "have \"lhs c' = {}\""], ["proof (prove)\nusing this:\n  lhs (fst_cmd c') = lhs c'\n  \\<exists>p es rets. fst_cmd c' = Call p es rets\n\ngoal (1 subgoal):\n 1. lhs c' = {}", "by auto"], ["proof (state)\nthis:\n  lhs c' = {}\n\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "with \\<open>label prog l = c'\\<close>"], ["proof (chain)\npicking this:\n  label prog l = c'\n  lhs c' = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  label prog l = c'\n  lhs c' = {}\n\ngoal (1 subgoal):\n 1. lhs (label prog l) = {}", "by simp"], ["proof (state)\nthis:\n  lhs (label prog l) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_procs_THE_in_procs_ins:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE ins'. \\<exists>c' outs'. (p,ins',outs',c') \\<in> set procs) = ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_formed procs; (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> (THE ins'.\n                          \\<exists>c' outs'.\n                             (p, ins', outs', c') \\<in> set procs) =\n                      ins", "by(fastforce intro:the_equality)"], ["", "definition Def :: \"wf_prog \\<Rightarrow> node \\<Rightarrow> vname set\"\n  where \"Def wfp n \\<equiv> (let (prog,procs) = Rep_wf_prog wfp; (p,l) = n in\n  (case l of Label lx \\<Rightarrow> \n    (if p = Main then lhs (label prog lx)\n     else (if (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs)\n           then \n  lhs (label (THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) lx)\n           else {}))\n  | Entry \\<Rightarrow> if (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs)\n            then (set \n      (THE ins'. \\<exists>c' outs'. (p,ins',outs',c') \\<in> set procs)) else {}\n  | Exit \\<Rightarrow> {}))\n    \\<union> set (ParamDefs wfp n)\""], ["", "lemma Entry_Def_empty:\"Def wfp (Main, Entry) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Def wfp (Main, Entry) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Def wfp (Main, Entry) = {}", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"Rep_wf_prog wfp\") auto"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Entry) = {}", "hence \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Entry) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Entry) = {}", "by(auto simp:Def_def ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  Def wfp (Main, Entry) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_Def_empty:\"Def wfp (Main, Exit) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Def wfp (Main, Exit) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Def wfp (Main, Exit) = {}", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"Rep_wf_prog wfp\") auto"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Exit) = {}", "hence \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Exit) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Exit) = {}", "by(auto dest:Proc_CFG_Call_Labels simp:Def_def ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  Def wfp (Main, Exit) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\\<open>Use\\<close>\\<close>"], ["", "fun rhs :: \"cmd \\<Rightarrow> vname set\"\nwhere\n  \"rhs Skip                = {}\"\n  | \"rhs (V:=e)              = fv e\"\n  | \"rhs (c\\<^sub>1;;c\\<^sub>2)            = rhs c\\<^sub>1\"\n  | \"rhs (if (b) c\\<^sub>1 else c\\<^sub>2) = fv b\"\n  | \"rhs (while (b) c)       = fv b\"\n  | \"rhs (Call p es rets)    = {}\""], ["", "lemma rhs_fst_cmd:\"rhs (fst_cmd c) = rhs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs (fst_cmd c) = rhs c", "by(induct c) auto"], ["", "lemma Proc_CFG_Call_target_empty_rhs:\n  assumes \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\"\n  shows \"rhs (label prog l') = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "from \\<open>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"l' < #:prog\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. l' < #:prog", "by(rule Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:prog\n\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "then"], ["proof (chain)\npicking this:\n  l' < #:prog", "obtain c' where \"labels prog l' c'\""], ["proof (prove)\nusing this:\n  l' < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>c'. labels prog l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels prog l' c'\n\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "hence \"label prog l' = c'\""], ["proof (prove)\nusing this:\n  labels prog l' c'\n\ngoal (1 subgoal):\n 1. label prog l' = c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label prog l' = c'\n\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "from \\<open>labels prog l' c'\\<close> \\<open>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  labels prog l' c'\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"fst_cmd c' = Skip\""], ["proof (prove)\nusing this:\n  labels prog l' c'\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. fst_cmd c' = Skip", "by(rule Proc_CFG_Call_target_fst_cmd_Skip)"], ["proof (state)\nthis:\n  fst_cmd c' = Skip\n\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "with rhs_fst_cmd[of c']"], ["proof (chain)\npicking this:\n  rhs (fst_cmd c') = rhs c'\n  fst_cmd c' = Skip", "have \"rhs c' = {}\""], ["proof (prove)\nusing this:\n  rhs (fst_cmd c') = rhs c'\n  fst_cmd c' = Skip\n\ngoal (1 subgoal):\n 1. rhs c' = {}", "by simp"], ["proof (state)\nthis:\n  rhs c' = {}\n\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "with \\<open>label prog l' = c'\\<close>"], ["proof (chain)\npicking this:\n  label prog l' = c'\n  rhs c' = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  label prog l' = c'\n  rhs c' = {}\n\ngoal (1 subgoal):\n 1. rhs (label prog l') = {}", "by simp"], ["proof (state)\nthis:\n  rhs (label prog l') = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_procs_THE_in_procs_outs:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> (THE outs'. \\<exists>c' ins'. (p,ins',outs',c') \\<in> set procs) = outs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_formed procs; (p, ins, outs, c) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> (THE outs'.\n                          \\<exists>c' ins'.\n                             (p, ins', outs', c') \\<in> set procs) =\n                      outs", "by(fastforce intro:the_equality)"], ["", "definition Use :: \"wf_prog \\<Rightarrow> node \\<Rightarrow> vname set\"\n  where \"Use wfp n \\<equiv> (let (prog,procs) = Rep_wf_prog wfp; (p,l) = n in\n  (case l of Label lx \\<Rightarrow> \n    (if p = Main then rhs (label prog lx) \n     else (if (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs)\n           then \n  rhs (label (THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) lx)\n           else {}))\n  | Exit \\<Rightarrow> if (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs)\n            then (set (THE outs'. \\<exists>c' ins'. (p,ins',outs',c') \\<in> set procs) )\n            else {}\n  | Entry \\<Rightarrow> if (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs)\n      then (set (THE ins'. \\<exists>c' outs'. (p,ins',outs',c') \\<in> set procs))\n      else {}))\n  \\<union> Union (set (ParamUses wfp n)) \\<union> set (ParamDefs wfp n)\""], ["", "lemma Entry_Use_empty:\"Use wfp (Main, Entry) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Use wfp (Main, Entry) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Use wfp (Main, Entry) = {}", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"Rep_wf_prog wfp\") auto"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. Use wfp (Main, Entry) = {}", "hence \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Use wfp (Main, Entry) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Use wfp (Main, Entry) = {}", "by(auto dest:Proc_CFG_Call_Labels \n    simp:Use_def ParamUses_def ParamUses_proc_def ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  Use wfp (Main, Entry) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_Use_empty:\"Use wfp (Main, Exit) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Use wfp (Main, Exit) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Use wfp (Main, Exit) = {}", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"Rep_wf_prog wfp\") auto"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. Use wfp (Main, Exit) = {}", "hence \"well_formed procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. well_formed procs", "by(fastforce intro:wf_wf_prog)"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Use wfp (Main, Exit) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. Use wfp (Main, Exit) = {}", "by(auto dest:Proc_CFG_Call_Labels \n    simp:Use_def ParamUses_def ParamUses_proc_def ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  Use wfp (Main, Exit) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lemmas about edges and call frames\\<close>"], ["", "lemmas transfers_simps = ProcCFG.transfer.simps[simplified]"], ["", "declare transfers_simps [simp]"], ["", "abbreviation state_val :: \"(('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> 'var \\<rightharpoonup> 'val\"\n  where \"state_val s V \\<equiv> (fst (hd s)) V\""], ["", "lemma Proc_CFG_edge_no_lhs_equal:\n  assumes \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\" and \"V \\<notin> lhs (label prog l)\"\n  shows \"state_val (CFG.transfer (lift_procs wfp) et (cf#cfs)) V = fst cf V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "from \\<open>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'", "obtain x where \"IEdge et = x\" and \"prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>IEdge et = x;\n         prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp_all"], ["proof (state)\nthis:\n  IEdge et = x\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "from \\<open>prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\\<close> \\<open>IEdge et = x\\<close> \\<open>V \\<notin> lhs (label prog l)\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n  IEdge et = x\n  V \\<notin> lhs (label prog l)", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n  IEdge et = x\n  V \\<notin> lhs (label prog l)\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "proof(induct prog \"Label l\" x n' arbitrary:l rule:Proc_CFG.induct)"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf Va e;\n        V \\<notin> lhs (label (Va:=e) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 17 subgoals...", "case (Proc_CFG_LAss V' e)"], ["proof (state)\nthis:\n  IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V' e\n  V \\<notin> lhs (label (V':=e) 0)\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf Va e;\n        V \\<notin> lhs (label (Va:=e) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 17 subgoals...", "have \"labels (V':=e) 0 (V':=e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (V':=e) 0 (V':=e)", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (V':=e) 0 (V':=e)\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf Va e;\n        V \\<notin> lhs (label (Va:=e) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 17 subgoals...", "hence \"label (V':=e) 0 = (V':=e)\""], ["proof (prove)\nusing this:\n  labels (V':=e) 0 (V':=e)\n\ngoal (1 subgoal):\n 1. label (V':=e) 0 = V':=e", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (V':=e) 0 = V':=e\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf Va e;\n        V \\<notin> lhs (label (Va:=e) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 17 subgoals...", "have \"V' \\<in> lhs (V':=e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V' \\<in> lhs (V':=e)", "by simp"], ["proof (state)\nthis:\n  V' \\<in> lhs (V':=e)\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf Va e;\n        V \\<notin> lhs (label (Va:=e) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 17 subgoals...", "with \\<open>V \\<notin> lhs (label (V':=e) 0)\\<close>\n      \\<open>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V' e\\<close> \\<open>label (V':=e) 0 = (V':=e)\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (V':=e) 0)\n  IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V' e\n  label (V':=e) 0 = V':=e\n  V' \\<in> lhs (V':=e)", "show ?case"], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (V':=e) 0)\n  IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V' e\n  label (V':=e) 0 = V':=e\n  V' \\<in> lhs (V':=e)\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by fastforce"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "case (Proc_CFG_SeqFirst c\\<^sub>1 et' n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>IEdge et = et'; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n  n' \\<noteq> Exit\n  IEdge et = et'\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "note IH = \\<open>\\<lbrakk>IEdge et = et'; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n      \\<Longrightarrow> state_val (CFG.transfer (lift_procs wfp) et (cf # cfs)) V = fst cf V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>IEdge et = et'; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "from \\<open>c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  l < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l c'\""], ["proof (prove)\nusing this:\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c'\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "hence \"labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "by(rule Labels_Seq1)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "hence \"label (c\\<^sub>1;;c\\<^sub>2) l = c';;c\\<^sub>2\""], ["proof (prove)\nusing this:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "with \\<open>V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<close> \\<open>labels c\\<^sub>1 l c'\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n  labels c\\<^sub>1 l c'\n  label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2", "have \"V \\<notin> lhs (label c\\<^sub>1 l)\""], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n  labels c\\<^sub>1 l c'\n  label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c\\<^sub>1 l)", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c\\<^sub>1 l)\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 16 subgoals...", "with \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>1 l)", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>1 l)\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by (rule IH)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "case (Proc_CFG_SeqConnect c\\<^sub>1 et' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>IEdge et = et'; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n  Label l \\<noteq> Entry\n  IEdge et = et'\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "note IH = \\<open>\\<lbrakk>IEdge et = et'; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n      \\<Longrightarrow> state_val (CFG.transfer (lift_procs wfp) et (cf # cfs)) V = fst cf V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>IEdge et = et'; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "from \\<open>c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  l < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l c'\""], ["proof (prove)\nusing this:\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c'\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "hence \"labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "by(rule Labels_Seq1)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "hence \"label (c\\<^sub>1;;c\\<^sub>2) l = c';;c\\<^sub>2\""], ["proof (prove)\nusing this:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "with \\<open>V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<close> \\<open>labels c\\<^sub>1 l c'\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n  labels c\\<^sub>1 l c'\n  label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2", "have \"V \\<notin> lhs (label c\\<^sub>1 l)\""], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n  labels c\\<^sub>1 l c'\n  label (c\\<^sub>1;; c\\<^sub>2) l = c';; c\\<^sub>2\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c\\<^sub>1 l)", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c\\<^sub>1 l)\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 15 subgoals...", "with \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>1 l)", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>1 l)\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by (rule IH)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2 n et' n' c\\<^sub>1 l)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c\\<^sub>2 ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  IEdge et = et'\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et'; V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n      \\<Longrightarrow> state_val (CFG.transfer (lift_procs wfp) et (cf # cfs)) V = fst cf V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c\\<^sub>2 ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "from \\<open>n \\<oplus> #:c\\<^sub>1 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 = Label l", "obtain l' \n      where \"n = Label l'\" and \"l = l' + #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + #:c\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + #:c\\<^sub>1\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "from \\<open>n = Label l'\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  n = Label l'\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "obtain c' where \"labels c\\<^sub>2 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>2 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l' c'\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "with \\<open>l = l' + #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + #:c\\<^sub>1\n  labels c\\<^sub>2 l' c'", "have \"labels (c\\<^sub>1;;c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + #:c\\<^sub>1\n  labels c\\<^sub>2 l' c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l c'", "by(fastforce intro:Labels_Seq2)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "hence \"label (c\\<^sub>1;;c\\<^sub>2) l = c'\""], ["proof (prove)\nusing this:\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. label (c\\<^sub>1;; c\\<^sub>2) l = c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (c\\<^sub>1;; c\\<^sub>2) l = c'\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "with \\<open>V \\<notin> lhs (label (c\\<^sub>1;;c\\<^sub>2) l)\\<close> \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>l = l' + #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n  labels c\\<^sub>2 l' c'\n  l = l' + #:c\\<^sub>1\n  label (c\\<^sub>1;; c\\<^sub>2) l = c'", "have \"V \\<notin> lhs (label c\\<^sub>2 l')\""], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\n  labels c\\<^sub>2 l' c'\n  l = l' + #:c\\<^sub>1\n  label (c\\<^sub>1;; c\\<^sub>2) l = c'\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c\\<^sub>2 l')", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c\\<^sub>2 l')\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (c\\<^sub>1;; c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 14 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>2 l')", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>2 l')\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by (rule IH)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "case (Proc_CFG_CondThen c\\<^sub>1 n et' n' b c\\<^sub>2 l)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c\\<^sub>1 ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n  n \\<noteq> Entry\n  n \\<oplus> 1 = Label l\n  IEdge et = et'\n  V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et'; V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n      \\<Longrightarrow> state_val (CFG.transfer (lift_procs wfp) et (cf # cfs)) V = fst cf V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c\\<^sub>1 ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "from \\<open>n \\<oplus> 1 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 1 = Label l", "obtain l' \n      where \"n = Label l'\" and \"l = l' + 1\""], ["proof (prove)\nusing this:\n  n \\<oplus> 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 1\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "from \\<open>n = Label l'\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "have \"l' < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n = Label l'\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>1\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l' c'\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "with \\<open>l = l' + 1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 1\n  labels c\\<^sub>1 l' c'", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + 1\n  labels c\\<^sub>1 l' c'\n\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "by(fastforce intro:Labels_CondTrue)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "hence \"label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'\""], ["proof (prove)\nusing this:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "with \\<open>V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<close> \\<open>labels c\\<^sub>1 l' c'\\<close> \\<open>l = l' + 1\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\n  labels c\\<^sub>1 l' c'\n  l = l' + 1\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'", "have \"V \\<notin> lhs (label c\\<^sub>1 l')\""], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\n  labels c\\<^sub>1 l' c'\n  l = l' + 1\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c\\<^sub>1 l')", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c\\<^sub>1 l')\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>1 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 13 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>1 l')", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>1 l')\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by (rule IH)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "case (Proc_CFG_CondElse c\\<^sub>2 n et' n' b c\\<^sub>1 l)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c\\<^sub>2 ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n  IEdge et = et'\n  V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et'; V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n      \\<Longrightarrow> state_val (CFG.transfer (lift_procs wfp) et (cf # cfs)) V = fst cf V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c\\<^sub>2 ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "from \\<open>n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l", "obtain l' \n      where \"n = Label l'\" and \"l = l' + #:c\\<^sub>1 + 1\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + #:c\\<^sub>1 + 1\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "from \\<open>n = Label l'\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  n = Label l'\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "obtain c' where \"labels c\\<^sub>2 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>2 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l' c'\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "with \\<open>l = l' + #:c\\<^sub>1 + 1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + #:c\\<^sub>1 + 1\n  labels c\\<^sub>2 l' c'", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + #:c\\<^sub>1 + 1\n  labels c\\<^sub>2 l' c'\n\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "by(fastforce intro:Labels_CondFalse)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "hence \"label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'\""], ["proof (prove)\nusing this:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "with \\<open>V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<close> \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>l = l' + #:c\\<^sub>1 + 1\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\n  labels c\\<^sub>2 l' c'\n  l = l' + #:c\\<^sub>1 + 1\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'", "have \"V \\<notin> lhs (label c\\<^sub>2 l')\""], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\n  labels c\\<^sub>2 l' c'\n  l = l' + #:c\\<^sub>1 + 1\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) l = c'\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c\\<^sub>2 l')", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c\\<^sub>2 l')\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c\\<^sub>2 l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             V \\<notin> lhs (label c' l)\\<rbrakk>\n            \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                               V =\n                              fst cf V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 12 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>2 l')", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c\\<^sub>2 l')\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by (rule IH)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "case (Proc_CFG_WhileBody c' n et' n' b l)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c' ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = Label l\n  IEdge et = et'\n  V \\<notin> lhs (label (while (b) c') l)\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et'; V \\<notin> lhs (label c' l)\\<rbrakk>\n      \\<Longrightarrow> state_val (CFG.transfer (lift_procs wfp) et (cf # cfs)) V = fst cf V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c' ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "from \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' \n      where \"n = Label l'\" and \"l = l' + 2\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 2\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "from \\<open>n = Label l'\\<close> \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  n = Label l'\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c'", "obtain cx where \"labels c' l' cx\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. (\\<And>cx. labels c' l' cx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c' l' cx\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "with \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 2\n  labels c' l' cx", "have \"labels (while (b) c') l (cx;;while (b) c')\""], ["proof (prove)\nusing this:\n  l = l' + 2\n  labels c' l' cx\n\ngoal (1 subgoal):\n 1. labels (while (b) c') l (cx;; while (b) c')", "by(fastforce intro:Labels_WhileBody)"], ["proof (state)\nthis:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "hence \"label (while (b) c') l = cx;;while (b) c'\""], ["proof (prove)\nusing this:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (1 subgoal):\n 1. label (while (b) c') l = cx;; while (b) c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (while (b) c') l = cx;; while (b) c'\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "with \\<open>V \\<notin> lhs (label (while (b) c') l)\\<close> \\<open>labels c' l' cx\\<close> \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (while (b) c') l)\n  labels c' l' cx\n  l = l' + 2\n  label (while (b) c') l = cx;; while (b) c'", "have \"V \\<notin> lhs (label c' l')\""], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (while (b) c') l)\n  labels c' l' cx\n  l = l' + 2\n  label (while (b) c') l = cx;; while (b) c'\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c' l')", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c' l')\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta; V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V\nA total of 11 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c' l')", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c' l')\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by (rule IH)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "case (Proc_CFG_WhileBodyExit c' n et' b l)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c' ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n  n \\<noteq> Entry\n  n \\<oplus> 2 = Label l\n  IEdge et = et'\n  V \\<notin> lhs (label (while (b) c') l)\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et'; V \\<notin> lhs (label c' l)\\<rbrakk>\n      \\<Longrightarrow> state_val (CFG.transfer (lift_procs wfp) et (cf # cfs)) V = fst cf V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   V \\<notin> lhs (label c' ?l)\\<rbrakk>\n  \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                    fst cf V\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "from \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' \n      where \"n = Label l'\" and \"l = l' + 2\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 2\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "from \\<open>n = Label l'\\<close> \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  n = Label l'\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "then"], ["proof (chain)\npicking this:\n  l' < #:c'", "obtain cx where \"labels c' l' cx\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. (\\<And>cx. labels c' l' cx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c' l' cx\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "with \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 2\n  labels c' l' cx", "have \"labels (while (b) c') l (cx;;while (b) c')\""], ["proof (prove)\nusing this:\n  l = l' + 2\n  labels c' l' cx\n\ngoal (1 subgoal):\n 1. labels (while (b) c') l (cx;; while (b) c')", "by(fastforce intro:Labels_WhileBody)"], ["proof (state)\nthis:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "hence \"label (while (b) c') l = cx;;while (b) c'\""], ["proof (prove)\nusing this:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (1 subgoal):\n 1. label (while (b) c') l = cx;; while (b) c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (while (b) c') l = cx;; while (b) c'\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "with \\<open>V \\<notin> lhs (label (while (b) c') l)\\<close> \\<open>labels c' l' cx\\<close> \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lhs (label (while (b) c') l)\n  labels c' l' cx\n  l = l' + 2\n  label (while (b) c') l = cx;; while (b) c'", "have \"V \\<notin> lhs (label c' l')\""], ["proof (prove)\nusing this:\n  V \\<notin> lhs (label (while (b) c') l)\n  labels c' l' cx\n  l = l' + 2\n  label (while (b) c') l = cx;; while (b) c'\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c' l')", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c' l')\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            V \\<notin> lhs (label c' l)\\<rbrakk>\n           \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs))\n                              V =\n                             fst cf V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        V \\<notin> lhs (label (while (b) c') l)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                          fst cf V", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c' l')", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  V \\<notin> lhs (label c' l')\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V", "by (rule IH)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     V \\<notin> lhs (label Skip 0)\\<rbrakk>\n    \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                      fst cf V\n 2. \\<And>Va e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Va:=e) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        V \\<notin> lhs (label (while (b) c') 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (while (b) c') 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        V \\<notin> lhs (label (Call p es rets) 0)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        V \\<notin> lhs (label (Call p es rets) 1)\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp et (cf # cfs)) V =\n                         fst cf V", "qed auto"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp et (cf # cfs)) V = fst cf V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_edge_uses_only_rhs:\n  assumes \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\" and \"CFG.pred et s\"\n  and \"CFG.pred et s'\" and \"\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\"\n  shows \"\\<forall>V\\<in>lhs (label prog l). \n    state_val (CFG.transfer (lift_procs wfp) et s) V =\n    state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label prog l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label prog l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "from \\<open>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'", "obtain x where \"IEdge et = x\" and \"prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>IEdge et = x;\n         prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp_all"], ["proof (state)\nthis:\n  IEdge et = x\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label prog l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "from \\<open>CFG.pred et s\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred et s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  ProcCFG.pred et s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label prog l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "from \\<open>CFG.pred et s'\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred et s'", "obtain cf' cfs' where [simp]:\"s' = cf'#cfs'\""], ["proof (prove)\nusing this:\n  ProcCFG.pred et s'\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        s' = cf' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s') auto"], ["proof (state)\nthis:\n  s' = cf' # cfs'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label prog l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "from \\<open>prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\\<close> \\<open>IEdge et = x\\<close>\n    \\<open>\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n  IEdge et = x\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n  IEdge et = x\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label prog l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "proof(induct prog \"Label l\" x n' arbitrary:l rule:Proc_CFG.induct)"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>lhs (label Skip 0).\n                         state_val (ProcCFG.transfer wfp et s) V =\n                         state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs\n    (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 17 subgoals...", "case Proc_CFG_Skip"], ["proof (state)\nthis:\n  IEdge et = IEdge \\<Up>id\n  \\<forall>V\\<in>rhs (label Skip 0). state_val s V = state_val s' V\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>lhs (label Skip 0).\n                         state_val (ProcCFG.transfer wfp et s) V =\n                         state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs\n    (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 17 subgoals...", "have \"labels Skip 0 Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels Skip 0 Skip", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels Skip 0 Skip\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>lhs (label Skip 0).\n                         state_val (ProcCFG.transfer wfp et s) V =\n                         state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs\n    (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 17 subgoals...", "hence \"label Skip 0 = Skip\""], ["proof (prove)\nusing this:\n  labels Skip 0 Skip\n\ngoal (1 subgoal):\n 1. label Skip 0 = Skip", "by(rule labels_label)"], ["proof (state)\nthis:\n  label Skip 0 = Skip\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>lhs (label Skip 0).\n                         state_val (ProcCFG.transfer wfp et s) V =\n                         state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs\n    (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 17 subgoals...", "hence \"\\<forall>V. V \\<notin> lhs (label Skip 0)\""], ["proof (prove)\nusing this:\n  label Skip 0 = Skip\n\ngoal (1 subgoal):\n 1. \\<forall>V. V \\<notin> lhs (label Skip 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V. V \\<notin> lhs (label Skip 0)\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>lhs (label Skip 0).\n                         state_val (ProcCFG.transfer wfp et s) V =\n                         state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs\n    (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>V. V \\<notin> lhs (label Skip 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V. V \\<notin> lhs (label Skip 0)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label Skip 0).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label Skip 0).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (16 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 16 subgoals...", "case (Proc_CFG_LAss V e)"], ["proof (state)\nthis:\n  IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e\n  \\<forall>V\\<in>rhs (label (V:=e) 0). state_val s V = state_val s' V\n\ngoal (16 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 16 subgoals...", "have \"labels (V:=e) 0 (V:=e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (V:=e) 0 (V:=e)", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (V:=e) 0 (V:=e)\n\ngoal (16 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 16 subgoals...", "hence \"label (V:=e) 0 = V:=e\""], ["proof (prove)\nusing this:\n  labels (V:=e) 0 (V:=e)\n\ngoal (1 subgoal):\n 1. label (V:=e) 0 = V:=e", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (V:=e) 0 = V:=e\n\ngoal (16 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  label (V:=e) 0 = V:=e", "have \"lhs (label (V:=e) 0) = {V}\"\n      and \"rhs (label (V:=e) 0) = fv e\""], ["proof (prove)\nusing this:\n  label (V:=e) 0 = V:=e\n\ngoal (1 subgoal):\n 1. lhs (label (V:=e) 0) = {V} &&& rhs (label (V:=e) 0) = fv e", "by auto"], ["proof (state)\nthis:\n  lhs (label (V:=e) 0) = {V}\n  rhs (label (V:=e) 0) = fv e\n\ngoal (16 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 16 subgoals...", "with \\<open>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e\\<close> \n      \\<open>\\<forall>V\\<in>rhs (label (V:=e) 0). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e\n  \\<forall>V\\<in>rhs (label (V:=e) 0). state_val s V = state_val s' V\n  lhs (label (V:=e) 0) = {V}\n  rhs (label (V:=e) 0) = fv e", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e\n  \\<forall>V\\<in>rhs (label (V:=e) 0). state_val s V = state_val s' V\n  lhs (label (V:=e) 0) = {V}\n  rhs (label (V:=e) 0) = fv e\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (V:=e) 0).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce intro:rhs_interpret_eq)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (V:=e) 0).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (15 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 15 subgoals...", "case (Proc_CFG_LAssSkip V e)"], ["proof (state)\nthis:\n  IEdge et = IEdge \\<Up>id\n  \\<forall>V\\<in>rhs (label (V:=e) 1). state_val s V = state_val s' V\n\ngoal (15 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 15 subgoals...", "have \"labels (V:=e) 1 Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (V:=e) 1 Skip", "by(rule Labels_LAss)"], ["proof (state)\nthis:\n  labels (V:=e) 1 Skip\n\ngoal (15 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 15 subgoals...", "hence \"label (V:=e) 1 = Skip\""], ["proof (prove)\nusing this:\n  labels (V:=e) 1 Skip\n\ngoal (1 subgoal):\n 1. label (V:=e) 1 = Skip", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (V:=e) 1 = Skip\n\ngoal (15 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 15 subgoals...", "hence \"\\<forall>V'. V' \\<notin> lhs (label (V:=e) 1)\""], ["proof (prove)\nusing this:\n  label (V:=e) 1 = Skip\n\ngoal (1 subgoal):\n 1. \\<forall>V'. V' \\<notin> lhs (label (V:=e) 1)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V'. V' \\<notin> lhs (label (V:=e) 1)\n\ngoal (15 subgoals):\n 1. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (V:=e) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>V'. V' \\<notin> lhs (label (V:=e) 1)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V'. V' \\<notin> lhs (label (V:=e) 1)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (V:=e) 1).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (V:=e) 1).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "case (Proc_CFG_SeqFirst c\\<^sub>1 et' n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n  n' \\<noteq> Exit\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "note IH = \\<open>\\<lbrakk>IEdge et = et'; \n      \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n        state_val (CFG.transfer (lift_procs wfp) et s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "from \\<open>c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  l < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l c'\""], ["proof (prove)\nusing this:\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c'\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "hence \"labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "by(rule Labels_Seq1)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "with \\<open>labels c\\<^sub>1 l c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "with \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "have \"\\<forall>V\\<in>lhs (label c\\<^sub>1 l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n      state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\nusing this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by (rule IH)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 14 subgoals...", "with \\<open>labels c\\<^sub>1 l c'\\<close> \\<open>labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l c'\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V", "show ?case"], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "case (Proc_CFG_SeqConnect c\\<^sub>1 et' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n  Label l \\<noteq> Entry\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "note IH = \\<open>\\<lbrakk>IEdge et = et'; \n      \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n        state_val (CFG.transfer (lift_procs wfp) et s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "from \\<open>c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  l < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l c'\""], ["proof (prove)\nusing this:\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c'\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "hence \"labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "by(rule Labels_Seq1)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "with \\<open>labels c\\<^sub>1 l c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "with \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "have \"\\<forall>V\\<in>lhs (label c\\<^sub>1 l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n      state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\nusing this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by (rule IH)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V;\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 13 subgoals...", "with \\<open>labels c\\<^sub>1 l c'\\<close> \\<open>labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l c'\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V", "show ?case"], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2 n et' n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et'; \n      \\<forall>V\\<in>rhs (label c\\<^sub>2 l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n        state_val (CFG.transfer (lift_procs wfp) et s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "from \\<open>n \\<oplus> #:c\\<^sub>1 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + #:c\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + #:c\\<^sub>1\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "from \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "obtain c' where \"labels c\\<^sub>2 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>2 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l' c'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "with \\<open>l = l' + #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + #:c\\<^sub>1\n  labels c\\<^sub>2 l' c'", "have \"labels (c\\<^sub>1;;c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + #:c\\<^sub>1\n  labels c\\<^sub>2 l' c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l c'", "by(fastforce intro:Labels_Seq2)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "with \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (c\\<^sub>1;;c\\<^sub>2) l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "have \"\\<forall>V\\<in>lhs (label c\\<^sub>2 l'). state_val (CFG.transfer (lift_procs wfp) et s) V =\n      state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by (rule IH)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (c\\<^sub>1;; c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                 state_val (ProcCFG.transfer wfp et s) V =\n                                 state_val (ProcCFG.transfer wfp et s') V;\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 12 subgoals...", "with \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>labels (c\\<^sub>1;;c\\<^sub>2) l c'\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>2 l' c'\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n  \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V", "show ?case"], ["proof (prove)\nusing this:\n  labels c\\<^sub>2 l' c'\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n  \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 11 subgoals...", "case (Proc_CFG_CondTrue b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 11 subgoals...", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0 (if (b) c\\<^sub>1 else c\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n     (if (b) c\\<^sub>1 else c\\<^sub>2)", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 11 subgoals...", "hence \"label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1 else c\\<^sub>2\""], ["proof (prove)\nusing this:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n    else c\\<^sub>2", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 11 subgoals...", "hence \"\\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\""], ["proof (prove)\nusing this:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_CondFalse b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0 (if (b) c\\<^sub>1 else c\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n     (if (b) c\\<^sub>1 else c\\<^sub>2)", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V", "hence \"label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1 else c\\<^sub>2\""], ["proof (prove)\nusing this:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n    else c\\<^sub>2", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V", "hence \"\\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\""], ["proof (prove)\nusing this:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                             state_val (ProcCFG.transfer wfp et s) V =\n                             state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V. V \\<notin> lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_CondThen c\\<^sub>1 n et' n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n  n \\<noteq> Entry\n  n \\<oplus> 1 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et'; \n      \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n        state_val (CFG.transfer (lift_procs wfp) et s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>n \\<oplus> 1 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 1 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + 1\""], ["proof (prove)\nusing this:\n  n \\<oplus> 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 1\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l' c'\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>l = l' + 1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 1\n  labels c\\<^sub>1 l' c'", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + 1\n  labels c\\<^sub>1 l' c'\n\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "by(fastforce intro:Labels_CondTrue)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c\\<^sub>1 l' c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V", "have \"\\<forall>V\\<in>lhs (label c\\<^sub>1 l'). state_val (CFG.transfer (lift_procs wfp) et s) V =\n      state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c\\<^sub>1 l').\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by (rule IH)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>1 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c\\<^sub>1 l' c'\\<close> \\<open>labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l' c'\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V", "show ?case"], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l' c'\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n  \\<forall>V\\<in>lhs (label c\\<^sub>1 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_CondElse c\\<^sub>2 n et' n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c\\<^sub>2 l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n        state_val (CFG.transfer (lift_procs wfp) et s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>n \\<oplus> #:c\\<^sub>1 + 1= Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + #:c\\<^sub>1+1\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + #:c\\<^sub>1 + 1\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "obtain c' where \"labels c\\<^sub>2 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>2 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l' c'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>l = l' + #:c\\<^sub>1 + 1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + #:c\\<^sub>1 + 1\n  labels c\\<^sub>2 l' c'", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + #:c\\<^sub>1 + 1\n  labels c\\<^sub>2 l' c'\n\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "by(fastforce intro:Labels_CondFalse)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l). \n      state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "have \"\\<forall>V\\<in>lhs (label c\\<^sub>2 l'). state_val (CFG.transfer (lift_procs wfp) et s) V =\n      state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by (rule IH)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c\\<^sub>2 l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs\n   (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>2 l' c'\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n  \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V", "show ?case"], ["proof (prove)\nusing this:\n  labels c\\<^sub>2 l' c'\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n  \\<forall>V\\<in>lhs (label c\\<^sub>2 l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_WhileTrue b c')"], ["proof (state)\nthis:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "have \"labels (while (b) c') 0 (while (b) c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (while (b) c') 0 (while (b) c')", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"label (while (b) c') 0 = while (b) c'\""], ["proof (prove)\nusing this:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (1 subgoal):\n 1. label (while (b) c') 0 = while (b) c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (while (b) c') 0 = while (b) c'\n\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"\\<forall>V. V \\<notin> lhs (label (while (b) c') 0)\""], ["proof (prove)\nusing this:\n  label (while (b) c') 0 = while (b) c'\n\ngoal (1 subgoal):\n 1. \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)\n\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (while (b) c') 0).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (while (b) c') 0).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_WhileFalse b c')"], ["proof (state)\nthis:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "have \"labels (while (b) c') 0 (while (b) c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (while (b) c') 0 (while (b) c')", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"label (while (b) c') 0 = while (b) c'\""], ["proof (prove)\nusing this:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (1 subgoal):\n 1. label (while (b) c') 0 = while (b) c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (while (b) c') 0 = while (b) c'\n\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"\\<forall>V. V \\<notin> lhs (label (while (b) c') 0)\""], ["proof (prove)\nusing this:\n  label (while (b) c') 0 = while (b) c'\n\ngoal (1 subgoal):\n 1. \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)\n\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 0)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (while (b) c') 0).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (while (b) c') 0).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_WhileFalseSkip b c')"], ["proof (state)\nthis:\n  IEdge et = IEdge \\<Up>id\n  \\<forall>V\\<in>rhs (label (while (b) c') 1).\n     state_val s V = state_val s' V\n\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "have \"labels (while (b) c') 1 Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (while (b) c') 1 Skip", "by(rule Labels_WhileExit)"], ["proof (state)\nthis:\n  labels (while (b) c') 1 Skip\n\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"label (while (b) c') 1 = Skip\""], ["proof (prove)\nusing this:\n  labels (while (b) c') 1 Skip\n\ngoal (1 subgoal):\n 1. label (while (b) c') 1 = Skip", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (while (b) c') 1 = Skip\n\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"\\<forall>V. V \\<notin> lhs (label (while (b) c') 1)\""], ["proof (prove)\nusing this:\n  label (while (b) c') 1 = Skip\n\ngoal (1 subgoal):\n 1. \\<forall>V. V \\<notin> lhs (label (while (b) c') 1)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 1)\n\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 1)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V. V \\<notin> lhs (label (while (b) c') 1)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (while (b) c') 1).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (while (b) c') 1).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_WhileBody c' n et' n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c' l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n        state_val (CFG.transfer (lift_procs wfp) et s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + 2\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 2\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  l' < #:c'", "obtain cx where \"labels c' l' cx\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. (\\<And>cx. labels c' l' cx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c' l' cx\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 2\n  labels c' l' cx", "have \"labels (while (b) c') l (cx;;while (b) c')\""], ["proof (prove)\nusing this:\n  l = l' + 2\n  labels c' l' cx\n\ngoal (1 subgoal):\n 1. labels (while (b) c') l (cx;; while (b) c')", "by(fastforce intro:Labels_WhileBody)"], ["proof (state)\nthis:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c' l' cx\\<close> \\<open>\\<forall>V\\<in>rhs (label (while (b) c') l). \n      state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')", "have \"\\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "have \"\\<forall>V\\<in>lhs (label c' l'). state_val (CFG.transfer (lift_procs wfp) et s) V =\n      state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c' l').\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by (rule IH)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c' l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (4 subgoals):\n 1. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 4. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c' l' cx\\<close> \\<open>labels (while (b) c') l (cx;;while (b) c')\\<close>"], ["proof (chain)\npicking this:\n  labels c' l' cx\n  labels (while (b) c') l (cx;; while (b) c')\n  \\<forall>V\\<in>lhs (label c' l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V", "show ?case"], ["proof (prove)\nusing this:\n  labels c' l' cx\n  labels (while (b) c') l (cx;; while (b) c')\n  \\<forall>V\\<in>lhs (label c' l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (while (b) c') l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (while (b) c') l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_WhileBodyExit c' n et' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n  n \\<noteq> Entry\n  n \\<oplus> 2 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c' l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l). state_val (CFG.transfer (lift_procs wfp) et s) V =\n        state_val (CFG.transfer (lift_procs wfp) et s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' ?l).\n                       state_val (ProcCFG.transfer wfp et s) V =\n                       state_val (ProcCFG.transfer wfp et s') V\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + 2\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 2\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "from \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n  n = Label l'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  l' < #:c'", "obtain cx where \"labels c' l' cx\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. (\\<And>cx. labels c' l' cx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c' l' cx\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 2\n  labels c' l' cx", "have \"labels (while (b) c') l (cx;;while (b) c')\""], ["proof (prove)\nusing this:\n  l = l' + 2\n  labels c' l' cx\n\ngoal (1 subgoal):\n 1. labels (while (b) c') l (cx;; while (b) c')", "by(fastforce intro:Labels_WhileBody)"], ["proof (state)\nthis:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c' l' cx\\<close> \\<open>\\<forall>V\\<in>rhs (label (while (b) c') l).\n      state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')", "have \"\\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "have \"\\<forall>V\\<in>lhs (label c' l'). state_val (CFG.transfer (lift_procs wfp) et s) V =\n      state_val (CFG.transfer (lift_procs wfp) et s') V\""], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c' l').\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by (rule IH)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c' l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (3 subgoals):\n 1. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>lhs (label c' l).\n                                state_val (ProcCFG.transfer wfp et s) V =\n                                state_val (ProcCFG.transfer wfp et s') V;\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (while (b) c') l).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 3. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "with \\<open>labels c' l' cx\\<close> \\<open>labels (while (b) c') l (cx;;while (b) c')\\<close>"], ["proof (chain)\npicking this:\n  labels c' l' cx\n  labels (while (b) c') l (cx;; while (b) c')\n  \\<forall>V\\<in>lhs (label c' l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V", "show ?case"], ["proof (prove)\nusing this:\n  labels c' l' cx\n  labels (while (b) c') l (cx;; while (b) c')\n  \\<forall>V\\<in>lhs (label c' l').\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (while (b) c') l).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (while (b) c') l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "case (Proc_CFG_CallSkip p es rets)"], ["proof (state)\nthis:\n  IEdge et = IEdge \\<Up>id\n  \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n     state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "have \"labels (Call p es rets) 1 Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (Call p es rets) 1 Skip", "by(rule Labels_Call)"], ["proof (state)\nthis:\n  labels (Call p es rets) 1 Skip\n\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"label (Call p es rets) 1 = Skip\""], ["proof (prove)\nusing this:\n  labels (Call p es rets) 1 Skip\n\ngoal (1 subgoal):\n 1. label (Call p es rets) 1 = Skip", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (Call p es rets) 1 = Skip\n\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "hence \"\\<forall>V. V \\<notin> lhs (label (Call p es rets) 1)\""], ["proof (prove)\nusing this:\n  label (Call p es rets) 1 = Skip\n\ngoal (1 subgoal):\n 1. \\<forall>V. V \\<notin> lhs (label (Call p es rets) 1)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V. V \\<notin> lhs (label (Call p es rets) 1)\n\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V\n 2. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "then"], ["proof (chain)\npicking this:\n  \\<forall>V. V \\<notin> lhs (label (Call p es rets) 1)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>V. V \\<notin> lhs (label (Call p es rets) 1)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n       state_val (ProcCFG.transfer wfp et s) V =\n       state_val (ProcCFG.transfer wfp et s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label (Call p es rets) 1).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal (1 subgoal):\n 1. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lhs (label (Call p es rets) 0).\n                            state_val (ProcCFG.transfer wfp et s) V =\n                            state_val (ProcCFG.transfer wfp et s') V", "qed auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label prog l).\n     state_val (ProcCFG.transfer wfp et s) V =\n     state_val (ProcCFG.transfer wfp et s') V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_edge_rhs_pred_eq:\n  assumes \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\" and \"CFG.pred et s\"\n  and \"\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\"\n  and \"length s = length s'\"\n  shows \"CFG.pred et s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "from \\<open>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'", "obtain x where \"IEdge et = x\" and \"prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>IEdge et = x;\n         prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp_all"], ["proof (state)\nthis:\n  IEdge et = x\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "from \\<open>CFG.pred et s\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred et s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  ProcCFG.pred et s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "from \\<open>length s = length s'\\<close>"], ["proof (chain)\npicking this:\n  length s = length s'", "obtain cf' cfs' where [simp]:\"s' = cf'#cfs'\""], ["proof (prove)\nusing this:\n  length s = length s'\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        s' = cf' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s') auto"], ["proof (state)\nthis:\n  s' = cf' # cfs'\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "from \\<open>prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\\<close> \\<open>IEdge et = x\\<close> \n    \\<open>\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n  IEdge et = x\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -x\\<rightarrow>\\<^sub>p n'\n  IEdge et = x\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "proof(induct prog \"Label l\" x n' arbitrary:l rule:Proc_CFG.induct)"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 17 subgoals...", "case (Proc_CFG_SeqFirst c\\<^sub>1 et' n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n  n' \\<noteq> Exit\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 17 subgoals...", "note IH = \\<open>\\<lbrakk>IEdge et = et'; \\<forall>V\\<in>rhs (label c\\<^sub>1 l). \n      state_val s V = state_val s' V\\<rbrakk> \\<Longrightarrow> CFG.pred et s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 17 subgoals...", "from \\<open>c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  l < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l c'\""], ["proof (prove)\nusing this:\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c'\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 17 subgoals...", "hence \"labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "by(rule Labels_Seq1)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 17 subgoals...", "with \\<open>labels c\\<^sub>1 l c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (17 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -eta\\<rightarrow>\\<^sub>p n';\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        n' \\<noteq> Exit; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 17 subgoals...", "with \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by (rule IH)"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "case (Proc_CFG_SeqConnect c\\<^sub>1 et' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n  Label l \\<noteq> Entry\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "note IH = \\<open>\\<lbrakk>IEdge et = et'; \n      \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\\<rbrakk>\n      \\<Longrightarrow> CFG.pred et s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "from \\<open>c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  l < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l c'\""], ["proof (prove)\nusing this:\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l c'\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "hence \"labels (c\\<^sub>1;;c\\<^sub>2) l (c';;c\\<^sub>2)\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "by(rule Labels_Seq1)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "with \\<open>labels c\\<^sub>1 l c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l (c';; c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (16 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 eta c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<lbrakk>IEdge et = eta;\n         \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s';\n        Label l \\<noteq> Entry; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 16 subgoals...", "with \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by (rule IH)"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2 n et' n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c\\<^sub>2 l). state_val s V = state_val s' V\\<rbrakk> \n      \\<Longrightarrow> CFG.pred et s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "from \\<open>n \\<oplus> #:c\\<^sub>1 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + #:c\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + #:c\\<^sub>1\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "from \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "obtain c' where \"labels c\\<^sub>2 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>2 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l' c'\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "with \\<open>l = l' + #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + #:c\\<^sub>1\n  labels c\\<^sub>2 l' c'", "have \"labels (c\\<^sub>1;;c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + #:c\\<^sub>1\n  labels c\\<^sub>2 l' c'\n\ngoal (1 subgoal):\n 1. labels (c\\<^sub>1;; c\\<^sub>2) l c'", "by(fastforce intro:Labels_Seq2)"], ["proof (state)\nthis:\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "with \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (c\\<^sub>1;;c\\<^sub>2) l). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (c\\<^sub>1;; c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (15 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (c\\<^sub>1;; c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et =\n                 IEdge\n                  (\\<lambda>cf.\n                      state_check cf b (Some false))\\<^sub>\\<surd>;\n         \\<forall>V\\<in>rhs (label (while (b) c') 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 15 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by (rule IH)"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "case (Proc_CFG_CondTrue b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "from \\<open>CFG.pred et s\\<close> \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred et s\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>", "have \"state_check (fst cf) b (Some true)\""], ["proof (prove)\nusing this:\n  ProcCFG.pred et s\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_check (fst cf) b (Some true)", "by simp"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some true)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "moreover"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some true)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0 (if (b) c\\<^sub>1 else c\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n     (if (b) c\\<^sub>1 else c\\<^sub>2)", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "hence \"label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1 else c\\<^sub>2\""], ["proof (prove)\nusing this:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n    else c\\<^sub>2", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "with \\<open>\\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2", "have \"\\<forall>V\\<in> fv b. state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  state_check (fst cf) b (Some true)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "have \"state_check (fst cf') b (Some true)\""], ["proof (prove)\nusing this:\n  state_check (fst cf) b (Some true)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. state_check (fst cf') b (Some true)", "by simp(rule rhs_interpret_eq)"], ["proof (state)\nthis:\n  state_check (fst cf') b (Some true)\n\ngoal (14 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>b c'.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (while (b) c') 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 14 subgoals...", "with \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some true)", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some true)\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by simp"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "case (Proc_CFG_CondFalse b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "from \\<open>CFG.pred et s\\<close> \n      \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred et s\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>", "have \"state_check (fst cf) b (Some false)\""], ["proof (prove)\nusing this:\n  ProcCFG.pred et s\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_check (fst cf) b (Some false)", "by simp"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some false)\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some false)\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0 (if (b) c\\<^sub>1 else c\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n     (if (b) c\\<^sub>1 else c\\<^sub>2)", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "hence \"label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1 else c\\<^sub>2\""], ["proof (prove)\nusing this:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) 0\n   (if (b) c\\<^sub>1 else c\\<^sub>2)\n\ngoal (1 subgoal):\n 1. label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n    else c\\<^sub>2", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "with \\<open>\\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2", "have \"\\<forall>V\\<in> fv b. state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n     state_val s V = state_val s' V\n  label (if (b) c\\<^sub>1 else c\\<^sub>2) 0 = if (b) c\\<^sub>1\n  else c\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  state_check (fst cf) b (Some false)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "have \"state_check (fst cf') b (Some false)\""], ["proof (prove)\nusing this:\n  state_check (fst cf) b (Some false)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. state_check (fst cf') b (Some false)", "by simp(rule rhs_interpret_eq)"], ["proof (state)\nthis:\n  state_check (fst cf') b (Some false)\n\ngoal (13 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta n' b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n         IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 13 subgoals...", "with \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some false)", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some false)\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by simp"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "case (Proc_CFG_CondThen c\\<^sub>1 n et' n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n  n \\<noteq> Entry\n  n \\<oplus> 1 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c\\<^sub>1 l). state_val s V = state_val s' V\\<rbrakk> \n      \\<Longrightarrow> CFG.pred et s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>1 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "from \\<open>n \\<oplus> 1 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 1 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + 1\""], ["proof (prove)\nusing this:\n  n \\<oplus> 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 1\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "from \\<open>c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>1\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>1", "obtain c' where \"labels c\\<^sub>1 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>1 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>1 l' c'\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "with \\<open>l = l' + 1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 1\n  labels c\\<^sub>1 l' c'", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + 1\n  labels c\\<^sub>1 l' c'\n\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "by(fastforce intro:Labels_CondTrue)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "with \\<open>labels c\\<^sub>1 l' c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l). \n      state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>1 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>1 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V\n\ngoal (12 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>1 n eta n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>1 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>c' n eta b l.\n        \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l.\n            \\<lbrakk>n = Label l; IEdge et = eta;\n             \\<forall>V\\<in>rhs (label c' l).\n                state_val s V = state_val s' V\\<rbrakk>\n            \\<Longrightarrow> ProcCFG.pred et s';\n         n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n         \\<forall>V\\<in>rhs (label (while (b) c') l).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 12 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>1 l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by (rule IH)"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "case (Proc_CFG_CondElse c\\<^sub>2 n et' n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c\\<^sub>2 l). state_val s V = state_val s' V\\<rbrakk> \n      \\<Longrightarrow> CFG.pred et s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c\\<^sub>2 ?l).\n      state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "from \\<open>n \\<oplus> #:c\\<^sub>1 + 1= Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + #:c\\<^sub>1+1\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + #:c\\<^sub>1 + 1\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "from \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "obtain c' where \"labels c\\<^sub>2 l' c'\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        labels c\\<^sub>2 l' c' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c\\<^sub>2 l' c'\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "with \\<open>l = l' + #:c\\<^sub>1 + 1\\<close>"], ["proof (chain)\npicking this:\n  l = l' + #:c\\<^sub>1 + 1\n  labels c\\<^sub>2 l' c'", "have \"labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\""], ["proof (prove)\nusing this:\n  l = l' + #:c\\<^sub>1 + 1\n  labels c\\<^sub>2 l' c'\n\ngoal (1 subgoal):\n 1. labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "by(fastforce intro:Labels_CondFalse)"], ["proof (state)\nthis:\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "with \\<open>labels c\\<^sub>2 l' c'\\<close> \\<open>\\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l). \n      state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'", "have \"\\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c\\<^sub>2 l' c'\n  \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n     state_val s V = state_val s' V\n  labels (if (b) c\\<^sub>1 else c\\<^sub>2) l c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (11 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>c\\<^sub>2 n eta n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c\\<^sub>2 l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (if (b) c\\<^sub>1 else c\\<^sub>2) l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = CEdge (p, es, rets);\n         \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'\nA total of 11 subgoals...", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c\\<^sub>2 l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by (rule IH)"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "case (Proc_CFG_WhileTrue b c')"], ["proof (state)\nthis:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "from \\<open>CFG.pred et s\\<close> \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred et s\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>", "have \"state_check (fst cf) b (Some true)\""], ["proof (prove)\nusing this:\n  ProcCFG.pred et s\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_check (fst cf) b (Some true)", "by simp"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some true)\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "moreover"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some true)\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "have \"labels (while (b) c') 0 (while (b) c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (while (b) c') 0 (while (b) c')", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "hence \"label (while (b) c') 0 = while (b) c'\""], ["proof (prove)\nusing this:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (1 subgoal):\n 1. label (while (b) c') 0 = while (b) c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (while (b) c') 0 = while (b) c'\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>\\<forall>V\\<in>rhs (label (while (b) c') 0). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n  label (while (b) c') 0 = while (b) c'", "have \"\\<forall>V\\<in> fv b. state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n  label (while (b) c') 0 = while (b) c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "ultimately"], ["proof (chain)\npicking this:\n  state_check (fst cf) b (Some true)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "have \"state_check (fst cf') b (Some true)\""], ["proof (prove)\nusing this:\n  state_check (fst cf) b (Some true)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. state_check (fst cf') b (Some true)", "by simp(rule rhs_interpret_eq)"], ["proof (state)\nthis:\n  state_check (fst cf') b (Some true)\n\ngoal (10 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 10. \\<And>p es rets.\n        \\<lbrakk>IEdge et = IEdge \\<Up>id;\n         \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some true)", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some true)\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by simp"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "case (Proc_CFG_WhileFalse b c')"], ["proof (state)\nthis:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "from \\<open>CFG.pred et s\\<close>\n      \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred et s\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>", "have \"state_check (fst cf) b (Some false)\""], ["proof (prove)\nusing this:\n  ProcCFG.pred et s\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_check (fst cf) b (Some false)", "by simp"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some false)\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "moreover"], ["proof (state)\nthis:\n  state_check (fst cf) b (Some false)\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "have \"labels (while (b) c') 0 (while (b) c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels (while (b) c') 0 (while (b) c')", "by(rule Labels_Base)"], ["proof (state)\nthis:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "hence \"label (while (b) c') 0 = while (b) c'\""], ["proof (prove)\nusing this:\n  labels (while (b) c') 0 (while (b) c')\n\ngoal (1 subgoal):\n 1. label (while (b) c') 0 = while (b) c'", "by(rule labels_label)"], ["proof (state)\nthis:\n  label (while (b) c') 0 = while (b) c'\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>\\<forall>V\\<in>rhs (label (while (b) c') 0). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n  label (while (b) c') 0 = while (b) c'", "have \"\\<forall>V\\<in> fv b. state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rhs (label (while (b) c') 0).\n     state_val s V = state_val s' V\n  label (while (b) c') 0 = while (b) c'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "ultimately"], ["proof (chain)\npicking this:\n  state_check (fst cf) b (Some false)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V", "have \"state_check (fst cf') b (Some false)\""], ["proof (prove)\nusing this:\n  state_check (fst cf) b (Some false)\n  \\<forall>V\\<in>fv b. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. state_check (fst cf') b (Some false)", "by simp(rule rhs_interpret_eq)"], ["proof (state)\nthis:\n  state_check (fst cf') b (Some false)\n\ngoal (9 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et =\n                IEdge\n                 (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        \\<forall>V\\<in>rhs (label (while (b) c') 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 9. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>IEdge et = IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some false)", "show ?case"], ["proof (prove)\nusing this:\n  IEdge et =\n  IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\n  state_check (fst cf') b (Some false)\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by simp"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "case (Proc_CFG_WhileBody c' n et' n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c' l). state_val s V = state_val s' V\\<rbrakk> \n      \\<Longrightarrow> CFG.pred et s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "from \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + 2\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 2\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "from \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "then"], ["proof (chain)\npicking this:\n  l' < #:c'", "obtain cx where \"labels c' l' cx\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. (\\<And>cx. labels c' l' cx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c' l' cx\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 2\n  labels c' l' cx", "have \"labels (while (b) c') l (cx;;while (b) c')\""], ["proof (prove)\nusing this:\n  l = l' + 2\n  labels c' l' cx\n\ngoal (1 subgoal):\n 1. labels (while (b) c') l (cx;; while (b) c')", "by(fastforce intro:Labels_WhileBody)"], ["proof (state)\nthis:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>labels c' l' cx\\<close> \\<open>\\<forall>V\\<in>rhs (label (while (b) c') l). \n      state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')", "have \"\\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (8 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta n' b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label l;\n        IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 8. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by (rule IH)"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "case (Proc_CFG_WhileBodyExit c' n et' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n  n \\<noteq> Entry\n  n \\<oplus> 2 = Label l\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "note IH = \\<open>\\<And>l. \\<lbrakk>n = Label l; IEdge et = et';\n      \\<forall>V\\<in>rhs (label c' l). state_val s V = state_val s' V\\<rbrakk> \n      \\<Longrightarrow> CFG.pred et s'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n = Label ?l; IEdge et = et';\n   \\<forall>V\\<in>rhs (label c' ?l). state_val s V = state_val s' V\\<rbrakk>\n  \\<Longrightarrow> ProcCFG.pred et s'\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "from \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' where \"n = Label l'\" and \"l = l' + 2\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>n = Label l'; l = l' + 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n  l = l' + 2\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "from \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\\<close> \\<open>n = Label l'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n  n = Label l'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n  n = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "then"], ["proof (chain)\npicking this:\n  l' < #:c'", "obtain cx where \"labels c' l' cx\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. (\\<And>cx. labels c' l' cx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels c' l' cx\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>l = l' + 2\\<close>"], ["proof (chain)\npicking this:\n  l = l' + 2\n  labels c' l' cx", "have \"labels (while (b) c') l (cx;;while (b) c')\""], ["proof (prove)\nusing this:\n  l = l' + 2\n  labels c' l' cx\n\ngoal (1 subgoal):\n 1. labels (while (b) c') l (cx;; while (b) c')", "by(fastforce intro:Labels_WhileBody)"], ["proof (state)\nthis:\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>labels c' l' cx\\<close> \\<open>\\<forall>V\\<in>rhs (label (while (b) c') l). \n      state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')", "have \"\\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  labels c' l' cx\n  \\<forall>V\\<in>rhs (label (while (b) c') l).\n     state_val s V = state_val s' V\n  labels (while (b) c') l (cx;; while (b) c')\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "by(fastforce dest:labels_label)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>c' n eta b l.\n       \\<lbrakk>c' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l.\n           \\<lbrakk>n = Label l; IEdge et = eta;\n            \\<forall>V\\<in>rhs (label c' l).\n               state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> ProcCFG.pred et s';\n        n \\<noteq> Entry; n \\<oplus> 2 = Label l; IEdge et = eta;\n        \\<forall>V\\<in>rhs (label (while (b) c') l).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 7. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "with \\<open>n = Label l'\\<close> \\<open>IEdge et = et'\\<close>"], ["proof (chain)\npicking this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  n = Label l'\n  IEdge et = et'\n  \\<forall>V\\<in>rhs (label c' l'). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred et s'", "by (rule IH)"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal (6 subgoals):\n 1. \\<lbrakk>IEdge et = IEdge \\<Up>id;\n     \\<forall>V\\<in>rhs (label Skip 0).\n        state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> ProcCFG.pred et s'\n 2. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        \\<forall>V\\<in>rhs (label (V:=e) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 3. \\<And>V e.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (V:=e) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 4. \\<And>b c'.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (while (b) c') 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 5. \\<And>p es rets.\n       \\<lbrakk>IEdge et = CEdge (p, es, rets);\n        \\<forall>V\\<in>rhs (label (Call p es rets) 0).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'\n 6. \\<And>p es rets.\n       \\<lbrakk>IEdge et = IEdge \\<Up>id;\n        \\<forall>V\\<in>rhs (label (Call p es rets) 1).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred et s'", "qed auto"], ["proof (state)\nthis:\n  ProcCFG.pred et s'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instantiating the \\<open>CFG_wf\\<close> locale\\<close>"], ["", "interpretation ProcCFG_wf:\n  CFG_wf sourcenode targetnode kind \"valid_edge wfp\" \"(Main,Entry)\"\n  get_proc \"get_return_edges wfp\" \"lift_procs wfp\" Main \n  \"Def wfp\" \"Use wfp\" \"ParamDefs wfp\" \"ParamUses wfp\"\n  for wfp"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Def wfp)\n     (Use wfp) (ParamDefs wfp) (ParamUses wfp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Def wfp)\n     (Use wfp) (ParamDefs wfp) (ParamUses wfp)", "from Rep_wf_prog[of wfp]"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp \\<in> wf_prog", "obtain prog procs where [simp]:\"Rep_wf_prog wfp = (prog,procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp \\<in> wf_prog\n\ngoal (1 subgoal):\n 1. (\\<And>prog procs.\n        Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:wf_prog_def)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. CFG_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Def wfp)\n     (Use wfp) (ParamDefs wfp) (ParamUses wfp)", "hence \"wf prog procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n\ngoal (1 subgoal):\n 1. WellFormProgs.wf prog procs", "by(rule wf_wf_prog)"], ["proof (state)\nthis:\n  WellFormProgs.wf prog procs\n\ngoal (1 subgoal):\n 1. CFG_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Def wfp)\n     (Use wfp) (ParamDefs wfp) (ParamUses wfp)", "hence wf:\"well_formed procs\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n\ngoal (1 subgoal):\n 1. well_formed procs", "by fastforce"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (1 subgoal):\n 1. CFG_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Def wfp)\n     (Use wfp) (ParamDefs wfp) (ParamUses wfp)", "show \"CFG_wf sourcenode targetnode kind (valid_edge wfp)\n    (Main, Entry) get_proc (get_return_edges wfp) (lift_procs wfp) Main \n    (Def wfp) (Use wfp) (ParamDefs wfp) (ParamUses wfp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Def wfp)\n     (Use wfp) (ParamDefs wfp) (ParamUses wfp)", "proof"], ["proof (state)\ngoal (17 subgoals):\n 1. Def wfp (Main, Entry) = {} \\<and> Use wfp (Main, Entry) = {}\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 5. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 6. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 8. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 9. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 10. \\<And>a V s.\n        \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n         intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n        \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                          state_val s V\nA total of 17 subgoals...", "from Entry_Def_empty Entry_Use_empty"], ["proof (chain)\npicking this:\n  Def ?wfp (Main, Entry) = {}\n  Use ?wfp (Main, Entry) = {}", "show \"Def wfp (Main, Entry) = {} \\<and> Use wfp (Main, Entry) = {}\""], ["proof (prove)\nusing this:\n  Def ?wfp (Main, Entry) = {}\n  Use ?wfp (Main, Entry) = {}\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Entry) = {} \\<and> Use wfp (Main, Entry) = {}", "by simp"], ["proof (state)\nthis:\n  Def wfp (Main, Entry) = {} \\<and> Use wfp (Main, Entry) = {}\n\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 9. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a;\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         intra_kind (kind a); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                             state_val (ProcCFG.transfer wfp (kind a) s) V =\n                             state_val (ProcCFG.transfer wfp (kind a) s') V\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 9. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a;\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         intra_kind (kind a); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                             state_val (ProcCFG.transfer wfp (kind a) s) V =\n                             state_val (ProcCFG.transfer wfp (kind a) s') V\nA total of 16 subgoals...", "fix a Q r p fs ins outs"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 9. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a;\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         intra_kind (kind a); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                             state_val (ProcCFG.transfer wfp (kind a) s) V =\n                             state_val (ProcCFG.transfer wfp (kind a) s') V\nA total of 16 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \n      and \"(p, ins, outs) \\<in> set (lift_procs wfp)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 9. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a;\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         intra_kind (kind a); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                             state_val (ProcCFG.transfer wfp (kind a) s) V =\n                             state_val (ProcCFG.transfer wfp (kind a) s') V\nA total of 16 subgoals...", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 9. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a;\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         intra_kind (kind a); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                             state_val (ProcCFG.transfer wfp (kind a) s) V =\n                             state_val (ProcCFG.transfer wfp (kind a) s') V\nA total of 16 subgoals...", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)", "show \"length (ParamUses wfp (sourcenode a)) = length ins\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. length (ParamUses wfp (sourcenode a)) = length ins", "proof(induct n\\<equiv>\"sourcenode a\" et\\<equiv>\"kind a\" n'\\<equiv>\"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "case (MainCall l p' es rets n' insx outsx cx)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)", "have [simp]:\"insx = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. insx = ins", "by fastforce"], ["proof (state)\nthis:\n  insx = ins\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"containsCall procs prog [] p'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] p'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "with \\<open>wf prog procs\\<close> \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close> \n        \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', insx, outsx, cx) \\<in> set procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog [] p'", "have \"length es = length ins\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', insx, outsx, cx) \\<in> set procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog [] p'\n\ngoal (1 subgoal):\n 1. length es = length ins", "by fastforce"], ["proof (state)\nthis:\n  length es = length ins\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"ParamUses wfp (Main, Label l) = map fv es\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamUses wfp (Main, Label l) = map fv es", "by(fastforce intro:ParamUses_Main_Return_target)"], ["proof (state)\nthis:\n  ParamUses wfp (Main, Label l) = map fv es\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "with \\<open>(Main, Label l) = sourcenode a\\<close> \\<open>length es = length ins\\<close>"], ["proof (chain)\npicking this:\n  (Main, Label l) = sourcenode a\n  length es = length ins\n  ParamUses wfp (Main, Label l) = map fv es", "show ?case"], ["proof (prove)\nusing this:\n  (Main, Label l) = sourcenode a\n  length es = length ins\n  ParamUses wfp (Main, Label l) = map fv es\n\ngoal (1 subgoal):\n 1. length (ParamUses wfp (sourcenode a)) = length ins", "by simp"], ["proof (state)\nthis:\n  length (ParamUses wfp (sourcenode a)) = length ins\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "case (ProcCall px insx outsx cx l p' es rets l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)", "have [simp]:\"ins' = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. ins' = ins", "by fastforce"], ["proof (state)\nthis:\n  ins' = ins\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "from \\<open>cx \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs cx [] p'\""], ["proof (prove)\nusing this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs cx [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs cx [] p'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "with \\<open>containsCall procs prog ps px\\<close> \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p'", "have \"containsCall procs prog (ps@[px]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [px]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "with \\<open>wf prog procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n        \\<open>cx \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'", "have \"length es = length ins\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. length es = length ins", "by fastforce"], ["proof (state)\nthis:\n  length es = length ins\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "from \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close>\n        \\<open>cx \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"ParamUses wfp (px,Label l) = map fv es\""], ["proof (prove)\nusing this:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. ParamUses wfp (px, Label l) = map fv es", "by(fastforce intro:ParamUses_Proc_Return_target simp:set_conv_nth)"], ["proof (state)\nthis:\n  ParamUses wfp (px, Label l) = map fv es\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "with \\<open>(px, Label l) = sourcenode a\\<close> \\<open>length es = length ins\\<close>"], ["proof (chain)\npicking this:\n  (px, Label l) = sourcenode a\n  length es = length ins\n  ParamUses wfp (px, Label l) = map fv es", "show ?case"], ["proof (prove)\nusing this:\n  (px, Label l) = sourcenode a\n  length es = length ins\n  ParamUses wfp (px, Label l) = map fv es\n\ngoal (1 subgoal):\n 1. length (ParamUses wfp (sourcenode a)) = length ins", "by simp"], ["proof (state)\nthis:\n  length (ParamUses wfp (sourcenode a)) = length ins\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 3. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins\n 6. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamUses wfp (sourcenode a)) = length ins", "qed auto"], ["proof (state)\nthis:\n  length (ParamUses wfp (sourcenode a)) = length ins\n\ngoal (15 subgoals):\n 1. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n         snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred (kind a) s'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n         snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred (kind a) s'\nA total of 15 subgoals...", "fix a"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n         snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred (kind a) s'\nA total of 15 subgoals...", "assume \"valid_edge wfp a\""], ["proof (state)\nthis:\n  valid_edge wfp a\n\ngoal (15 subgoals):\n 1. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n         snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred (kind a) s'\nA total of 15 subgoals...", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (15 subgoals):\n 1. \\<And>a.\n       valid_edge wfp a \\<Longrightarrow>\n       distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n         snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>Use wfp (sourcenode a).\n            state_val s V = state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.pred (kind a) s'\nA total of 15 subgoals...", "thus \"distinct (ParamDefs wfp (targetnode a))\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (Main n n')"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = sourcenode a\n  (Main, n') = targetnode a\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(Main, n') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (Main, n') = targetnode a", "have \"ParamDefs wfp (Main,n') = []\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (Main, n') = targetnode a\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (Main, n') = []", "by(fastforce intro:ParamDefs_Main_IEdge_Nil)"], ["proof (state)\nthis:\n  ParamDefs wfp (Main, n') = []\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>(Main, n') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (Main, n') = targetnode a\n  ParamDefs wfp (Main, n') = []", "show ?case"], ["proof (prove)\nusing this:\n  (Main, n') = targetnode a\n  ParamDefs wfp (Main, n') = []\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by simp"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (Proc p ins outs c n n')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps_ p\n  (p, n) = sourcenode a\n  (p, n') = targetnode a\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'", "have \"ParamDefs wfp (p,n') = []\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = []", "by(fastforce intro:ParamDefs_Proc_IEdge_Nil)"], ["proof (state)\nthis:\n  ParamDefs wfp (p, n') = []\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>(p, n') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  (p, n') = targetnode a\n  ParamDefs wfp (p, n') = []", "show ?case"], ["proof (prove)\nusing this:\n  (p, n') = targetnode a\n  ParamDefs wfp (p, n') = []\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by simp"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (MainCall l p es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  kind a\n  (p, Entry) = targetnode a\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>(p, ins, outs, c) \\<in> set procs\\<close> wf"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  kind a\n  (p, Entry) = targetnode a", "have [simp]:\"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  kind a\n  (p, Entry) = targetnode a\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from wf \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have \"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>(p, Entry) = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (p, Entry)\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "show ?case"], ["proof (prove)\nusing this:\n  targetnode a = (p, Entry)\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by(auto simp:ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (ProcCall p ins outs c l p' es' rets' l' ins' outs' c')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>(p', ins', outs', c') \\<in> set procs\\<close> wf"], ["proof (chain)\npicking this:\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a", "have [simp]:\"p' \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n\ngoal (1 subgoal):\n 1. p' \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p' \\<noteq> Main\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from wf \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs", "have \"(THE cx. \\<exists>insx outsx. (p',insx,outsx,cx) \\<in> set procs) = c'\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE cx. \\<exists>insx outsx. (p', insx, outsx, cx) \\<in> set procs) =\n    c'", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE cx. \\<exists>insx outsx. (p', insx, outsx, cx) \\<in> set procs) = c'\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>(p', Entry) = targetnode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  targetnode a = (p', Entry)\n  (THE cx. \\<exists>insx outsx. (p', insx, outsx, cx) \\<in> set procs) = c'", "show ?case"], ["proof (prove)\nusing this:\n  targetnode a = (p', Entry)\n  (THE cx. \\<exists>insx outsx. (p', insx, outsx, cx) \\<in> set procs) = c'\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by(fastforce simp:ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (MainReturn l p es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs prog [] p\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] p", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] p\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>wf prog procs\\<close> \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \n        \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p, ins, outs, c) \\<in> set procs\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog [] p", "have \"distinct rets\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p, ins, outs, c) \\<in> set procs\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog [] p\n\ngoal (1 subgoal):\n 1. distinct rets", "by fastforce"], ["proof (state)\nthis:\n  distinct rets\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"ParamDefs wfp (Main,Label l') = rets\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (Main, Label l') = rets", "by(fastforce intro:ParamDefs_Main_Return_target)"], ["proof (state)\nthis:\n  ParamDefs wfp (Main, Label l') = rets\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>distinct rets\\<close> \\<open>(Main, Label l') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  distinct rets\n  (Main, Label l') = targetnode a\n  ParamDefs wfp (Main, Label l') = rets", "show ?case"], ["proof (prove)\nusing this:\n  distinct rets\n  (Main, Label l') = targetnode a\n  ParamDefs wfp (Main, Label l') = rets\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by(fastforce simp:distinct_map inj_on_def)"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (ProcReturn p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs c [] p'\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs c [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs c [] p'\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>containsCall procs prog ps p\\<close> \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'", "have \"containsCall procs prog (ps@[p]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [p]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [p]) p'\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>wf prog procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n        \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [p]) p'", "have \"distinct rets'\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [p]) p'\n\ngoal (1 subgoal):\n 1. distinct rets'", "by fastforce"], ["proof (state)\nthis:\n  distinct rets'\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close>\n        \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"ParamDefs wfp (p,Label l') = rets'\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, Label l') = rets'", "by(fastforce intro:ParamDefs_Proc_Return_target simp:set_conv_nth)"], ["proof (state)\nthis:\n  ParamDefs wfp (p, Label l') = rets'\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>distinct rets'\\<close> \\<open>(p, Label l') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  distinct rets'\n  (p, Label l') = targetnode a\n  ParamDefs wfp (p, Label l') = rets'", "show ?case"], ["proof (prove)\nusing this:\n  distinct rets'\n  (p, Label l') = targetnode a\n  ParamDefs wfp (p, Label l') = rets'\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by(fastforce simp:distinct_map inj_on_def)"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (MainCallReturn n p es rets n')"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, n') = targetnode a\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"containsCall procs prog [] p\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] p", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] p\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>wf prog procs\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  containsCall procs prog [] p", "obtain ins outs c where \"(p, ins, outs, c) \\<in> set procs\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  containsCall procs prog [] p\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs c.\n        (p, ins, outs, c) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add:wf_def) blast"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>wf prog procs\\<close> \\<open>containsCall procs prog [] p\\<close>\n        \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  containsCall procs prog [] p\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs", "have \"distinct rets\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  containsCall procs prog [] p\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. distinct rets", "by fastforce"], ["proof (state)\nthis:\n  distinct rets\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"ParamDefs wfp (Main,n') = rets\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (Main, n') = rets", "by(fastforce intro:ParamDefs_Main_Return_target)"], ["proof (state)\nthis:\n  ParamDefs wfp (Main, n') = rets\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>distinct rets\\<close> \\<open>(Main, n') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  distinct rets\n  (Main, n') = targetnode a\n  ParamDefs wfp (Main, n') = rets", "show ?case"], ["proof (prove)\nusing this:\n  distinct rets\n  (Main, n') = targetnode a\n  ParamDefs wfp (Main, n') = rets\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by(fastforce simp:distinct_map inj_on_def)"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "case (ProcCallReturn p ins outs c n p' es' rets' n' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  (p, n) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (p, n') = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'", "have \"containsCall procs c [] p'\""], ["proof (prove)\nusing this:\n  c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. containsCall procs c [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs c [] p'\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>Rep_wf_prog wfp = (prog,procs)\\<close> \\<open>(p, ins, outs, c) \\<in> set procs\\<close>\n        \\<open>containsCall procs prog ps p\\<close>"], ["proof (chain)\npicking this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p", "obtain wfp' where \"Rep_wf_prog wfp' = (c,procs)\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule wfp_Call)"], ["proof (state)\nthis:\n  Rep_wf_prog wfp' = (c, procs)\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "hence \"wf c procs\""], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp' = (c, procs)\n\ngoal (1 subgoal):\n 1. WellFormProgs.wf c procs", "by(rule wf_wf_prog)"], ["proof (state)\nthis:\n  WellFormProgs.wf c procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>containsCall procs c [] p'\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs c [] p'\n  WellFormProgs.wf c procs", "obtain ins' outs' c'\n        where \"(p', ins', outs', c') \\<in> set procs\""], ["proof (prove)\nusing this:\n  containsCall procs c [] p'\n  WellFormProgs.wf c procs\n\ngoal (1 subgoal):\n 1. (\\<And>ins' outs' c'.\n        (p', ins', outs', c') \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add:wf_def) blast"], ["proof (state)\nthis:\n  (p', ins', outs', c') \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>containsCall procs prog ps p\\<close> \\<open>(p, ins, outs, c) \\<in> set procs\\<close>\n        \\<open>containsCall procs c [] p'\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'", "have \"containsCall procs prog (ps@[p]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs c [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [p]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [p]) p'\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>wf prog procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n        \\<open>c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog (ps @ [p]) p'", "have \"distinct rets'\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog (ps @ [p]) p'\n\ngoal (1 subgoal):\n 1. distinct rets'", "by fastforce"], ["proof (state)\nthis:\n  distinct rets'\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'", "have \"ParamDefs wfp (p,n') = rets'\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n') = rets'", "by(fastforce intro:ParamDefs_Proc_Return_target)"], ["proof (state)\nthis:\n  ParamDefs wfp (p, n') = rets'\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (p, n') = targetnode a\\<rbrakk>\n       \\<Longrightarrow> distinct (ParamDefs wfp (targetnode a))", "with \\<open>distinct rets'\\<close> \\<open>(p, n') = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  distinct rets'\n  (p, n') = targetnode a\n  ParamDefs wfp (p, n') = rets'", "show ?case"], ["proof (prove)\nusing this:\n  distinct rets'\n  (p, n') = targetnode a\n  ParamDefs wfp (p, n') = rets'\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs wfp (targetnode a))", "by(fastforce simp:distinct_map inj_on_def)"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (ParamDefs wfp (targetnode a))\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "fix a Q' p f' ins outs"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n      and \"(p, ins, outs) \\<in> set (lift_procs wfp)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length (ParamDefs wfp (targetnode a)) = length outs\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "thus \"length (ParamDefs wfp (targetnode a)) = length outs\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. length (ParamDefs wfp (targetnode a)) = length outs", "by(rule ParamDefs_length)"], ["proof (state)\nthis:\n  length (ParamDefs wfp (targetnode a)) = length outs\n\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         valid_edge wfp a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         valid_edge wfp a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "fix n V"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         valid_edge wfp a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "assume \"CFG.valid_node sourcenode targetnode (valid_edge wfp) n\"\n      and \"V \\<in> set (ParamDefs wfp n)\""], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp n\n  V \\<in> set (ParamDefs wfp n)\n\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> set (ParamDefs wfp n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         valid_edge wfp a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "thus \"V \\<in> Def wfp n\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp n\n  V \\<in> set (ParamDefs wfp n)\n\ngoal (1 subgoal):\n 1. V \\<in> Def wfp n", "by(simp add:Def_def)"], ["proof (state)\nthis:\n  V \\<in> Def wfp n\n\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s';\n         \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                          ProcCFG.params fs (state_val s') ! i\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s';\n         \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                          ProcCFG.params fs (state_val s') ! i\nA total of 12 subgoals...", "fix a Q r p fs ins outs V"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s';\n         \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                          ProcCFG.params fs (state_val s') ! i\nA total of 12 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"(p, ins, outs) \\<in> set (lift_procs wfp)\" and \"V \\<in> set ins\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins\n\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s';\n         \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                          ProcCFG.params fs (state_val s') ! i\nA total of 12 subgoals...", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n         ProcCFG.pred (kind a) s';\n         \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n            state_val s V = state_val s' V\\<rbrakk>\n        \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                          ProcCFG.params fs (state_val s') ! i\nA total of 12 subgoals...", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close> \\<open>V \\<in> set ins\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins", "show \"V \\<in> Def wfp (targetnode a)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. V \\<in> Def wfp (targetnode a)", "proof(induct n\\<equiv>\"sourcenode a\" et\\<equiv>\"kind a\" n'\\<equiv>\"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "case (MainCall l p' es rets n' insx outsx cx)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins", "have [simp]:\"insx = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. insx = ins", "by fastforce"], ["proof (state)\nthis:\n  insx = ins\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "from wf \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p', insx, outsx, cx) \\<in> set procs", "have \"(THE ins'. \\<exists>c' outs'. (p',ins',outs',c') \\<in> set procs) = \n        insx\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p', insx, outsx, cx) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE ins'. \\<exists>c' outs'. (p', ins', outs', c') \\<in> set procs) =\n    insx", "by(rule in_procs_THE_in_procs_ins)"], ["proof (state)\nthis:\n  (THE ins'. \\<exists>c' outs'. (p', ins', outs', c') \\<in> set procs) =\n  insx\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "with \\<open>(p', Entry) = targetnode a\\<close>[THEN sym] \\<open>V \\<in> set ins\\<close>\n        \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (p', Entry)\n  V \\<in> set ins\n  (p', insx, outsx, cx) \\<in> set procs\n  (THE ins'. \\<exists>c' outs'. (p', ins', outs', c') \\<in> set procs) =\n  insx", "show ?case"], ["proof (prove)\nusing this:\n  targetnode a = (p', Entry)\n  V \\<in> set ins\n  (p', insx, outsx, cx) \\<in> set procs\n  (THE ins'. \\<exists>c' outs'. (p', ins', outs', c') \\<in> set procs) =\n  insx\n\ngoal (1 subgoal):\n 1. V \\<in> Def wfp (targetnode a)", "by(auto simp:Def_def)"], ["proof (state)\nthis:\n  V \\<in> Def wfp (targetnode a)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "case (ProcCall px insx outsx cx l p' es rets l' ins' outs' c')"], ["proof (state)\nthis:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins", "have [simp]:\"ins' = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. ins' = ins", "by fastforce"], ["proof (state)\nthis:\n  ins' = ins\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "from wf \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs", "have \"(THE insx. \\<exists>cx outsx. (p',insx,outsx,cx) \\<in> set procs) = \n        ins'\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE insx. \\<exists>cx outsx. (p', insx, outsx, cx) \\<in> set procs) =\n    ins'", "by(rule in_procs_THE_in_procs_ins)"], ["proof (state)\nthis:\n  (THE insx. \\<exists>cx outsx. (p', insx, outsx, cx) \\<in> set procs) =\n  ins'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "with \\<open>(p', Entry) = targetnode a\\<close>[THEN sym] \\<open>V \\<in> set ins\\<close>\n        \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (p', Entry)\n  V \\<in> set ins\n  (p', ins', outs', c') \\<in> set procs\n  (THE insx. \\<exists>cx outsx. (p', insx, outsx, cx) \\<in> set procs) =\n  ins'", "show ?case"], ["proof (prove)\nusing this:\n  targetnode a = (p', Entry)\n  V \\<in> set ins\n  (p', ins', outs', c') \\<in> set procs\n  (THE insx. \\<exists>cx outsx. (p', insx, outsx, cx) \\<in> set procs) =\n  ins'\n\ngoal (1 subgoal):\n 1. V \\<in> Def wfp (targetnode a)", "by(auto simp:Def_def)"], ["proof (state)\nthis:\n  V \\<in> Def wfp (targetnode a)\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 3. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)\n 6. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Def wfp (targetnode a)", "qed auto"], ["proof (state)\nthis:\n  V \\<in> Def wfp (targetnode a)\n\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(ParamDefs wfp (targetnode a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(ParamDefs wfp (targetnode a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(ParamDefs wfp (targetnode a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(ParamDefs wfp (targetnode a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>valid_edge wfp a;\n         kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(ParamDefs wfp (targetnode a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show \"Def wfp (sourcenode a) = {}\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. Def wfp (sourcenode a) = {}", "proof(induct n\\<equiv>\"sourcenode a\" et\\<equiv>\"kind a\" n'\\<equiv>\"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "case (MainCall l p' es rets n' insx outsx cx)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "from \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym]\n        \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, Label l)\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"ParamDefs wfp (sourcenode a) = []\""], ["proof (prove)\nusing this:\n  sourcenode a = (Main, Label l)\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (sourcenode a) = []", "by(fastforce intro:ParamDefs_Main_CEdge_Nil)"], ["proof (state)\nthis:\n  ParamDefs wfp (sourcenode a) = []\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 8. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "with \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n        \\<open>(Main, Label l) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  sourcenode a = (Main, Label l)\n  ParamDefs wfp (sourcenode a) = []", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  sourcenode a = (Main, Label l)\n  ParamDefs wfp (sourcenode a) = []\n\ngoal (1 subgoal):\n 1. Def wfp (sourcenode a) = {}", "by(fastforce dest:Proc_CFG_Call_source_empty_lhs simp:Def_def)"], ["proof (state)\nthis:\n  Def wfp (sourcenode a) = {}\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "case (ProcCall px insx outsx cx l p' es' rets' l' ins' outs' c')"], ["proof (state)\nthis:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "from \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close> wf"], ["proof (chain)\npicking this:\n  (px, insx, outsx, cx) \\<in> set procs\n  well_formed procs", "have [simp]:\"px \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (px, insx, outsx, cx) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. px \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  px \\<noteq> Main\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "from \\<open>cx \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"lhs (label cx l) = {}\""], ["proof (prove)\nusing this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. lhs (label cx l) = {}", "by(rule Proc_CFG_Call_source_empty_lhs)"], ["proof (state)\nthis:\n  lhs (label cx l) = {}\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "from wf \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs", "have THE:\"(THE c'. \\<exists>ins' outs'. (px,ins',outs',c') \\<in> set procs) = cx\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (px, ins', outs', c') \\<in> set procs) =\n    cx", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (px, ins', outs', c') \\<in> set procs) = cx\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "with \\<open>(px, Label l) = sourcenode a\\<close>[THEN sym]\n        \\<open>cx \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>  wf"], ["proof (chain)\npicking this:\n  sourcenode a = (px, Label l)\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  well_formed procs\n  (THE c'. \\<exists>ins' outs'. (px, ins', outs', c') \\<in> set procs) = cx", "have \"ParamDefs wfp (sourcenode a) = []\""], ["proof (prove)\nusing this:\n  sourcenode a = (px, Label l)\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  well_formed procs\n  (THE c'. \\<exists>ins' outs'. (px, ins', outs', c') \\<in> set procs) = cx\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (sourcenode a) = []", "by(fastforce dest:Proc_CFG_Call_targetnode_no_Call_sourcenode\n        [of _ _ _ _ _ \"Label l\"] simp:ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  ParamDefs wfp (sourcenode a) = []\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 7. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "with \\<open>(px, Label l) = sourcenode a\\<close>[THEN sym] \\<open>lhs (label cx l) = {}\\<close> THE"], ["proof (chain)\npicking this:\n  sourcenode a = (px, Label l)\n  lhs (label cx l) = {}\n  (THE c'. \\<exists>ins' outs'. (px, ins', outs', c') \\<in> set procs) = cx\n  ParamDefs wfp (sourcenode a) = []", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = (px, Label l)\n  lhs (label cx l) = {}\n  (THE c'. \\<exists>ins' outs'. (px, ins', outs', c') \\<in> set procs) = cx\n  ParamDefs wfp (sourcenode a) = []\n\ngoal (1 subgoal):\n 1. Def wfp (sourcenode a) = {}", "by(auto simp:Def_def)"], ["proof (state)\nthis:\n  Def wfp (sourcenode a) = {}\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 3. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 4. \\<And>pa ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}\n 6. \\<And>pa ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> Def wfp (sourcenode a) = {}", "qed auto"], ["proof (state)\nthis:\n  Def wfp (sourcenode a) = {}\n\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n         intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             kind a = (Q)\\<^sub>\\<surd> \\<and>\n                             kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n         intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             kind a = (Q)\\<^sub>\\<surd> \\<and>\n                             kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "fix n V"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n         intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             kind a = (Q)\\<^sub>\\<surd> \\<and>\n                             kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"CFG.valid_node sourcenode targetnode (valid_edge wfp) n\"\n      and \"V \\<in> \\<Union>(set (ParamUses wfp n))\""], ["proof (state)\nthis:\n  ProcCFG.valid_node wfp n\n  V \\<in> \\<Union> (set (ParamUses wfp n))\n\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>ProcCFG.valid_node wfp n;\n        V \\<in> \\<Union> (set (ParamUses wfp n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n         sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n         intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             kind a = (Q)\\<^sub>\\<surd> \\<and>\n                             kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"V \\<in> Use wfp n\""], ["proof (prove)\nusing this:\n  ProcCFG.valid_node wfp n\n  V \\<in> \\<Union> (set (ParamUses wfp n))\n\ngoal (1 subgoal):\n 1. V \\<in> Use wfp n", "by(fastforce simp:Use_def)"], ["proof (state)\nthis:\n  V \\<in> Use wfp n\n\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q p f ins outs V"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\"\n      and \"(p, ins, outs) \\<in> set (lift_procs wfp)\" and \"V \\<in> set outs\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs\n\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from this \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close> \\<open>V \\<in> set outs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs", "show \"V \\<in> Use wfp (sourcenode a)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. V \\<in> Use wfp (sourcenode a)", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "case (MainReturn l p' es rets l' insx outsx cx)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', insx, outsx, cx) \\<in> set procs\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outsx) =\n  kind a\n  (Main, Label l') = targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', insx, outsx, cx) \\<in> set procs\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outsx) =\n  kind a\n  (Main, Label l') = targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs", "have [simp]:\"outsx = outs\""], ["proof (prove)\nusing this:\n  well_formed procs\n  prog \\<turnstile> Label\n                     l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', insx, outsx, cx) \\<in> set procs\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n         map cf outsx) =\n  kind a\n  (Main, Label l') = targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. outsx = outs", "by fastforce"], ["proof (state)\nthis:\n  outsx = outs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "from wf \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p', insx, outsx, cx) \\<in> set procs", "have \"(THE outs'. \\<exists>c' ins'. (p',ins',outs',c') \\<in> set procs) = \n        outsx\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p', insx, outsx, cx) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE outs'. \\<exists>c' ins'. (p', ins', outs', c') \\<in> set procs) =\n    outsx", "by(rule in_procs_THE_in_procs_outs)"], ["proof (state)\nthis:\n  (THE outs'. \\<exists>c' ins'. (p', ins', outs', c') \\<in> set procs) =\n  outsx\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "with \\<open>(p', Exit) = sourcenode a\\<close>[THEN sym] \\<open>V \\<in> set outs\\<close>\n        \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p', Exit)\n  V \\<in> set outs\n  (p', insx, outsx, cx) \\<in> set procs\n  (THE outs'. \\<exists>c' ins'. (p', ins', outs', c') \\<in> set procs) =\n  outsx", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = (p', Exit)\n  V \\<in> set outs\n  (p', insx, outsx, cx) \\<in> set procs\n  (THE outs'. \\<exists>c' ins'. (p', ins', outs', c') \\<in> set procs) =\n  outsx\n\ngoal (1 subgoal):\n 1. V \\<in> Use wfp (sourcenode a)", "by(auto simp:Use_def)"], ["proof (state)\nthis:\n  V \\<in> Use wfp (sourcenode a)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "case (ProcReturn px insx outsx cx l p' es' rets' l' ins' outs' c')"], ["proof (state)\nthis:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ px\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n         map cf outs') =\n  kind a\n  (px, Label l') = targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ px\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n         map cf outs') =\n  kind a\n  (px, Label l') = targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs", "have [simp]:\"outs' = outs\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ px\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (px,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' [:=]\n         map cf outs') =\n  kind a\n  (px, Label l') = targetnode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. outs' = outs", "by fastforce"], ["proof (state)\nthis:\n  outs' = outs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "from wf \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs", "have \"(THE outsx. \\<exists>cx insx. (p',insx,outsx,cx) \\<in> set procs) = \n        outs'\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p', ins', outs', c') \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE outsx. \\<exists>cx insx. (p', insx, outsx, cx) \\<in> set procs) =\n    outs'", "by(rule in_procs_THE_in_procs_outs)"], ["proof (state)\nthis:\n  (THE outsx. \\<exists>cx insx. (p', insx, outsx, cx) \\<in> set procs) =\n  outs'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "with \\<open>(p', Exit) = sourcenode a\\<close>[THEN sym] \\<open>V \\<in> set outs\\<close>\n        \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p', Exit)\n  V \\<in> set outs\n  (p', ins', outs', c') \\<in> set procs\n  (THE outsx. \\<exists>cx insx. (p', insx, outsx, cx) \\<in> set procs) =\n  outs'", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = (p', Exit)\n  V \\<in> set outs\n  (p', ins', outs', c') \\<in> set procs\n  (THE outsx. \\<exists>cx insx. (p', insx, outsx, cx) \\<in> set procs) =\n  outs'\n\ngoal (1 subgoal):\n 1. V \\<in> Use wfp (sourcenode a)", "by(auto simp:Use_def)"], ["proof (state)\nthis:\n  V \\<in> Use wfp (sourcenode a)\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)\n 6. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set (lift_procs wfp); V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> Use wfp (sourcenode a)", "qed auto"], ["proof (state)\nthis:\n  V \\<in> Use wfp (sourcenode a)\n\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a V s"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"V \\<notin> Def wfp (sourcenode a)\"\n      and \"intra_kind (kind a)\" and \"CFG.pred (kind a) s\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>valid_edge wfp a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from this \\<open>V \\<notin> Def wfp (sourcenode a)\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>CFG.pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s", "show \"state_val (CFG.transfer (lift_procs wfp) (kind a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "case (Main n n')"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = sourcenode a\n  (Main, n') = targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "from \\<open>CFG.pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred (kind a) s", "obtain cf cfs where \"s = cf#cfs\""], ["proof (prove)\nusing this:\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>V \\<notin> Def wfp (sourcenode a)\\<close> \\<open>(Main, n) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> Def wfp (sourcenode a)\n  (Main, n) = sourcenode a\n  n = Label l", "have \"V \\<notin> lhs (label prog l)\""], ["proof (prove)\nusing this:\n  V \\<notin> Def wfp (sourcenode a)\n  (Main, n) = sourcenode a\n  n = Label l\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label prog l)", "by(fastforce simp:Def_def)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label prog l)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  V \\<notin> lhs (label prog l)", "have \"state_val (CFG.transfer (lift_procs wfp) (kind a) (cf#cfs)) V = fst cf V\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  V \\<notin> lhs (label prog l)\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V", "by(fastforce intro:Proc_CFG_edge_no_lhs_equal)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>s = cf#cfs\\<close>"], ["proof (chain)\npicking this:\n  s = cf # cfs\n  state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V", "show ?thesis"], ["proof (prove)\nusing this:\n  s = cf # cfs\n  state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by simp"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>s = cf#cfs\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  s = cf # cfs\n  n = Entry", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  s = cf # cfs\n  n = Entry\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by(fastforce dest:Proc_CFG_EntryD simp:transfers_simps[of wfp,simplified])"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit", "have False"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by simp"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "case (Proc p ins outs c n n')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps_ p\n  (p, n) = sourcenode a\n  (p, n') = targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "from \\<open>CFG.pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred (kind a) s", "obtain cf cfs where \"s = cf#cfs\""], ["proof (prove)\nusing this:\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "from wf \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have THE1:\"(THE ins'. \\<exists>c' outs'. (p,ins',outs',c') \\<in> set procs) = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE ins'. \\<exists>c' outs'. (p, ins', outs', c') \\<in> set procs) =\n    ins", "by(rule in_procs_THE_in_procs_ins)"], ["proof (state)\nthis:\n  (THE ins'. \\<exists>c' outs'. (p, ins', outs', c') \\<in> set procs) = ins\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "from wf \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have THE2:\"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(rule in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "from wf \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have [simp]:\"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>V \\<notin> Def wfp (sourcenode a)\\<close> \\<open>(p, n) = sourcenode a\\<close>\n          \\<open>(p, ins, outs, c) \\<in> set procs\\<close> wf THE1 THE2"], ["proof (chain)\npicking this:\n  V \\<notin> Def wfp (sourcenode a)\n  (p, n) = sourcenode a\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (THE ins'. \\<exists>c' outs'. (p, ins', outs', c') \\<in> set procs) = ins\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  n = Label l", "have \"V \\<notin> lhs (label c l)\""], ["proof (prove)\nusing this:\n  V \\<notin> Def wfp (sourcenode a)\n  (p, n) = sourcenode a\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  (THE ins'. \\<exists>c' outs'. (p, ins', outs', c') \\<in> set procs) = ins\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  n = Label l\n\ngoal (1 subgoal):\n 1. V \\<notin> lhs (label c l)", "by(fastforce simp:Def_def split:if_split_asm)"], ["proof (state)\nthis:\n  V \\<notin> lhs (label c l)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  V \\<notin> lhs (label c l)", "have \"state_val (CFG.transfer (lift_procs wfp) (kind a) (cf#cfs)) V = fst cf V\""], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  V \\<notin> lhs (label c l)\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V", "by(fastforce intro:Proc_CFG_edge_no_lhs_equal)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 3. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>s = cf#cfs\\<close>"], ["proof (chain)\npicking this:\n  s = cf # cfs\n  state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V", "show ?thesis"], ["proof (prove)\nusing this:\n  s = cf # cfs\n  state_val (ProcCFG.transfer wfp (kind a) (cf # cfs)) V = fst cf V\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by simp"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n 2. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>s = cf#cfs\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  s = cf # cfs\n  n = Entry", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  s = cf # cfs\n  n = Entry\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by(fastforce dest:Proc_CFG_EntryD simp:transfers_simps[of wfp,simplified])"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit", "have False"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by simp"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "case MainCallReturn"], ["proof (state)\nthis:\n  prog \\<turnstile> n_ -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p n'_\n  (Main, n_) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, n'_) = targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n_ -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p n'_\n  (Main, n_) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (Main, n'_) = targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by(cases s,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "case ProcCallReturn"], ["proof (state)\nthis:\n  (p_, ins_, outs_, c_) \\<in> set procs\n  c_ \\<turnstile> n_ -CEdge (p'_, es'_, rets'_)\\<rightarrow>\\<^sub>p n'_\n  containsCall procs prog ps_ p_\n  (p_, n_) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (p_, n'_) = targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        V \\<notin> Def wfp (sourcenode a); intra_kind (kind a);\n        ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "thus ?case"], ["proof (prove)\nusing this:\n  (p_, ins_, outs_, c_) \\<in> set procs\n  c_ \\<turnstile> n_ -CEdge (p'_, es'_, rets'_)\\<rightarrow>\\<^sub>p n'_\n  containsCall procs prog ps_ p_\n  (p_, n_) = sourcenode a\n  (\\<lambda>s. False)\\<^sub>\\<surd> = kind a\n  (p_, n'_) = targetnode a\n  V \\<notin> Def wfp (sourcenode a)\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V", "by(cases s,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; V \\<notin> Def wfp (sourcenode a);\n        intra_kind (kind a); ProcCFG.pred (kind a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (ProcCFG.transfer wfp (kind a) s) V =\n                         state_val s V", "qed(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  state_val (ProcCFG.transfer wfp (kind a) s) V = state_val s V\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a s s'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" \n      and \"\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\"\n      and \"intra_kind (kind a)\" and \"CFG.pred (kind a) s\" and \"CFG.pred (kind a) s'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  intra_kind (kind a)\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>CFG.pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred (kind a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>CFG.pred (kind a) s'\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred (kind a) s'", "obtain cf' cfs' where [simp]:\"s' = cf'#cfs'\""], ["proof (prove)\nusing this:\n  ProcCFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        s' = cf' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s') auto"], ["proof (state)\nthis:\n  s' = cf' # cfs'\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        intra_kind (kind a); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\\<close> \\<open>intra_kind (kind a)\\<close>\n      \\<open>\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\\<close>\n      \\<open>CFG.pred (kind a) s\\<close> \\<open>CFG.pred (kind a) s'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  intra_kind (kind a)\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'", "show \"\\<forall>V\\<in>Def wfp (sourcenode a). \n      state_val (CFG.transfer (lift_procs wfp) (kind a) s) V =\n      state_val (CFG.transfer (lift_procs wfp) (kind a) s') V\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  intra_kind (kind a)\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V", "case (Main n n')"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = sourcenode a\n  (Main, n') = targetnode a\n  intra_kind (kind a)\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with \\<open>\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\\<close>\n          \\<open>(Main, n) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  sourcenode a = (Main, n)\n  n = Label l", "have rhs:\"\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\"\n          and PDef:\"\\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)). \n          state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  sourcenode a = (Main, n)\n  n = Label l\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V &&&\n    \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n       state_val s V = state_val s' V", "by(auto simp:Use_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val s V = state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "from rhs \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l\\<close> \\<open>CFG.pred (kind a) s\\<close> \n          \\<open>CFG.pred (kind a) s'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'", "have lhs:\"\\<forall>V\\<in>lhs (label prog l). \n          state_val (CFG.transfer (lift_procs wfp) (kind a) s) V =\n          state_val (CFG.transfer (lift_procs wfp) (kind a) s') V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label prog l).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by -(rule Proc_CFG_edge_uses_only_rhs,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label prog l).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "from PDef \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(Main, n) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val s V = state_val s' V\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  sourcenode a = (Main, n)", "have \"\\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)). \n          state_val (CFG.transfer (lift_procs wfp) (kind a) s) V =\n          state_val (CFG.transfer (lift_procs wfp) (kind a) s') V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val s V = state_val s' V\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  sourcenode a = (Main, n)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by(fastforce dest:Proc_CFG_Call_follows_id_edge \n            simp:ParamDefs_def ParamDefs_proc_def transfers_simps[of wfp,simplified]\n            split:if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with lhs \\<open>(Main, n) = sourcenode a\\<close>[THEN sym] Label"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>lhs (label prog l).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n  sourcenode a = (Main, n)\n  n = Label l\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>lhs (label prog l).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n  sourcenode a = (Main, n)\n  n = Label l\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by(fastforce simp:Def_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with \\<open>(Main, n) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  sourcenode a = (Main, n)\n  n = Entry", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (Main, n)\n  n = Entry\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by(fastforce simp:Entry_Def_empty)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit", "have False"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V", "case (Proc p ins outs c n n')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps_ p\n  (p, n) = sourcenode a\n  (p, n') = targetnode a\n  intra_kind (kind a)\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with \\<open>\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\\<close> wf\n          \\<open>(p, n) = sourcenode a\\<close>[THEN sym] \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  well_formed procs\n  sourcenode a = (p, n)\n  (p, ins, outs, c) \\<in> set procs\n  n = Label l", "have rhs:\"\\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V\"\n          and PDef:\"\\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)). \n          state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  well_formed procs\n  sourcenode a = (p, n)\n  (p, ins, outs, c) \\<in> set procs\n  n = Label l\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V &&&\n    \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n       state_val s V = state_val s' V", "by(auto dest:in_procs_THE_in_procs_cmd simp:Use_def split:if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val s V = state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "from rhs \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = Label l\\<close> \\<open>CFG.pred (kind a) s\\<close> \n          \\<open>CFG.pred (kind a) s'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'", "have lhs:\"\\<forall>V\\<in>lhs (label c l). \n          state_val (CFG.transfer (lift_procs wfp) (kind a) s) V =\n          state_val (CFG.transfer (lift_procs wfp) (kind a) s') V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  ProcCFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lhs (label c l).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by -(rule Proc_CFG_edge_uses_only_rhs,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lhs (label c l).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "from \\<open>(p, ins, outs, c) \\<in> set procs\\<close> wf"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have [simp]:\"p \\<noteq> Main\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. p \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  p \\<noteq> Main\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "from wf \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs", "have THE:\"(THE c'. \\<exists>ins' outs'. (p,ins',outs',c') \\<in> set procs) = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "by(fastforce intro:in_procs_THE_in_procs_cmd)"], ["proof (state)\nthis:\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with PDef \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(p, n) = sourcenode a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val s V = state_val s' V\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  sourcenode a = (p, n)\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c", "have \"\\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)). \n          state_val (CFG.transfer (lift_procs wfp) (kind a) s) V =\n          state_val (CFG.transfer (lift_procs wfp) (kind a) s') V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val s V = state_val s' V\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  sourcenode a = (p, n)\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by(fastforce dest:Proc_CFG_Call_follows_id_edge \n            simp:ParamDefs_def ParamDefs_proc_def transfers_simps[of wfp,simplified]\n            split:if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Label x1 \\<Longrightarrow>\n       \\<forall>V\\<in>Def wfp (sourcenode a).\n          state_val (ProcCFG.transfer wfp (kind a) s) V =\n          state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with lhs \\<open>(p, n) = sourcenode a\\<close>[THEN sym] Label THE"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>lhs (label c l).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n  sourcenode a = (p, n)\n  n = Label l\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>lhs (label c l).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n  sourcenode a = (p, n)\n  n = Label l\n  (THE c'. \\<exists>ins' outs'. (p, ins', outs', c') \\<in> set procs) = c\n  \\<forall>V\\<in>set (ParamDefs wfp (sourcenode a)).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by(auto simp:Def_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with wf \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  n = Entry", "have \"ParamDefs wfp (p,n) = []\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  n = Entry\n\ngoal (1 subgoal):\n 1. ParamDefs wfp (p, n) = []", "by(fastforce simp:ParamDefs_def ParamDefs_proc_def)"], ["proof (state)\nthis:\n  ParamDefs wfp (p, n) = []\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "moreover"], ["proof (state)\nthis:\n  ParamDefs wfp (p, n) = []\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "from Entry \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  n = Entry\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs", "have \"ParamUses wfp (p,n) = []\""], ["proof (prove)\nusing this:\n  n = Entry\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. ParamUses wfp (p, n) = []", "by(fastforce intro:ParamUses_Proc_IEdge_Nil)"], ["proof (state)\nthis:\n  ParamUses wfp (p, n) = []\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "ultimately"], ["proof (chain)\npicking this:\n  ParamDefs wfp (p, n) = []\n  ParamUses wfp (p, n) = []", "have \"\\<forall>V\\<in>set ins. state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  ParamDefs wfp (p, n) = []\n  ParamUses wfp (p, n) = []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set ins. state_val s V = state_val s' V", "using wf \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p,n) = sourcenode a\\<close>\n          \\<open>\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\\<close>  Entry"], ["proof (prove)\nusing this:\n  ParamDefs wfp (p, n) = []\n  ParamUses wfp (p, n) = []\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, n) = sourcenode a\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  n = Entry\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set ins. state_val s V = state_val s' V", "by(fastforce dest:in_procs_THE_in_procs_ins simp:Use_def split:if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>set ins. state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> Entry"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Entry\n  \\<forall>V\\<in>set ins. state_val s V = state_val s' V", "have \"\\<forall>V\\<in>set ins. state_val (CFG.transfer (lift_procs wfp) (kind a) s) V =\n          state_val (CFG.transfer (lift_procs wfp) (kind a) s') V\""], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Entry\n  \\<forall>V\\<in>set ins. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set ins.\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by(fastforce dest:Proc_CFG_EntryD simp:transfers_simps[of wfp,simplified])"], ["proof (state)\nthis:\n  \\<forall>V\\<in>set ins.\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with \\<open>(p,n) = sourcenode a\\<close>[THEN sym] Entry wf  \n          \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>ParamDefs wfp (p,n) = []\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = (p, n)\n  n = Entry\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  ParamDefs wfp (p, n) = []\n  \\<forall>V\\<in>set ins.\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (p, n)\n  n = Entry\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  ParamDefs wfp (p, n) = []\n  \\<forall>V\\<in>set ins.\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by(auto dest:in_procs_THE_in_procs_ins simp:Def_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit", "have False"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow>\n    \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def wfp (sourcenode a).\n       state_val (ProcCFG.transfer wfp (kind a) s) V =\n       state_val (ProcCFG.transfer wfp (kind a) s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        intra_kind (kind a);\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        ProcCFG.pred (kind a) s; ProcCFG.pred (kind a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Def wfp (sourcenode a).\n                            state_val (ProcCFG.transfer wfp (kind a) s) V =\n                            state_val (ProcCFG.transfer wfp (kind a) s') V", "qed(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def wfp (sourcenode a).\n     state_val (ProcCFG.transfer wfp (kind a) s) V =\n     state_val (ProcCFG.transfer wfp (kind a) s') V\n\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a s"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix s'::\"((char list \\<rightharpoonup> val) \\<times> node) list\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"CFG.pred (kind a) s\"\n      and \"\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\" \n      and \"length s = length s'\" and \"snd (hd s) = snd (hd s')\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>CFG.pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  ProcCFG.pred (kind a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  ProcCFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>length s = length s'\\<close>"], ["proof (chain)\npicking this:\n  length s = length s'", "obtain cf' cfs' where [simp]:\"s' = cf'#cfs'\""], ["proof (prove)\nusing this:\n  length s = length s'\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        s' = cf' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s') auto"], ["proof (state)\nthis:\n  s' = cf' # cfs'\n\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>valid_edge wfp a; ProcCFG.pred (kind a) s;\n        snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\\<close> \\<open>CFG.pred (kind a) s\\<close>\n      \\<open>\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\\<close>\n      \\<open>length s = length s'\\<close> \\<open>snd (hd s) = snd (hd s')\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')", "show \"CFG.pred (kind a) s'\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case (Main n n')"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = sourcenode a\n  (Main, n') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1. n = Label x1 \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1. n = Label x1 \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\\<close>\n          \\<open>(Main, n) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  (Main, n) = sourcenode a\n  n = Label l", "have \"\\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  (Main, n) = sourcenode a\n  n = Label l\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V", "by(fastforce simp:Use_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>x1. n = Label x1 \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> Label \\<open>CFG.pred (kind a) s\\<close>\n          \\<open>length s = length s'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  length s = length s'\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  length s = length s'\n  \\<forall>V\\<in>rhs (label prog l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by(fastforce intro:Proc_CFG_edge_rhs_pred_eq)"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>CFG.pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  ProcCFG.pred (kind a) s\n  n = Entry", "show ?thesis"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  ProcCFG.pred (kind a) s\n  n = Entry\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit", "have False"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by simp"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case (Proc p ins outs c n n')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps_ p\n  (p, n) = sourcenode a\n  (p, n') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (p, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1. n = Label x1 \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case (Label l)"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>x1. n = Label x1 \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>\\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\\<close> wf\n          \\<open>(p, n) = sourcenode a\\<close>[THEN sym] \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  well_formed procs\n  sourcenode a = (p, n)\n  (p, ins, outs, c) \\<in> set procs\n  n = Label l", "have \"\\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  well_formed procs\n  sourcenode a = (p, n)\n  (p, ins, outs, c) \\<in> set procs\n  n = Label l\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V", "by(auto dest:in_procs_THE_in_procs_cmd simp:Use_def split:if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>x1. n = Label x1 \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> Label \\<open>CFG.pred (kind a) s\\<close>\n          \\<open>length s = length s'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  length s = length s'\n  \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  ProcCFG.pred (kind a) s\n  length s = length s'\n  \\<forall>V\\<in>rhs (label c l). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by(fastforce intro:Proc_CFG_edge_rhs_pred_eq)"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case Entry"], ["proof (state)\nthis:\n  n = Entry\n\ngoal (2 subgoals):\n 1. n = Entry \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>CFG.pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  ProcCFG.pred (kind a) s\n  n = Entry", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  ProcCFG.pred (kind a) s\n  n = Entry\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case Exit"], ["proof (state)\nthis:\n  n = Exit\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit", "have False"], ["proof (prove)\nusing this:\n  c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n'\n  n = Exit\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n = Exit \\<Longrightarrow> ProcCFG.pred (kind a) s'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by simp"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case (MainReturn l p es rets l' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; (p, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets \n              [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>\\<lambda>cf. snd cf = (Main, Label l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outs) =\n        kind a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  kind a =\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')", "show ?case"], ["proof (prove)\nusing this:\n  kind a =\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs)\n  prog \\<turnstile> Label\n                     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p, ins, outs, c) \\<in> set procs\n  (p, Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'(rets [:=]\n        map cf outs) =\n  kind a\n  (Main, Label l') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by fastforce"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "case (ProcReturn p ins outs c l p' es rets l' ins' outs' c')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                  cf'(rets' [:=] map cf outs') =\n        kind a;\n        (p, Label l') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "with \\<open>\\<lambda>cf. snd cf = (p, Label l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets [:=] map cf outs') =\n        kind a\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  kind a =\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs')\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')", "show ?case"], ["proof (prove)\nusing this:\n  kind a =\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs')\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p', Exit) = sourcenode a\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets \n            [:=] map cf outs') =\n  kind a\n  (p, Label l') = targetnode a\n  ProcCFG.pred (kind a) s\n  \\<forall>V\\<in>Use wfp (sourcenode a). state_val s V = state_val s' V\n  length s = length s'\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. ProcCFG.pred (kind a) s'", "by fastforce"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n        kind a;\n        (p, Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(p, Label\n                     l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                      es' =\n        kind a;\n        (p', Entry) = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a; ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (p, n') = targetnode a;\n        ProcCFG.pred (kind a) s;\n        \\<forall>V\\<in>Use wfp (sourcenode a).\n           state_val s V = state_val s' V;\n        length s = length s'; snd (hd s) = snd (hd s')\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.pred (kind a) s'", "qed(auto dest:sym)"], ["proof (state)\nthis:\n  ProcCFG.pred (kind a) s'\n\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q r p fs ins outs"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"(p, ins, outs) \\<in> set (lift_procs wfp)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)", "show \"length fs = length ins\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. length fs = length ins", "proof(induct rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "case (MainCall l p' es rets n' ins' outs' c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', ins', outs', c) \\<in> set procs\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "hence \"fs = map interpret es\" and \"p' = p\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', ins', outs', c) \\<in> set procs\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. fs = map interpret es &&& p' = p", "by simp_all"], ["proof (state)\nthis:\n  fs = map interpret es\n  p' = p\n\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "with wf \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close>\n        \\<open>(p', ins', outs', c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  (p', ins', outs', c) \\<in> set procs\n  fs = map interpret es\n  p' = p", "have [simp]:\"ins' = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  (p', ins', outs', c) \\<in> set procs\n  fs = map interpret es\n  p' = p\n\ngoal (1 subgoal):\n 1. ins' = ins", "by fastforce"], ["proof (state)\nthis:\n  ins' = ins\n\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"containsCall procs prog [] p'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] p'\n\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "with \\<open>wf prog procs\\<close> \\<open>(p', ins', outs', c) \\<in> set procs\\<close>\n        \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c) \\<in> set procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog [] p'", "have \"length es = length ins\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c) \\<in> set procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog [] p'\n\ngoal (1 subgoal):\n 1. length es = length ins", "by fastforce"], ["proof (state)\nthis:\n  length es = length ins\n\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "with \\<open>fs = map interpret es\\<close>"], ["proof (chain)\npicking this:\n  fs = map interpret es\n  length es = length ins", "show ?case"], ["proof (prove)\nusing this:\n  fs = map interpret es\n  length es = length ins\n\ngoal (1 subgoal):\n 1. length fs = length ins", "by simp"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "case (ProcCall px insx outsx c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, insx, outsx, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "hence \"fs = map interpret es'\" and \"p' = p\""], ["proof (prove)\nusing this:\n  (px, insx, outsx, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. fs = map interpret es' &&& p' = p", "by simp_all"], ["proof (state)\nthis:\n  fs = map interpret es'\n  p' = p\n\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "with wf \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close>\n        \\<open>(p', ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  (p', ins', outs', c') \\<in> set procs\n  fs = map interpret es'\n  p' = p", "have [simp]:\"ins' = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  (p', ins', outs', c') \\<in> set procs\n  fs = map interpret es'\n  p' = p\n\ngoal (1 subgoal):\n 1. ins' = ins", "by fastforce"], ["proof (state)\nthis:\n  ins' = ins\n\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "from \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs c [] p'\""], ["proof (prove)\nusing this:\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs c [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs c [] p'\n\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "with \\<open>containsCall procs prog ps px\\<close> \\<open>(px, insx, outsx, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, insx, outsx, c) \\<in> set procs\n  containsCall procs c [] p'", "have \"containsCall procs prog (ps@[px]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, insx, outsx, c) \\<in> set procs\n  containsCall procs c [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [px]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "with \\<open>wf prog procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n        \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'", "have \"length es' = length ins\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. length es' = length ins", "by fastforce"], ["proof (state)\nthis:\n  length es' = length ins\n\ngoal (7 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "with \\<open>fs = map interpret es'\\<close>"], ["proof (chain)\npicking this:\n  fs = map interpret es'\n  length es' = length ins", "show ?case"], ["proof (prove)\nusing this:\n  fs = map interpret es'\n  length es' = length ins\n\ngoal (1 subgoal):\n 1. length fs = length ins", "by simp"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (6 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>pa insa outsa c n et n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa;\n        (\\<lambda>s. False)\\<^sub>\\<surd> =\n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "qed auto"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q r p fs a' Q' r' p' fs' s s'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"valid_edge wfp a'\" and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\" \n      and \"sourcenode a = sourcenode a'\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge wfp a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  sourcenode a = sourcenode a'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\"\n      and \"prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge wfp a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  sourcenode a = sourcenode a'\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode\n                             a -kind a\\<rightarrow> targetnode a &&&\n    prog,procs \\<turnstile> sourcenode\n                             a' -kind a'\\<rightarrow> targetnode a'", "by(simp_all add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge wfp a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        sourcenode a = sourcenode a'; ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'", "show \"a = a'\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. a = a'", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "case (MainCall l px es rets n' insx outsx cx)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  (px, insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>px\\<^esub>map interpret es =\n  kind a\n  (px, Entry) = targetnode a\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "from \\<open>prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\\<close>\n        \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close> \n        \\<open>(Main, Label l) = sourcenode a\\<close> \\<open>sourcenode a = sourcenode a'\\<close>\n        \\<open>prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> wf"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  (Main, Label l) = sourcenode a\n  sourcenode a = sourcenode a'\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  well_formed procs", "have \"targetnode a' = (px, Entry)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  (Main, Label l) = sourcenode a\n  sourcenode a = sourcenode a'\n  prog \\<turnstile> Label l -CEdge (px, es, rets)\\<rightarrow>\\<^sub>p n'\n  well_formed procs\n\ngoal (1 subgoal):\n 1. targetnode a' = (px, Entry)", "by(fastforce elim!:PCFG.cases dest:Proc_CFG_Call_nodes_eq)"], ["proof (state)\nthis:\n  targetnode a' = (px, Entry)\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>valid_edge wfp a\\<close> \\<open>valid_edge wfp a'\\<close>\n        \\<open>sourcenode a = sourcenode a'\\<close> \\<open>(px, Entry) = targetnode a\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  (px, Entry) = targetnode a\n  well_formed procs\n  targetnode a' = (px, Entry)", "have \"kind a = kind a'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  (px, Entry) = targetnode a\n  well_formed procs\n  targetnode a' = (px, Entry)\n\ngoal (1 subgoal):\n 1. kind a = kind a'", "by(fastforce intro:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  kind a = kind a'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>l pa es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, ins, outs, c) \\<in> set procs; (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>sourcenode a = sourcenode a'\\<close> \\<open>(px, Entry) = targetnode a\\<close>\n        \\<open>targetnode a' = (px, Entry)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  (px, Entry) = targetnode a\n  targetnode a' = (px, Entry)\n  kind a = kind a'", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  (px, Entry) = targetnode a\n  targetnode a' = (px, Entry)\n  kind a = kind a'\n\ngoal (1 subgoal):\n 1. a = a'", "by(cases a,cases a',auto)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "case (ProcCall px ins outs c l px' es rets l' insx outsx cx)"], ["proof (state)\nthis:\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px', insx, outsx, cx) \\<in> set procs\n  containsCall procs prog ps_ px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>px'\\<^esub>map interpret es =\n  kind a\n  (px', Entry) = targetnode a\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px', insx, outsx, cx) \\<in> set procs\n  containsCall procs prog ps_ px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>px'\\<^esub>map interpret es =\n  kind a\n  (px', Entry) = targetnode a\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'", "have \"px \\<noteq> Main\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (px, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px', insx, outsx, cx) \\<in> set procs\n  containsCall procs prog ps_ px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>px'\\<^esub>map interpret es =\n  kind a\n  (px', Entry) = targetnode a\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n\ngoal (1 subgoal):\n 1. px \\<noteq> Main", "by fastforce"], ["proof (state)\nthis:\n  px \\<noteq> Main\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\\<close>\n        \\<open>kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>\n        \\<open>(px, Label l) = sourcenode a\\<close> \\<open>sourcenode a = sourcenode a'\\<close>\n        \\<open>c \\<turnstile> Label l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>\n        \\<open>(px', insx, outsx, cx) \\<in> set procs\\<close> \\<open>(px, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  (px, Label l) = sourcenode a\n  sourcenode a = sourcenode a'\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px', insx, outsx, cx) \\<in> set procs\n  (px, ins, outs, c) \\<in> set procs\n  px \\<noteq> Main", "have \"targetnode a' = (px', Entry)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a' -kind a'\\<rightarrow> targetnode a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  (px, Label l) = sourcenode a\n  sourcenode a = sourcenode a'\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px', insx, outsx, cx) \\<in> set procs\n  (px, ins, outs, c) \\<in> set procs\n  px \\<noteq> Main\n\ngoal (1 subgoal):\n 1. targetnode a' = (px', Entry)", "proof(induct n\\<equiv>\"sourcenode a'\" et\\<equiv>\"kind a'\" n'\\<equiv>\"targetnode a'\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(kind a')\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a'; (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 2. \\<And>p insa outsa ca n n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge (kind a')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 3. \\<And>la p esa retsa n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs;\n        (Main, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret esa =\n        kind a';\n        (p, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 4. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es' =\n        kind a';\n        (p'a, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 5. \\<And>la p esa retsa l'a insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs; (p, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               cf'(retsa [:=] map cf outsa) =\n        kind a';\n        (Main, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 6. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p'a, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs') =\n        kind a';\n        (p, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 7. \\<And>n p esa retsa n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 8. \\<And>p insa outsa ca n p'a es' rets' n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)", "case (ProcCall p insa outsa ca la p'a es' rets' l'a ins' outs' c')"], ["proof (state)\nthis:\n  (p, insa, outsa, ca) \\<in> set procs\n  ca \\<turnstile> Label\n                   la -CEdge\n                        (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l'a\n  (p'a, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p, Label la) = sourcenode a'\n  \\<lambda>s.\n     True:(p, Label\n               l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n  kind a'\n  (p'a, Entry) = targetnode a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  (px, Label l) = sourcenode a\n  sourcenode a = sourcenode a'\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px', insx, outsx, cx) \\<in> set procs\n  (px, ins, outs, c) \\<in> set procs\n  px \\<noteq> Main\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(kind a')\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a'; (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 2. \\<And>p insa outsa ca n n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge (kind a')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 3. \\<And>la p esa retsa n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs;\n        (Main, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret esa =\n        kind a';\n        (p, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 4. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es' =\n        kind a';\n        (p'a, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 5. \\<And>la p esa retsa l'a insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs; (p, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               cf'(retsa [:=] map cf outsa) =\n        kind a';\n        (Main, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 6. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p'a, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs') =\n        kind a';\n        (p, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 7. \\<And>n p esa retsa n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 8. \\<And>p insa outsa ca n p'a es' rets' n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)", "hence [simp]:\"px = p\" \"l = la\""], ["proof (prove)\nusing this:\n  (p, insa, outsa, ca) \\<in> set procs\n  ca \\<turnstile> Label\n                   la -CEdge\n                        (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l'a\n  (p'a, ins', outs', c') \\<in> set procs\n  containsCall procs prog ps_ p\n  (p, Label la) = sourcenode a'\n  \\<lambda>s.\n     True:(p, Label\n               l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n  kind a'\n  (p'a, Entry) = targetnode a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  (px, Label l) = sourcenode a\n  sourcenode a = sourcenode a'\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n  (px', insx, outsx, cx) \\<in> set procs\n  (px, ins, outs, c) \\<in> set procs\n  px \\<noteq> Main\n\ngoal (1 subgoal):\n 1. px = p &&& l = la", "by(auto dest:sym)"], ["proof (state)\nthis:\n  px = p\n  l = la\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(kind a')\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a'; (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 2. \\<And>p insa outsa ca n n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge (kind a')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 3. \\<And>la p esa retsa n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs;\n        (Main, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret esa =\n        kind a';\n        (p, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 4. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es' =\n        kind a';\n        (p'a, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 5. \\<And>la p esa retsa l'a insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs; (p, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               cf'(retsa [:=] map cf outsa) =\n        kind a';\n        (Main, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 6. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p'a, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs') =\n        kind a';\n        (p, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 7. \\<And>n p esa retsa n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 8. \\<And>p insa outsa ca n p'a es' rets' n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)", "from \\<open>(p, insa, outsa, ca) \\<in> set procs\\<close>\n          \\<open>(px, ins, outs, c) \\<in> set procs\\<close> wf"], ["proof (chain)\npicking this:\n  (p, insa, outsa, ca) \\<in> set procs\n  (px, ins, outs, c) \\<in> set procs\n  well_formed procs", "have [simp]:\"ca = c\""], ["proof (prove)\nusing this:\n  (p, insa, outsa, ca) \\<in> set procs\n  (px, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ca = c", "by auto"], ["proof (state)\nthis:\n  ca = c\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(kind a')\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a'; (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 2. \\<And>p insa outsa ca n n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge (kind a')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 3. \\<And>la p esa retsa n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs;\n        (Main, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret esa =\n        kind a';\n        (p, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 4. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es' =\n        kind a';\n        (p'a, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 5. \\<And>la p esa retsa l'a insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs; (p, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               cf'(retsa [:=] map cf outsa) =\n        kind a';\n        (Main, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 6. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p'a, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs') =\n        kind a';\n        (p, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 7. \\<And>n p esa retsa n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 8. \\<And>p insa outsa ca n p'a es' rets' n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)", "from \\<open>ca \\<turnstile> Label la -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l'a\\<close>\n          \\<open>c \\<turnstile> Label l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  ca \\<turnstile> Label\n                   la -CEdge\n                        (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l'a\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'", "have \"p'a = px'\""], ["proof (prove)\nusing this:\n  ca \\<turnstile> Label\n                   la -CEdge\n                        (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l'a\n  c \\<turnstile> Label\n                  l -CEdge (px', es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. p'a = px'", "by(fastforce dest:Proc_CFG_Call_nodes_eq)"], ["proof (state)\nthis:\n  p'a = px'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(kind a')\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a'; (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 2. \\<And>p insa outsa ca n n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge (kind a')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 3. \\<And>la p esa retsa n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs;\n        (Main, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret esa =\n        kind a';\n        (p, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 4. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(p, Label\n                     l'a)\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret\n                        es' =\n        kind a';\n        (p'a, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 5. \\<And>la p esa retsa l'a insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs; (p, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               cf'(retsa [:=] map cf outsa) =\n        kind a';\n        (Main, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 6. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p'a, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs') =\n        kind a';\n        (p, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 7. \\<And>n p esa retsa n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 8. \\<And>p insa outsa ca n p'a es' rets' n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)", "with \\<open>(p'a, Entry) = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  (p'a, Entry) = targetnode a'\n  p'a = px'", "show ?case"], ["proof (prove)\nusing this:\n  (p'a, Entry) = targetnode a'\n  p'a = px'\n\ngoal (1 subgoal):\n 1. targetnode a' = (px', Entry)", "by simp"], ["proof (state)\nthis:\n  targetnode a' = (px', Entry)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge\n(kind a')\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a'; (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 2. \\<And>p insa outsa ca n n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge (kind a')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 3. \\<And>la p esa retsa n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (p, insa, outsa, ca) \\<in> set procs;\n        (Main, Label la) = sourcenode a';\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret esa =\n        kind a';\n        (p, Entry) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 4. \\<And>la p esa retsa l'a insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p, esa, retsa)\\<rightarrow>\\<^sub>p Label l'a;\n        (p, insa, outsa, ca) \\<in> set procs; (p, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l'a)\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               cf'(retsa [:=] map cf outsa) =\n        kind a';\n        (Main, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 5. \\<And>p insa outsa ca la p'a es' rets' l'a ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p'a, es',\n                               rets')\\<rightarrow>\\<^sub>p Label l'a;\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps p; (p'a, Exit) = sourcenode a';\n        \\<lambda>cf.\n           snd cf =\n           (p, Label\n                l'a)\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs') =\n        kind a';\n        (p, Label l'a) = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 6. \\<And>n p esa retsa n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, esa, retsa)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (Main, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)\n 7. \\<And>p insa outsa ca n p'a es' rets' n' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, n) = sourcenode a';\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a';\n        (p, n') = targetnode a';\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        (px, Label l) = sourcenode a; sourcenode a = sourcenode a';\n        c \\<turnstile> Label\n                        l -CEdge\n                            (px', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (px', insx, outsx, cx) \\<in> set procs;\n        (px, ins, outs, c) \\<in> set procs; px \\<noteq> Main\\<rbrakk>\n       \\<Longrightarrow> targetnode a' = (px', Entry)", "qed(auto dest:sym)"], ["proof (state)\nthis:\n  targetnode a' = (px', Entry)\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>valid_edge wfp a\\<close> \\<open>valid_edge wfp a'\\<close>\n        \\<open>sourcenode a = sourcenode a'\\<close> \\<open>(px', Entry) = targetnode a\\<close> wf"], ["proof (chain)\npicking this:\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  (px', Entry) = targetnode a\n  well_formed procs\n  targetnode a' = (px', Entry)", "have \"kind a = kind a'\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  (px', Entry) = targetnode a\n  well_formed procs\n  targetnode a' = (px', Entry)\n\ngoal (1 subgoal):\n 1. kind a = kind a'", "by(fastforce intro:Proc_CFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  kind a = kind a'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'a\\<^esub>map interpret es' =\n        kind a;\n        (p'a, Entry) = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>sourcenode a = sourcenode a'\\<close> \\<open>(px', Entry) = targetnode a\\<close>\n        \\<open>targetnode a' = (px', Entry)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  (px', Entry) = targetnode a\n  targetnode a' = (px', Entry)\n  kind a = kind a'", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  (px', Entry) = targetnode a\n  targetnode a' = (px', Entry)\n  kind a = kind a'\n\ngoal (1 subgoal):\n 1. a = a'", "by(cases a,cases a',auto)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>pa ins outs c n n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>l pa es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, ins, outs, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outs) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>pa ins outs c l p'a es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p'a, es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p'a, ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p'a, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'a\\<^esub>\\<lambda>cf cf'.\n                cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>pa ins outs c n p'a es' rets' n' ps.\n       \\<lbrakk>(pa, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p'a, es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        prog,procs \\<turnstile> sourcenode\n                                 a' -kind a'\\<rightarrow> targetnode a';\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "qed auto"], ["proof (state)\nthis:\n  a = a'\n\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q r p fs i ins outs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix s s'::\"((char list \\<rightharpoonup> val) \\<times> node) list\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"i < length ins\"\n      and \"(p, ins, outs) \\<in> set (lift_procs wfp)\"\n      and \"\\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i. state_val s V = state_val s' V\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp); ProcCFG.pred (kind a) s;\n        ProcCFG.pred (kind a) s';\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>i < length ins\\<close> \n      \\<open>(p, ins, outs) \\<in> set (lift_procs wfp)\\<close> \n      \\<open>\\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i. state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V", "show \"CFG.params fs (state_val s) ! i = CFG.params fs (state_val s') ! i\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> sourcenode a -kind a\\<rightarrow> targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ProcCFG.params fs (state_val s) ! i =\n    ProcCFG.params fs (state_val s') ! i", "proof(induct \"sourcenode a\" \"kind a\" \"targetnode a\" rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "case (MainCall l p' es rets n' insx outsx cx)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V", "have [simp]:\"insx = ins\" \"fs = map interpret es\""], ["proof (prove)\nusing this:\n  well_formed procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p', insx, outsx, cx) \\<in> set procs\n  (Main, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. insx = ins &&& fs = map interpret es", "by auto"], ["proof (state)\nthis:\n  insx = ins\n  fs = map interpret es\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"containsCall procs prog [] p'\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. containsCall procs prog [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs prog [] p'\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>wf prog procs\\<close> \\<open>(p', insx, outsx, cx) \\<in> set procs\\<close> \n        \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', insx, outsx, cx) \\<in> set procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog [] p'", "have \"length es = length ins\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', insx, outsx, cx) \\<in> set procs\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog [] p'\n\ngoal (1 subgoal):\n 1. length es = length ins", "by fastforce"], ["proof (state)\nthis:\n  length es = length ins\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>i < length ins\\<close>"], ["proof (chain)\npicking this:\n  i < length ins\n  length es = length ins", "have \"i < length (map interpret es)\""], ["proof (prove)\nusing this:\n  i < length ins\n  length es = length ins\n\ngoal (1 subgoal):\n 1. i < length (map interpret es)", "by simp"], ["proof (state)\nthis:\n  i < length (map interpret es)\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "from \\<open>prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"ParamUses wfp (Main,Label l) = map fv es\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. ParamUses wfp (Main, Label l) = map fv es", "by(fastforce intro:ParamUses_Main_Return_target)"], ["proof (state)\nthis:\n  ParamUses wfp (Main, Label l) = map fv es\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>\\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i. state_val s V = state_val s' V\\<close>\n        \\<open>i < length (map interpret es)\\<close> \\<open>(Main, Label l) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n  i < length (map interpret es)\n  (Main, Label l) = sourcenode a\n  ParamUses wfp (Main, Label l) = map fv es", "have \" ((map (\\<lambda>e cf. interpret e cf) es)!i) (fst (hd s)) = \n        ((map (\\<lambda>e cf. interpret e cf) es)!i) (fst (hd s'))\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n  i < length (map interpret es)\n  (Main, Label l) = sourcenode a\n  ParamUses wfp (Main, Label l) = map fv es\n\ngoal (1 subgoal):\n 1. (map interpret es ! i) (state_val s) =\n    (map interpret es ! i) (state_val s')", "by(cases \"interpret (es ! i) (fst (hd s))\")(auto dest:rhs_interpret_eq)"], ["proof (state)\nthis:\n  (map interpret es ! i) (state_val s) =\n  (map interpret es ! i) (state_val s')\n\ngoal (8 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets n' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, c) \\<in> set procs;\n        (Main, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(Main,\n                 n')\\<hookrightarrow>\\<^bsub>pa\\<^esub>map interpret es =\n        kind a;\n        (pa, Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 8. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>i < length (map interpret es)\\<close>"], ["proof (chain)\npicking this:\n  i < length (map interpret es)\n  (map interpret es ! i) (state_val s) =\n  (map interpret es ! i) (state_val s')", "show ?case"], ["proof (prove)\nusing this:\n  i < length (map interpret es)\n  (map interpret es ! i) (state_val s) =\n  (map interpret es ! i) (state_val s')\n\ngoal (1 subgoal):\n 1. ProcCFG.params fs (state_val s) ! i =\n    ProcCFG.params fs (state_val s') ! i", "by(simp add:ProcCFG.params_nth)"], ["proof (state)\nthis:\n  ProcCFG.params fs (state_val s) ! i = ProcCFG.params fs (state_val s') ! i\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "case (ProcCall px insx outsx cx l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V", "have [simp]:\"ins' = ins\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps px\n  (px, Label l) = sourcenode a\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  (p', Entry) = targetnode a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. ins' = ins", "by fastforce"], ["proof (state)\nthis:\n  ins' = ins\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "from \\<open>cx \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"containsCall procs cx [] p'\""], ["proof (prove)\nusing this:\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. containsCall procs cx [] p'", "by(rule Proc_CFG_Call_containsCall)"], ["proof (state)\nthis:\n  containsCall procs cx [] p'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>containsCall procs prog ps px\\<close> \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog ps px\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p'", "have \"containsCall procs prog (ps@[px]) p'\""], ["proof (prove)\nusing this:\n  containsCall procs prog ps px\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p'\n\ngoal (1 subgoal):\n 1. containsCall procs prog (ps @ [px]) p'", "by(rule containsCall_in_proc)"], ["proof (state)\nthis:\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>wf prog procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n        \\<open>cx \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'", "have \"length es' = length ins\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  (p', ins', outs', c') \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog (ps @ [px]) p'\n\ngoal (1 subgoal):\n 1. length es' = length ins", "by fastforce"], ["proof (state)\nthis:\n  length es' = length ins\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "from \\<open>\\<lambda>s. True:(px, Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' = kind a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"fs = map interpret es'\""], ["proof (prove)\nusing this:\n  \\<lambda>s.\n     True:(px,\n           Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  kind a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. fs = map interpret es'", "by simp_all"], ["proof (state)\nthis:\n  fs = map interpret es'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "from \\<open>i < length ins\\<close> \\<open>fs = map interpret es'\\<close> \n        \\<open>length es' = length ins\\<close>"], ["proof (chain)\npicking this:\n  i < length ins\n  fs = map interpret es'\n  length es' = length ins", "have \"i < length fs\""], ["proof (prove)\nusing this:\n  i < length ins\n  fs = map interpret es'\n  length es' = length ins\n\ngoal (1 subgoal):\n 1. i < length fs", "by simp"], ["proof (state)\nthis:\n  i < length fs\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "from \\<open>(px, insx, outsx, cx) \\<in> set procs\\<close>\n        \\<open>cx \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have \"ParamUses wfp (px,Label l) = map fv es'\""], ["proof (prove)\nusing this:\n  (px, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. ParamUses wfp (px, Label l) = map fv es'", "by(auto intro!:ParamUses_Proc_Return_target simp:set_conv_nth)"], ["proof (state)\nthis:\n  ParamUses wfp (px, Label l) = map fv es'\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>\\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i. state_val s V = state_val s' V\\<close>\n        \\<open>(px, Label l) = sourcenode a\\<close> \\<open>i < length fs\\<close> \n        \\<open>fs = map interpret es'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n  (px, Label l) = sourcenode a\n  i < length fs\n  fs = map interpret es'\n  ParamUses wfp (px, Label l) = map fv es'", "have \" ((map (\\<lambda>e cf. interpret e cf) es')!i) (fst (hd s)) = \n        ((map (\\<lambda>e cf. interpret e cf) es')!i) (fst (hd s'))\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n     state_val s V = state_val s' V\n  (px, Label l) = sourcenode a\n  i < length fs\n  fs = map interpret es'\n  ParamUses wfp (px, Label l) = map fv es'\n\ngoal (1 subgoal):\n 1. (map interpret es' ! i) (state_val s) =\n    (map interpret es' ! i) (state_val s')", "by(cases \"interpret (es' ! i) (fst (hd s))\")(auto dest:rhs_interpret_eq)"], ["proof (state)\nthis:\n  (map interpret es' ! i) (state_val s) =\n  (map interpret es' ! i) (state_val s')\n\ngoal (7 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (pa, Label l) = sourcenode a;\n        \\<lambda>s.\n           True:(pa,\n                 Label\n                  l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n        kind a;\n        (p', Entry) = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 7. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "with \\<open>i < length fs\\<close> \\<open>fs = map interpret es'\\<close>"], ["proof (chain)\npicking this:\n  i < length fs\n  fs = map interpret es'\n  (map interpret es' ! i) (state_val s) =\n  (map interpret es' ! i) (state_val s')", "show ?case"], ["proof (prove)\nusing this:\n  i < length fs\n  fs = map interpret es'\n  (map interpret es' ! i) (state_val s) =\n  (map interpret es' ! i) (state_val s')\n\ngoal (1 subgoal):\n 1. ProcCFG.params fs (state_val s) ! i =\n    ProcCFG.params fs (state_val s') ! i", "by(simp add:ProcCFG.params_nth)"], ["proof (state)\nthis:\n  ProcCFG.params fs (state_val s) ! i = ProcCFG.params fs (state_val s') ! i\n\ngoal (6 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a; (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 2. \\<And>pa insa outsa c n n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge (kind a)\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 3. \\<And>l pa es rets l' insa outsa c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, c) \\<in> set procs; (pa, Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (Main,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>pa\\<^esub>\\<lambda>cf cf'. cf'(rets \n               [:=] map cf outsa) =\n        kind a;\n        (Main, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 4. \\<And>pa insa outsa c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps pa; (p', Exit) = sourcenode a;\n        \\<lambda>cf.\n           snd cf =\n           (pa,\n            Label\n             l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n               cf'(rets' [:=] map cf outs') =\n        kind a;\n        (pa, Label l') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 5. \\<And>n pa es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (Main, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a;\n        (Main, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i\n 6. \\<And>pa insa outsa c n p' es' rets' n' ps.\n       \\<lbrakk>(pa, insa, outsa, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps pa; (pa, n) = sourcenode a;\n        (\\<lambda>s. False)\\<^sub>\\<surd> = kind a; (pa, n') = targetnode a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set (lift_procs wfp);\n        \\<forall>V\\<in>ParamUses wfp (sourcenode a) ! i.\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> ProcCFG.params fs (state_val s) ! i =\n                         ProcCFG.params fs (state_val s') ! i", "qed auto"], ["proof (state)\nthis:\n  ProcCFG.params fs (state_val s) ! i = ProcCFG.params fs (state_val s') ! i\n\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q' p f' ins outs cf cf'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n      and \"(p, ins, outs) \\<in> set (lift_procs wfp)\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>valid_edge wfp a;\n        kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set (lift_procs wfp)\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' = vmap'(ParamDefs wfp (targetnode a) \n                         [:=] map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\""], ["proof (prove)\nusing this:\n  valid_edge wfp a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set (lift_procs wfp)\n\ngoal (1 subgoal):\n 1. f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)", "by(rule Return_update)"], ["proof (state)\nthis:\n  f' cf cf' = cf'(ParamDefs wfp (targetnode a) [:=] map cf outs)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a a'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"valid_edge wfp a\" and \"valid_edge wfp a'\"\n      and \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\"\n      and \"intra_kind (kind a)\" and \"intra_kind (kind a')\""], ["proof (state)\nthis:\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge wfp a; valid_edge wfp a';\n        sourcenode a = sourcenode a'; targetnode a \\<noteq> targetnode a';\n        intra_kind (kind a); intra_kind (kind a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            kind a = (Q)\\<^sub>\\<surd> \\<and>\n                            kind a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "with wf"], ["proof (chain)\npicking this:\n  well_formed procs\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  intra_kind (kind a)\n  intra_kind (kind a')", "show \"\\<exists>Q Q'. kind a = (Q)\\<^sub>\\<surd> \\<and> kind a' = (Q')\\<^sub>\\<surd> \\<and> \n      (\\<forall>cf. (Q cf \\<longrightarrow> \\<not> Q' cf) \\<and> (Q' cf \\<longrightarrow> \\<not> Q cf))\""], ["proof (prove)\nusing this:\n  well_formed procs\n  valid_edge wfp a\n  valid_edge wfp a'\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  intra_kind (kind a)\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       kind a = (Q)\\<^sub>\\<surd> \\<and>\n       kind a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>cf.\n           (Q cf \\<longrightarrow> \\<not> Q' cf) \\<and>\n           (Q' cf \\<longrightarrow> \\<not> Q cf))", "by(auto dest:Proc_CFG_deterministic simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     kind a = (Q)\\<^sub>\\<surd> \\<and>\n     kind a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>cf.\n         (Q cf \\<longrightarrow> \\<not> Q' cf) \\<and>\n         (Q' cf \\<longrightarrow> \\<not> Q cf))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry) get_proc\n   (get_return_edges wfp) (lift_procs wfp) Main (Def wfp) (Use wfp)\n   (ParamDefs wfp) (ParamUses wfp)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Instantiating the \\<open>CFGExit_wf\\<close> locale\\<close>"], ["", "interpretation ProcCFGExit_wf:\n  CFGExit_wf sourcenode targetnode kind \"valid_edge wfp\" \"(Main,Entry)\"\n  get_proc \"get_return_edges wfp\" \"lift_procs wfp\" Main \"(Main,Exit)\"\n  \"Def wfp\" \"Use wfp\" \"ParamDefs wfp\" \"ParamUses wfp\"\n  for wfp"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind (valid_edge wfp) (Main, Entry)\n     get_proc (get_return_edges wfp) (lift_procs wfp) Main (Main, Exit)\n     (Def wfp) (Use wfp) (ParamDefs wfp) (ParamUses wfp)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Def wfp (Main, Exit) = {} \\<and> Use wfp (Main, Exit) = {}", "from Exit_Def_empty Exit_Use_empty"], ["proof (chain)\npicking this:\n  Def ?wfp (Main, Exit) = {}\n  Use ?wfp (Main, Exit) = {}", "show \"Def wfp (Main, Exit) = {} \\<and> Use wfp (Main, Exit) = {}\""], ["proof (prove)\nusing this:\n  Def ?wfp (Main, Exit) = {}\n  Use ?wfp (Main, Exit) = {}\n\ngoal (1 subgoal):\n 1. Def wfp (Main, Exit) = {} \\<and> Use wfp (Main, Exit) = {}", "by simp"], ["proof (state)\nthis:\n  Def wfp (Main, Exit) = {} \\<and> Use wfp (Main, Exit) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}